// LlvmCodeGen.cpp
// Copyright (c) 2014 - The Foreseeable Future, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

#include <map>
#include <vector>
#include <memory>
#include <cfloat>
#include <utility>
#include <fstream>
#include <stdint.h>
#include <typeinfo>
#include <iostream>
#include <cinttypes>
#include "../include/parser.h"
#include "../include/codegen.h"
#include "../include/llvm_all.h"
#include "../include/compiler.h"
#include "llvm/Support/Host.h"
#include "llvm/Bitcode/ReaderWriter.h"
#include "llvm/Transforms/Instrumentation.h"

using namespace Ast;
using namespace Codegen;


namespace Codegen
{
	void doCodegen(std::string filename, Root* root, CodegenInstance* cgi)
	{
		llvm::InitializeNativeTarget();
		cgi->mainModule = new llvm::Module(Parser::getModuleName(filename), llvm::getGlobalContext());
		cgi->rootNode = root;

		std::string err;
		cgi->execEngine = llvm::EngineBuilder(cgi->mainModule).setErrorStr(&err).create();

		if(!cgi->execEngine)
		{
			fprintf(stderr, "%s", err.c_str());
			exit(1);
		}

		llvm::FunctionPassManager OurFPM = llvm::FunctionPassManager(cgi->mainModule);

		if(Compiler::getOptimisationLevel() > 0)
		{
			// Provide basic AliasAnalysis support for GVN.
			OurFPM.add(llvm::createBasicAliasAnalysisPass());

			// Do simple "peephole" optimisations and bit-twiddling optzns.
			OurFPM.add(llvm::createInstructionCombiningPass());

			// Reassociate expressions.
			OurFPM.add(llvm::createReassociatePass());

			// Eliminate Common SubExpressions.
			OurFPM.add(llvm::createGVNPass());

			// Simplify the control flow graph (deleting unreachable blocks, etc).
			OurFPM.add(llvm::createCFGSimplificationPass());

			// hmm.
			OurFPM.add(llvm::createLoadCombinePass());
			OurFPM.add(llvm::createConstantHoistingPass());
			OurFPM.add(llvm::createDelinearizationPass());
			OurFPM.add(llvm::createFlattenCFGPass());
			OurFPM.add(llvm::createScalarizerPass());
			OurFPM.add(llvm::createSinkingPass());
			OurFPM.add(llvm::createStructurizeCFGPass());
			OurFPM.add(llvm::createInstructionSimplifierPass());
			OurFPM.add(llvm::createDeadStoreEliminationPass());
			OurFPM.add(llvm::createDeadInstEliminationPass());
			OurFPM.add(llvm::createMemCpyOptPass());

			OurFPM.add(llvm::createSCCPPass());
			OurFPM.add(llvm::createAggressiveDCEPass());
		}

		// optimisation level -1 disables *everything*
		// mostly for reading the IR to debug codegen.
		if(Compiler::getOptimisationLevel() >= 0)
		{
			// always do the mem2reg pass, our generated code is too inefficient
			OurFPM.add(llvm::createPromoteMemoryToRegisterPass());
			OurFPM.add(llvm::createMergedLoadStoreMotionPass());
			OurFPM.add(llvm::createScalarReplAggregatesPass());
			OurFPM.add(llvm::createConstantPropagationPass());
			OurFPM.add(llvm::createDeadCodeEliminationPass());
		}


		OurFPM.doInitialization();

		// Set the global so the code gen can use this.
		cgi->Fpm = &OurFPM;
		cgi->pushScope();

		for(auto pair : cgi->rootNode->externalFuncs)
		{
			auto func = pair.second;

			// add to the func table
			llvm::Function* f = llvm::cast<llvm::Function>(cgi->mainModule->getOrInsertFunction(func->getName(), func->getFunctionType()));

			f->deleteBody();
			cgi->addFunctionToScope(func->getName(), FuncPair_t(f, pair.first));
		}

		for(auto pair : cgi->rootNode->externalTypes)
		{
			// "Type" and "Any" are always generated by the compiler
			// and should not be imported.

			llvm::StructType* str = llvm::cast<llvm::StructType>(pair.second);
			if(pair.first->name == "Any" || pair.first->name == "Type")
				continue;

			cgi->addNewType(str, pair.first, TypeKind::Struct);
		}

		cgi->rootNode->codegen(cgi);

		cgi->popScope();

		// free the memory
		cgi->clearScope();
	}

	void writeBitcode(std::string filename, CodegenInstance* cgi)
	{
		std::string e;
		llvm::sys::fs::OpenFlags of = (llvm::sys::fs::OpenFlags) 0;
		size_t lastdot = filename.find_last_of(".");
		std::string oname = (lastdot == std::string::npos ? filename : filename.substr(0, lastdot));
		oname += ".bc";

		llvm::raw_fd_ostream rso(oname.c_str(), e, of);

		llvm::WriteBitcodeToFile(cgi->mainModule, rso);
		rso.close();
	}



















	llvm::LLVMContext& CodegenInstance::getContext()
	{
		return llvm::getGlobalContext();
	}

	Root* CodegenInstance::getRootAST()
	{
		return rootNode;
	}





	void CodegenInstance::popScope()
	{
		this->symTabStack.pop_back();
		this->funcStack.pop_back();
	}

	void CodegenInstance::clearScope()
	{
		this->symTabStack.clear();
		this->funcStack.clear();

		this->clearNamespaceScope();
	}

	void CodegenInstance::pushScope()
	{
		this->symTabStack.push_back(SymTab_t());
		this->funcStack.push_back(FuncMap_t());
	}

	Func* CodegenInstance::getCurrentFunctionScope()
	{
		return this->funcScopeStack.back();
	}

	void CodegenInstance::setCurrentFunctionScope(Func* f)
	{
		this->funcScopeStack.push_back(f);
	}

	void CodegenInstance::clearCurrentFunctionScope()
	{
		this->funcScopeStack.pop_back();
	}


	SymTab_t& CodegenInstance::getSymTab()
	{
		return this->symTabStack.back();
	}

	SymbolPair_t* CodegenInstance::getSymPair(Expr* user, const std::string& name)
	{
		for(int i = symTabStack.size(); i-- > 0;)
		{
			SymTab_t& tab = symTabStack[i];
			if(tab.find(name) != tab.end())
				return &(tab[name]);
		}

		return nullptr;
	}

	llvm::Value* CodegenInstance::getSymInst(Expr* user, const std::string& name)
	{
		SymbolPair_t* pair = getSymPair(user, name);
		if(pair)
		{
			if(pair->first.second != SymbolValidity::Valid)
				GenError::useAfterFree(this, user, name);

			return pair->first.first;
		}

		return nullptr;
	}

	VarDecl* CodegenInstance::getSymDecl(Expr* user, const std::string& name)
	{
		SymbolPair_t* pair = nullptr;
		if((pair = getSymPair(user, name)))
			return pair->second;

		return nullptr;
	}

	bool CodegenInstance::isDuplicateSymbol(const std::string& name)
	{
		return getSymTab().find(name) != getSymTab().end();
	}

	void CodegenInstance::addSymbol(std::string name, llvm::Value* ai, VarDecl* vardecl)
	{
		SymbolValidity_t sv(ai, SymbolValidity::Valid);
		SymbolPair_t sp(sv, vardecl);

		this->getSymTab()[name] = sp;
	}


	void CodegenInstance::addNewType(llvm::Type* ltype, StructBase* atype, TypeKind e)
	{
		TypePair_t tpair(ltype, TypedExpr_t(atype, e));
		std::string mangled = this->mangleWithNamespace(atype->name, false);
		if(atype->mangledName.empty())
			atype->mangledName = mangled;

		// iceAssert(mangled == atype->mangledName);

		if(this->typeMap.find(mangled) == this->typeMap.end())
		{
			this->typeMap[mangled] = tpair;
		}
		else
		{
			error(this, atype, "Duplicate type %s", atype->name.c_str());
		}

		TypeInfo::addNewType(this, ltype, atype, e);
	}


	void CodegenInstance::removeType(std::string name)
	{
		if(this->typeMap.find(name) == this->typeMap.end())
			error("Type '%s' does not exist, cannot remove", name.c_str());

		this->typeMap.erase(name);
	}

	TypePair_t* CodegenInstance::getType(std::string name)
	{
		#if 0
		printf("finding %s\n{\n", name.c_str());
		for(auto p : this->typeMap)
			printf("\t%s\n", p.first.c_str());

		printf("}\n");
		#endif
		if(name == "Inferred" || name == "_ZN8Inferred")
			iceAssert(0);		// todo: see if this ever fires.

		if(this->typeMap.find(name) != this->typeMap.end())
			return &(this->typeMap[name]);

		return nullptr;
	}

	TypePair_t* CodegenInstance::getType(llvm::Type* type)
	{
		if(!type)
			return nullptr;

		for(auto pair : this->typeMap)
		{
			if(pair.second.first == type)
				return &this->typeMap[pair.first];
		}

		return nullptr;
	}

	bool CodegenInstance::isDuplicateType(std::string name)
	{
		return getType(name) != nullptr;
	}

	void CodegenInstance::popBracedBlock()
	{
		this->blockStack.pop_back();
	}

	BracedBlockScope* CodegenInstance::getCurrentBracedBlockScope()
	{
		return this->blockStack.size() > 0 ? &this->blockStack.back() : 0;
	}

	void CodegenInstance::pushBracedBlock(BreakableBracedBlock* block, llvm::BasicBlock* body, llvm::BasicBlock* after)
	{
		BracedBlockScope cs = std::make_pair(block, std::make_pair(body, after));
		this->blockStack.push_back(cs);
	}
















	// funcs
	void CodegenInstance::pushNamespaceScope(std::string namespc)
	{
		this->namespaceStack.push_back(namespc);
	}

	bool CodegenInstance::isValidNamespace(std::string namespc)
	{
		// check if it's imported anywhere
		for(auto nses : this->importedNamespaces)
		{
			for(std::string ns : nses)
			{
				if(ns == namespc)
					return true;
			}
		}

		return false;
	}

	void CodegenInstance::addFunctionToScope(std::string name, FuncPair_t func)
	{
		// this->funcMap[name] = func;
		this->funcStack.back()[name] = func;
	}

	FuncPair_t* CodegenInstance::getDeclaredFunc(std::string name)
	{
		for(ssize_t i = this->funcStack.size() - 1; i >= 0; i--)
		{
			FuncMap_t& tab = this->funcStack[i];

			#if 0
			printf("find %s:\n{\n", name.c_str());
			for(auto p : tab) printf("\t%s\n", p.first.c_str());
			printf("}\n");
			#endif

			if(tab.find(name) != tab.end())
				return &tab[name];
		}

		return nullptr;
	}

	static FuncPair_t* searchDeclaredFuncElsewhere(CodegenInstance* cgi, FuncCall* fc)
	{
		// mangled name
		FuncPair_t* fp = cgi->getDeclaredFunc(cgi->mangleName(cgi->mangleWithNamespace(fc->name), fc->params));
		if(fp) return fp;

		// search inside imported namespaces.
		for(auto ns : cgi->importedNamespaces)
		{
			fp = cgi->getDeclaredFunc(cgi->mangleName(cgi->mangleWithNamespace(fc->name, ns), fc->params));
			if(fp) return fp;
		}

		return 0;
	}





	FuncPair_t* CodegenInstance::getDeclaredFunc(FuncCall* fc)
	{
		// step one: unmangled name
		FuncPair_t* fp = this->getDeclaredFunc(fc->name);
		if(fp) return fp;

		fp = searchDeclaredFuncElsewhere(this, fc);
		if(fp) return fp;


		// search for generic functions.



		return 0;
	}

	bool CodegenInstance::isDuplicateFuncDecl(std::string name)
	{
		return this->getDeclaredFunc(name) != nullptr;
	}

	void CodegenInstance::popNamespaceScope()
	{
		this->namespaceStack.pop_back();
	}

	void CodegenInstance::clearNamespaceScope()
	{
		this->namespaceStack.clear();
	}



	static void searchForAndApplyExtension(CodegenInstance* cgi, std::deque<Expr*> exprs, std::string extName)
	{
		for(Expr* e : exprs)
		{
			Extension* ext		= dynamic_cast<Extension*>(e);
			NamespaceDecl* ns	= dynamic_cast<NamespaceDecl*>(e);

			if(ext && ext->mangledName == extName)
				ext->createType(cgi);

			else if(ns)
				searchForAndApplyExtension(cgi, ns->innards->statements, extName);
		}
	}

	void CodegenInstance::applyExtensionToStruct(std::string ext)
	{
		searchForAndApplyExtension(this, this->rootNode->topLevelExpressions, ext);
	}





	static std::string convertToMangled(CodegenInstance* cgi, llvm::Type* type)
	{
		std::string r = cgi->getReadableType(type);

		int ind = 0;
		r = cgi->unwrapPointerType(r, &ind);

		if(r.find("Int8") == 0)			r = "a";
		else if(r.find("Int16") == 0)	r = "s";
		else if(r.find("Int32") == 0)	r = "i";
		else if(r.find("Int64") == 0)	r = "l";
		else if(r.find("Int") == 0)		r = "l";

		else if(r.find("Uint8") == 0)	r = "h";
		else if(r.find("Uint16") == 0)	r = "t";
		else if(r.find("Uint32") == 0)	r = "j";
		else if(r.find("Uint64") == 0)	r = "m";
		else if(r.find("Uint") == 0)	r = "m";

		else if(r.find("Float32") == 0)	r = "f";
		else if(r.find("Float64") == 0)	r = "d";
		else if(r.find("Void") == 0)	r = "v";
		else
		{
			if(r.size() > 0 && r.front() == '%')
				r = r.substr(1);

			// remove anything at the back
			// find first of space, then remove everything after

			size_t firstSpace = r.find_first_of(' ');
			if(firstSpace != std::string::npos)
				r.erase(firstSpace);

			r = std::to_string(r.length()) + r;
		}

		for(int i = 0; i < ind; i++)
			r += "P";

		return r;
	}


	std::string CodegenInstance::mangleMemberFunction(StructBase* s, std::string orig, std::deque<VarDecl*> args, std::deque<std::string> ns,
		bool isStatic)
	{
		std::deque<Expr*> exprs;

		// todo: kinda hack? omit the first vardecl, since it's 'self'

		int i = 0;
		for(auto v : args)
		{
			if(i++ == 0 && !isStatic)		// static funcs don't have 'this'
				continue;

			exprs.push_back(v);
		}

		return this->mangleMemberFunction(s, orig, exprs, ns);
	}

	std::string CodegenInstance::mangleMemberFunction(StructBase* s, std::string orig, std::deque<Expr*> args)
	{
		return this->mangleMemberFunction(s, orig, args, this->namespaceStack);
	}

	std::string CodegenInstance::mangleMemberFunction(StructBase* s, std::string orig, std::deque<Expr*> args, std::deque<std::string> ns)
	{
		std::string mangled;
		mangled = (ns.size() > 0 ? "" : "_ZN") + this->mangleWithNamespace("", ns);

		// last char is 0 or E
		if(mangled.length() > 3)
		{
			if(mangled.back() == 'E')
				mangled = mangled.substr(0, mangled.length() - 1);

			iceAssert(mangled.back() == '0');
			mangled = mangled.substr(0, mangled.length() - 1);
		}

		mangled += std::to_string(s->name.length()) + s->name;
		mangled += this->mangleName(std::to_string(orig.length()) + orig + "E", args);

		return mangled;
	}

	std::string CodegenInstance::mangleName(StructBase* s, FuncCall* fc)
	{
		std::deque<llvm::Type*> largs;
		iceAssert(this->getType(s->mangledName));

		bool first = true;
		for(Expr* e : fc->params)
		{
			if(!first)
			{
				// we have an implicit self, don't push that
				largs.push_back(this->getLlvmType(e));
			}

			first = false;
		}

		std::string basename = fc->name + "E";
		std::string mangledFunc = this->mangleName(basename, largs);
		return this->mangleWithNamespace(s->name) + std::to_string(basename.length()) + mangledFunc;
	}

	std::string CodegenInstance::mangleName(StructBase* s, std::string orig)
	{
		return this->mangleWithNamespace(s->name) + std::to_string(orig.length()) + orig;
	}


	std::string CodegenInstance::mangleName(std::string base, std::deque<llvm::Type*> args)
	{
		std::string mangled = "";

		for(llvm::Type* e : args)
			mangled += convertToMangled(this, e);

		return base + (mangled.empty() ? "v" : (mangled));
	}

	std::string CodegenInstance::mangleName(std::string base, std::deque<Expr*> args)
	{
		std::deque<llvm::Type*> a;
		for(auto arg : args)
			a.push_back(this->getLlvmType(arg));

		return mangleName(base, a);
	}

	std::string CodegenInstance::mangleName(std::string base, std::deque<VarDecl*> args)
	{
		std::deque<llvm::Type*> a;
		for(auto arg : args)
			a.push_back(this->getLlvmType(arg));

		return mangleName(base, a);
	}

	std::string CodegenInstance::mangleWithNamespace(std::string original, bool isFunction)
	{
		return this->mangleWithNamespace(original, this->namespaceStack, isFunction);
	}


	std::string CodegenInstance::mangleWithNamespace(std::string original, std::deque<std::string> ns, bool isFunction)
	{
		std::string ret = "_Z";
		ret += (ns.size() > 0 ? "N" : "");

		for(std::string s : ns)
		{
			if(s.length() > 0)
				ret += std::to_string(s.length()) + s;
		}

		ret += std::to_string(original.length()) + original;
		if(ns.size() == 0)
		{
			ret = original;
		}
		else
		{
			if(isFunction)
			{
				ret += "E";
			}
		}

		return ret;
	}

	std::string CodegenInstance::mangleRawNamespace(std::string _orig)
	{
		std::string original = _orig;
		std::string ret = "_ZN";

		// we have a name now
		size_t next = 0;
		while((next = original.find_first_of("::")) != std::string::npos)
		{
			std::string ns = original.substr(0, next);
			ret += std::to_string(ns.length()) + ns;

			original = original.substr(next, -1);

			if(original.find("::") == 0)
				original = original.substr(2);
		}

		if(original.length() > 0)
			ret += std::to_string(original.length()) + original;

		return ret;
	}















	std::string CodegenInstance::unwrapPointerType(std::string type, int* _indirections)
	{
		std::string sptr = std::string("*");
		size_t ptrStrLength = sptr.length();

		int& indirections = *_indirections;
		std::string actualType = type;
		if(actualType.length() > ptrStrLength && std::equal(sptr.rbegin(), sptr.rend(), actualType.rbegin()))
		{
			while(actualType.length() > ptrStrLength && std::equal(sptr.rbegin(), sptr.rend(), actualType.rbegin()))
				actualType = actualType.substr(0, actualType.length() - ptrStrLength), indirections++;
		}

		return actualType;
	}

	static llvm::Type* recursivelyParseTuple(CodegenInstance* cgi, Expr* user, std::string& str)
	{
		iceAssert(str.length() > 0);
		iceAssert(str[0] == '(');

		str = str.substr(1);
		char front = str.front();
		if(front == ')')
			error(cgi, user, "Empty tuples are not supported");

		std::vector<llvm::Type*> types;
		while(front != ')')
		{
			std::string cur;
			while(front != ',' && front != '(' && front != ')')
			{
				cur += front;

				str.erase(str.begin());
				front = str.front();
			}

			if(front == ',' || front == ')')
			{
				bool shouldBreak = (front == ')');
				llvm::Type* ty = cgi->parseTypeFromString(user, cur);
				iceAssert(ty);

				types.push_back(ty);

				str.erase(str.begin());
				front = str.front();

				if(shouldBreak)
					break;
			}
			else if(front == '(')
			{
				iceAssert(str.front() == '(');
				types.push_back(recursivelyParseTuple(cgi, user, str));

				if(str.front() == ',')
					str.erase(str.begin());

				front = str.front();
			}
		}

		return llvm::StructType::get(cgi->getContext(), types);
	}

	llvm::Type* CodegenInstance::parseTypeFromString(Expr* user, std::string type)
	{
		if(type.length() > 0)
		{
			if(type[0] == '(')
			{
				// parse a tuple.
				llvm::Type* parsed = recursivelyParseTuple(this, user, type);
				// printf("parsed: %s\n", this->getReadableType(parsed).c_str());
				return parsed;
			}
			else
			{
				int indirections = 0;

				std::string actualType = this->unwrapPointerType(type, &indirections);
				llvm::Type* ret = this->getLlvmType(user, ExprType(actualType));

				if(ret)
				{
					while(indirections > 0)
					{
						ret = ret->getPointerTo();
						indirections--;
					}
				}

				return ret;
			}
		}
		else
		{
			return nullptr;
		}
	}















	llvm::Instruction::BinaryOps CodegenInstance::getBinaryOperator(ArithmeticOp op, bool isSigned, bool isFP)
	{
		using llvm::Instruction;
		switch(op)
		{
			case ArithmeticOp::Add:
			case ArithmeticOp::PlusEquals:
				return !isFP ? Instruction::BinaryOps::Add : Instruction::BinaryOps::FAdd;

			case ArithmeticOp::Subtract:
			case ArithmeticOp::MinusEquals:
				return !isFP ? Instruction::BinaryOps::Sub : Instruction::BinaryOps::FSub;

			case ArithmeticOp::Multiply:
			case ArithmeticOp::MultiplyEquals:
				return !isFP ? Instruction::BinaryOps::Mul : Instruction::BinaryOps::FMul;

			case ArithmeticOp::Divide:
			case ArithmeticOp::DivideEquals:
				return !isFP ? (isSigned ? Instruction::BinaryOps::SDiv : Instruction::BinaryOps::UDiv) : Instruction::BinaryOps::FDiv;

			case ArithmeticOp::Modulo:
			case ArithmeticOp::ModEquals:
				return !isFP ? (isSigned ? Instruction::BinaryOps::SRem : Instruction::BinaryOps::URem) : Instruction::BinaryOps::FRem;

			case ArithmeticOp::ShiftLeft:
			case ArithmeticOp::ShiftLeftEquals:
				return Instruction::BinaryOps::Shl;

			case ArithmeticOp::ShiftRight:
			case ArithmeticOp::ShiftRightEquals:
				return isSigned ? Instruction::BinaryOps::AShr : Instruction::BinaryOps::LShr;

			case ArithmeticOp::BitwiseAnd:
			case ArithmeticOp::BitwiseAndEquals:
				return Instruction::BinaryOps::And;

			case ArithmeticOp::BitwiseOr:
			case ArithmeticOp::BitwiseOrEquals:
				return Instruction::BinaryOps::Or;

			case ArithmeticOp::BitwiseXor:
			case ArithmeticOp::BitwiseXorEquals:
				return Instruction::BinaryOps::Xor;

			default:
				return (Instruction::BinaryOps) 0;
		}
	}

	bool CodegenInstance::isBuiltinType(llvm::Type* ltype)
	{
		return (ltype && (ltype->isIntegerTy() || ltype->isFloatingPointTy()));
	}

	bool CodegenInstance::isBuiltinType(Expr* expr)
	{
		llvm::Type* ltype = this->getLlvmType(expr);
		return this->isBuiltinType(ltype);
	}

	llvm::Type* CodegenInstance::getLlvmTypeOfBuiltin(std::string type)
	{
		if(!Compiler::getDisableLowercaseBuiltinTypes())
		{
			if(type.length() > 0)
			{
				type[0] = toupper(type[0]);
			}
		}

		if(type == "Int8")			return llvm::Type::getInt8Ty(this->getContext());
		else if(type == "Int16")	return llvm::Type::getInt16Ty(this->getContext());
		else if(type == "Int32")	return llvm::Type::getInt32Ty(this->getContext());
		else if(type == "Int64")	return llvm::Type::getInt64Ty(this->getContext());
		else if(type == "Int")		return llvm::Type::getInt64Ty(this->getContext());

		else if(type == "Uint8")	return llvm::Type::getInt8Ty(this->getContext());
		else if(type == "Uint16")	return llvm::Type::getInt16Ty(this->getContext());
		else if(type == "Uint32")	return llvm::Type::getInt32Ty(this->getContext());
		else if(type == "Uint64")	return llvm::Type::getInt64Ty(this->getContext());
		else if(type == "Uint")		return llvm::Type::getInt64Ty(this->getContext());

		else if(type == "Float32")	return llvm::Type::getFloatTy(this->getContext());
		else if(type == "Float64")	return llvm::Type::getDoubleTy(this->getContext());
		else if(type == "Bool")		return llvm::Type::getInt1Ty(this->getContext());
		else if(type == "Void")		return llvm::Type::getVoidTy(this->getContext());
		else return nullptr;
	}

	llvm::Type* CodegenInstance::getLlvmType(Ast::Expr* user, ExprType type)
	{
		if(type.isLiteral)
		{
			llvm::Type* ret = this->getLlvmTypeOfBuiltin(type.strType);
			if(ret) return ret;

			// not so lucky
			TypePair_t* tp = this->getType(type.strType);
			if(!tp)
				tp = this->getType(type.strType + "E");		// nested types. hack.

			if(!tp)
				GenError::unknownSymbol(this, user, type.strType, SymbolType::Type);

			return tp->first;
		}
		else
		{
			error(this, user, "enosup");
		}
	}

	bool CodegenInstance::isPtr(Expr* expr)
	{
		llvm::Type* ltype = this->getLlvmType(expr);
		return ltype && ltype->isPointerTy();
	}

	bool CodegenInstance::isAnyType(llvm::Type* type)
	{
		if(type->isStructTy())
		{
			if(llvm::cast<llvm::StructType>(type)->hasName() && type->getStructName() == "Any")
			{
				return true;
			}

			TypePair_t* pair = this->getType("Any");
			iceAssert(pair);

			if(pair->first == type)
				return true;
		}

		return false;
	}

	bool CodegenInstance::isEnum(ExprType type)
	{
		if(type.isLiteral)
		{
			TypePair_t* tp = 0;
			if((tp = this->getType(this->mangleWithNamespace(type.strType))))
			{
				if(tp->second.second == TypeKind::Enum)
					return true;
			}

			return false;
		}
		else
		{
			error("enosup");
		}
	}

	bool CodegenInstance::isEnum(llvm::Type* type)
	{
		if(!type) return false;

		bool res = true;
		if(!type->isStructTy())							res = false;
		if(res && type->getStructNumElements() != 1)	res = false;

		TypePair_t* tp = 0;
		if((tp = this->getType(type)))
			return tp->second.second == TypeKind::Enum;

		return res;
	}

	bool CodegenInstance::isTypeAlias(ExprType type)
	{
		if(type.isLiteral)
		{
			TypePair_t* tp = 0;
			if((tp = this->getType(this->mangleWithNamespace(type.strType))))
			{
				if(tp->second.second == TypeKind::TypeAlias)
					return true;
			}

			return false;
		}
		else
		{
			error("enosup");
		}
	}

	bool CodegenInstance::isTypeAlias(llvm::Type* type)
	{
		if(!type) return false;

		bool res = true;
		if(!type->isStructTy())							res = false;
		if(res && type->getStructNumElements() != 1)	res = false;

		TypePair_t* tp = 0;
		if((tp = this->getType(type)))
			return tp->second.second == TypeKind::TypeAlias;

		return res;
	}

	llvm::Value* CodegenInstance::lastMinuteUnwrapType(Expr* user, llvm::Value* alloca)
	{
		iceAssert(alloca->getType()->isPointerTy());
		llvm::Type* baseType = alloca->getType()->getPointerElementType();

		if(this->isEnum(baseType) || this->isTypeAlias(baseType))
		{
			TypePair_t* tp = this->getType(baseType);
			if(!tp)
				error(this, user, "Invalid type '%s'!", baseType->getStructName().str().c_str());

			iceAssert(tp->second.second == TypeKind::Enum);
			Enumeration* enr = dynamic_cast<Enumeration*>(tp->second.first);

			iceAssert(enr);
			if(enr->isStrong)
			{
				return alloca;		// fail.
			}

			return this->mainBuilder.CreateStructGEP(alloca, 0);
		}

		return alloca;
	}


	llvm::Type* CodegenInstance::getLlvmType(Expr* expr)
	{
		iceAssert(expr);
		{
			if(VarDecl* decl = dynamic_cast<VarDecl*>(expr))
			{
				if(decl->type.strType == "Inferred")
				{
					if(!decl->inferredLType)		// todo: better error detection for this
						return llvm::Type::getVoidTy(this->getContext());

					iceAssert(decl->inferredLType);
					return decl->inferredLType;
				}
				else
				{
					TypePair_t* type = this->getType(decl->type.strType);
					if(!type)
					{
						// check if it ends with pointer, and if we have a type that's un-pointered
						if(decl->type.strType.find("::") != std::string::npos)
						{
							decl->type.strType = this->mangleRawNamespace(decl->type.strType);
							return this->getLlvmType(decl);
						}

						return this->parseTypeFromString(decl, decl->type.strType);
					}

					return type->first;
				}
			}
			else if(VarRef* ref = dynamic_cast<VarRef*>(expr))
			{
				VarDecl* decl = getSymDecl(ref, ref->name);
				if(!decl)
					error(this, expr, "(%s:%d) -> Internal check failed: invalid var ref to '%s'", __FILE__, __LINE__, ref->name.c_str());

				auto x = getLlvmType(decl);
				return x;
			}
			else if(UnaryOp* uo = dynamic_cast<UnaryOp*>(expr))
			{
				if(uo->op == ArithmeticOp::Deref)
				{
					llvm::Type* ltype = this->getLlvmType(uo->expr);
					if(!ltype->isPointerTy())
						error(this, expr, "Attempted to dereference a non-pointer type '%s'", this->getReadableType(ltype).c_str());

					return this->getLlvmType(uo->expr)->getPointerElementType();
				}

				else if(uo->op == ArithmeticOp::AddrOf)
					return this->getLlvmType(uo->expr)->getPointerTo();

				else
					return this->getLlvmType(uo->expr);
			}
			else if(FuncCall* fc = dynamic_cast<FuncCall*>(expr))
			{
				FuncPair_t* fp = this->getDeclaredFunc(fc);
				if(!fp)
				{
					TypePair_t* tp = this->getType(fc->name);
					if(tp)
						return tp->first;

					error(this, expr, "Invalid function call to '%s'", fc->name.c_str());
				}

				return getLlvmType(fp->second);
			}
			else if(Func* f = dynamic_cast<Func*>(expr))
			{
				return getLlvmType(f->decl);
			}
			else if(FuncDecl* fd = dynamic_cast<FuncDecl*>(expr))
			{
				TypePair_t* type = getType(fd->type.strType);
				if(!type)
				{
					llvm::Type* ret = this->parseTypeFromString(fd, fd->type.strType);

					if(!ret)
					{
						error(this, expr, "(%s:%d) -> Internal check failed: Unknown type '%s'",
							__FILE__, __LINE__, expr->type.strType.c_str());
					}
					return ret;
				}

				return type->first;
			}
			else if(StringLiteral* sl = dynamic_cast<StringLiteral*>(expr))
			{
				if(sl->isRaw)
					return llvm::Type::getInt8PtrTy(this->getContext());

				else
				{
					auto tp = this->getType("String");
					if(!tp)
						return llvm::Type::getInt8PtrTy(this->getContext());


					return tp->first;
				}
			}
			else if(MemberAccess* ma = dynamic_cast<MemberAccess*>(expr))
			{
				VarRef* _vr = dynamic_cast<VarRef*>(ma->target);
				if(_vr)
				{
					// check for type function access
					TypePair_t* tp = 0;
					if((tp = this->getType(this->mangleWithNamespace(_vr->name))))
					{
						if(tp->second.second == TypeKind::Enum)
						{
							iceAssert(tp->first->isStructTy());
							return tp->first;
						}
						else if(tp->second.second == TypeKind::Struct)
						{
							Expr* rightmost = this->recursivelyResolveNested(ma);
							return this->getLlvmType(rightmost);
						}
					}
				}









				// first, get the type of the lhs
				llvm::Type* lhs = this->getLlvmType(ma->target);
				TypePair_t* pair = this->getType(lhs->isPointerTy() ? lhs->getPointerElementType() : lhs);

				llvm::StructType* st = llvm::dyn_cast<llvm::StructType>(lhs);

				if(!pair && (!st || (st && !st->isLiteral())))
					error(this, expr, "Invalid type '%s' for dot-operator-access", this->getReadableType(lhs).c_str());



				if((st && st->isLiteral()) || (pair->second.second == TypeKind::Tuple))
				{
					// values are 1, 2, 3 etc.
					// for now, assert this.

					Number* n = dynamic_cast<Number*>(ma->member);
					iceAssert(n);

					llvm::Type* ttype = pair ? pair->first : st;
					iceAssert(ttype->isStructTy());

					if(n->ival >= ttype->getStructNumElements())
						error(this, expr, "Tuple does not have %d elements, only %d", (int) n->ival + 1, ttype->getStructNumElements());

					return ttype->getStructElementType(n->ival);
				}
				else if(pair->second.second == TypeKind::Struct)
				{
					Struct* str = dynamic_cast<Struct*>(pair->second.first);
					iceAssert(str);

					VarRef* memberVr = dynamic_cast<VarRef*>(ma->member);
					FuncCall* memberFc = dynamic_cast<FuncCall*>(ma->member);

					if(memberVr)
					{
						for(VarDecl* mem : str->members)
						{
							if(mem->name == memberVr->name)
								return this->getLlvmType(mem);
						}
						for(ComputedProperty* c : str->cprops)
						{
							if(c->name == memberVr->name)
								return this->getLlvmType(c, c->type);
						}
					}
					else if(memberFc)
					{
						return this->getLlvmType(this->getFunctionFromStructFuncCall(str, memberFc));
					}
					else
					{
						error(this, expr, "invalid");
					}

					return this->getLlvmType(ma->member);
				}
				else
				{
					error(this, expr, "invalid");
				}
			}
			else if(BinOp* bo = dynamic_cast<BinOp*>(expr))
			{
				if(bo->op == ArithmeticOp::CmpLT || bo->op == ArithmeticOp::CmpGT || bo->op == ArithmeticOp::CmpLEq
				|| bo->op == ArithmeticOp::CmpGEq || bo->op == ArithmeticOp::CmpEq || bo->op == ArithmeticOp::CmpNEq)
				{
					return llvm::IntegerType::getInt1Ty(this->getContext());
				}
				else
				{
					// check if both are integers
					llvm::Type* ltype = this->getLlvmType(bo->left);
					llvm::Type* rtype = this->getLlvmType(bo->right);

					if(ltype->isIntegerTy() && rtype->isIntegerTy())
					{
						if(ltype->getIntegerBitWidth() > rtype->getIntegerBitWidth())
							return ltype;

						return rtype;
					}
					else
					{
						// usually the right
						return this->getLlvmType(bo->right);
					}
				}
			}
			else if(Alloc* alloc = dynamic_cast<Alloc*>(expr))
			{
				TypePair_t* type = getType(alloc->type.strType);
				if(!type)
				{
					// check if it ends with pointer, and if we have a type that's un-pointered
					if(alloc->type.strType.find("::") != std::string::npos)
					{
						alloc->type.strType = this->mangleRawNamespace(alloc->type.strType);
						return this->getLlvmType(alloc, alloc->type)->getPointerTo();
					}

					return this->parseTypeFromString(alloc, alloc->type.strType)->getPointerTo();
				}

				return type->first->getPointerTo();
			}
			else if(Number* nm = dynamic_cast<Number*>(expr))
			{
				return nm->codegen(this).result.first->getType();
			}
			else if(dynamic_cast<BoolVal*>(expr))
			{
				return llvm::Type::getInt1Ty(getContext());
			}
			else if(Return* retr = dynamic_cast<Return*>(expr))
			{
				return this->getLlvmType(retr->val);
			}
			else if(DummyExpr* dum = dynamic_cast<DummyExpr*>(expr))
			{
				if(dum->type.isLiteral)
				{
					return this->parseTypeFromString(expr, dum->type.strType);
				}
				else
				{
					return this->getLlvmType(dum->type.type);
				}
			}
			else if(dynamic_cast<If*>(expr))
			{
				return llvm::Type::getVoidTy(getContext());
			}
			else if(dynamic_cast<Typeof*>(expr))
			{
				TypePair_t* tp = this->getType("Type");
				iceAssert(tp);

				return tp->first;
			}
			else if(Tuple* tup = dynamic_cast<Tuple*>(expr))
			{
				llvm::Type* tp = tup->cachedLlvmType;
				if(!tup->didCreateType)
					tp = tup->getType(this);


				iceAssert(tp);
				return tp;
			}
		}

		error(expr, "(%s:%d) -> Internal check failed: failed to determine type '%s'", __FILE__, __LINE__, typeid(*expr).name());
	}

	bool CodegenInstance::isIntegerType(Expr* e)	{ return getLlvmType(e)->isIntegerTy(); }
	bool CodegenInstance::isSignedType(Expr* e)		{ return false; }		// TODO: something about this

	llvm::AllocaInst* CodegenInstance::allocateInstanceInBlock(llvm::Type* type, std::string name)
	{
		return this->mainBuilder.CreateAlloca(type, 0, name == "" ? "" : name);
	}

	llvm::AllocaInst* CodegenInstance::allocateInstanceInBlock(VarDecl* var)
	{
		return allocateInstanceInBlock(this->getLlvmType(var), var->name);
	}


	llvm::Value* CodegenInstance::getDefaultValue(Expr* e)
	{
		return llvm::Constant::getNullValue(getLlvmType(e));
	}

	static void StringReplace(std::string& str, const std::string& from, const std::string& to)
	{
		size_t start_pos = 0;
		while((start_pos = str.find(from, start_pos)) != std::string::npos)
		{
			str.replace(start_pos, from.length(), to);
			start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
		}
	}

	std::string CodegenInstance::getReadableType(llvm::Type* type)
	{
		std::string thing;
		llvm::raw_string_ostream rso(thing);

		type->print(rso);


		// turn it into Flax types.
		std::string ret = rso.str();

		StringReplace(ret, "void", "Void");
		StringReplace(ret, "i8", "Int8");
		StringReplace(ret, "i16", "Int16");
		StringReplace(ret, "i32", "Int32");
		StringReplace(ret, "i64", "Int64");
		StringReplace(ret, "float", "Float32");
		StringReplace(ret, "double", "Float64");

		StringReplace(ret, "i1", "Bool");

		if(ret.length() > 0 && ret[0] == '%')
			ret = ret.substr(1);

		return ret;
	}

	std::string CodegenInstance::getReadableType(llvm::Value* val)
	{
		return this->getReadableType(val->getType());
	}

	std::string CodegenInstance::getReadableType(Expr* expr)
	{
		return this->getReadableType(this->getLlvmType(expr));
	}

	void CodegenInstance::autoCastType(llvm::Type* target, llvm::Value*& right, llvm::Value* rhsPtr)
	{
		if(!target || !right)
			return;

		if(target->isIntegerTy() && right->getType()->isIntegerTy()
			&& target->getIntegerBitWidth() != right->getType()->getIntegerBitWidth())
		{
			unsigned int lBits = target->getIntegerBitWidth();
			unsigned int rBits = right->getType()->getIntegerBitWidth();

			bool shouldCast = lBits > rBits;
			// check if the RHS is a constant value
			llvm::ConstantInt* constVal = llvm::dyn_cast<llvm::ConstantInt>(right);
			if(constVal)
			{
				// check if the number fits in the LHS type
				if(lBits < 64)	// 64 is the max
				{
					if(constVal->getSExtValue() < 0)
					{
						int64_t max = -1 * powl(2, lBits - 1);
						if(constVal->getSExtValue() > max)
							shouldCast = true;
					}
					else
					{
						uint64_t max = powl(2, lBits) - 1;
						if(constVal->getZExtValue() <= max)
							shouldCast = true;
					}
				}
			}

			if(shouldCast)
				right = this->mainBuilder.CreateIntCast(right, target, false);
		}

		// check if we're passing a string to a function expecting an Int8*
		else if(target->isPointerTy() && target->getPointerElementType() == llvm::Type::getInt8Ty(this->getContext()))
		{
			if(right->getType()->isStructTy() && right->getType()->getStructName() == this->mangleWithNamespace("String", std::deque<std::string>()))
			{
				// get the struct gep:
				// Layout of string:
				// var data: Int8*
				// var allocated: Uint64

				// cast the RHS to the LHS
				iceAssert(rhsPtr);
				llvm::Value* ret = this->mainBuilder.CreateStructGEP(rhsPtr, 0);
				right = this->mainBuilder.CreateLoad(ret);	// mutating
			}
		}
		else if(target->isFloatingPointTy() && right->getType()->isIntegerTy())
		{
			right = this->mainBuilder.CreateSIToFP(right, target);
		}
	}

	void CodegenInstance::autoCastType(llvm::Value* left, llvm::Value*& right, llvm::Value* rhsPtr)
	{
		this->autoCastType(left->getType(), right, rhsPtr);
	}


























	bool CodegenInstance::isArrayType(Expr* e)
	{
		llvm::Type* ltype = this->getLlvmType(e);
		return ltype && ltype->isArrayTy();
	}

	ArithmeticOp CodegenInstance::determineArithmeticOp(std::string ch)
	{
		return Parser::mangledStringToOperator(ch);
	}

	Result_t CodegenInstance::callOperatorOnStruct(TypePair_t* pair, llvm::Value* self, ArithmeticOp op, llvm::Value* val, bool fail)
	{
		iceAssert(pair);
		iceAssert(pair->first);
		iceAssert(pair->second.first);

		if(pair->second.second != TypeKind::Struct)
		{
			if(fail)	error("!!??!?!?!");
			else		return Result_t(0, 0);
		}

		Struct* str = dynamic_cast<Struct*>(pair->second.first);
		iceAssert(str);

		llvm::Function* opov = nullptr;
		for(auto f : str->lOpOverloads)
		{
			if(f.first == op && (f.second->getArgumentList().back().getType() == val->getType()))
			{
				opov = f.second;
				break;
			}
		}

		if(!opov)
		{
			if(fail)	GenError::noOpOverload(this, str, str->name, op);
			else		return Result_t(0, 0);
		}

		// get the function with the same name in the current module
		opov = this->mainModule->getFunction(opov->getName());
		iceAssert(opov);

		// try the assign op.
		if(op == ArithmeticOp::Assign || op == ArithmeticOp::PlusEquals || op == ArithmeticOp::MinusEquals
		|| op == ArithmeticOp::MultiplyEquals || op == ArithmeticOp::DivideEquals)
		{
			// check args.
			llvm::Value* ret = mainBuilder.CreateCall2(opov, self, val);
			return Result_t(ret, self);
		}
		else if(op == ArithmeticOp::CmpEq || op == ArithmeticOp::Add || op == ArithmeticOp::Subtract || op == ArithmeticOp::Multiply
		|| op == ArithmeticOp::Divide)
		{
			// check that both types work
			return Result_t(mainBuilder.CreateCall2(opov, self, val), 0);
		}

		if(fail)	GenError::noOpOverload(this, str, str->name, op);
		return Result_t(0, 0);
	}

	llvm::Function* CodegenInstance::getStructInitialiser(Expr* user, TypePair_t* pair, std::vector<llvm::Value*> vals)
	{
		iceAssert(pair);
		iceAssert(pair->first);
		iceAssert(pair->second.first);

		Struct* str = dynamic_cast<Struct*>(pair->second.first);

		if(pair->second.second != TypeKind::Struct)
		{
			iceAssert(pair->second.second == TypeKind::TypeAlias);
			TypeAlias* ta = dynamic_cast<TypeAlias*>(pair->second.first);
			iceAssert(ta);

			TypePair_t* tp = this->getType(ta->origType);
			iceAssert(tp);

			// todo: support typealiases of typealises.
			str = dynamic_cast<Struct*>(tp->second.first);
		}


		iceAssert(str);

		llvm::Function* initf = 0;
		for(llvm::Function* initers : str->initFuncs)
		{
			if(initers->arg_size() < 1)
				error(user, "(%s:%d) -> Internal check failed: init() should have at least one (implicit) parameter", __FILE__, __LINE__);

			if(initers->arg_size() != vals.size())
				continue;

			int i = 0;
			for(auto it = initers->arg_begin(); it != initers->arg_end(); it++, i++)
			{
				llvm::Value& arg = (*it);
				if(vals[i]->getType() != arg.getType())
					goto breakout;
			}

			// fuuuuuuuuck this is ugly
			initf = initers;
			break;

			breakout:
			continue;
		}

		if(!initf)
			GenError::invalidInitialiser(this, user, str, vals);

		return this->mainModule->getFunction(initf->getName());
	}


	Result_t CodegenInstance::assignValueToAny(llvm::Value* lhsPtr, llvm::Value* rhs, llvm::Value* rhsPtr)
	{
		llvm::Value* typegep = this->mainBuilder.CreateStructGEP(lhsPtr, 0);	// Any
		typegep = this->mainBuilder.CreateStructGEP(typegep, 0, "type");		// Type

		size_t index = TypeInfo::getIndexForType(this, rhs->getType());
		iceAssert(index > 0);

		llvm::Value* constint = llvm::ConstantInt::get(typegep->getType()->getPointerElementType(), index);
		this->mainBuilder.CreateStore(constint, typegep);



		llvm::Value* valgep = this->mainBuilder.CreateStructGEP(lhsPtr, 1, "value");
		if(rhsPtr)
		{
			// printf("rhsPtr, %s\n", this->getReadableType(valgep).c_str());
			llvm::Value* casted = this->mainBuilder.CreatePointerCast(rhsPtr, valgep->getType()->getPointerElementType(), "pcast");
			this->mainBuilder.CreateStore(casted, valgep);
		}
		else
		{
			llvm::Type* targetType = rhs->getType()->isIntegerTy() ? valgep->getType()->getPointerElementType() : llvm::IntegerType::getInt64Ty(this->getContext());


			if(rhs->getType()->isIntegerTy())
			{
				llvm::Value* casted = this->mainBuilder.CreateIntToPtr(rhs, targetType);
				this->mainBuilder.CreateStore(casted, valgep);
			}
			else
			{
				llvm::Value* casted = this->mainBuilder.CreateBitCast(rhs, targetType);
				casted = this->mainBuilder.CreateIntToPtr(casted, valgep->getType()->getPointerElementType());
				this->mainBuilder.CreateStore(casted, valgep);
			}
		}

		return Result_t(this->mainBuilder.CreateLoad(lhsPtr), lhsPtr);
	}


	Result_t CodegenInstance::extractValueFromAny(llvm::Type* type, llvm::Value* ptr)
	{
		llvm::Value* valgep = this->mainBuilder.CreateStructGEP(ptr, 1);
		llvm::Value* loadedval = this->mainBuilder.CreateLoad(valgep);

		if(type->isStructTy())
		{
			// use pointer stuff
			llvm::Value* valptr = this->mainBuilder.CreatePointerCast(loadedval, type->getPointerTo());
			llvm::Value* loaded = this->mainBuilder.CreateLoad(valptr);

			return Result_t(loaded, valptr);
		}
		else
		{
			// the pointer is actually a literal
			llvm::Type* targetType = type->isIntegerTy() ? type : llvm::IntegerType::getInt64Ty(this->getContext());
			llvm::Value* val = this->mainBuilder.CreatePtrToInt(loadedval, targetType);

			if(val->getType() != type)
			{
				val = this->mainBuilder.CreateBitCast(val, type);
			}

			return Result_t(val, 0);
		}
	}






	Result_t CodegenInstance::doPointerArithmetic(ArithmeticOp op, llvm::Value* lhs, llvm::Value* lhsPtr, llvm::Value* rhs)
	{
		iceAssert(lhs->getType()->isPointerTy() && rhs->getType()->isIntegerTy()
		&& (op == ArithmeticOp::Add || op == ArithmeticOp::Subtract));

		llvm::Instruction::BinaryOps lop = this->getBinaryOperator(op, false, false);
		iceAssert(lop);


		// first, multiply the RHS by the number of bits the pointer type is, divided by 8
		// eg. if int16*, then +4 would be +4 int16s, which is (4 * (8 / 4)) = 4 * 2 = 8 bytes

		uint64_t ptrWidth = this->mainModule->getDataLayout()->getPointerSizeInBits();
		uint64_t typesize = this->mainModule->getDataLayout()->getTypeSizeInBits(lhs->getType()->getPointerElementType()) / 8;
		llvm::APInt apint = llvm::APInt(ptrWidth, typesize);
		llvm::Value* intval = llvm::Constant::getIntegerValue(llvm::IntegerType::getIntNTy(this->getContext(), ptrWidth), apint);

		if(rhs->getType()->getIntegerBitWidth() != ptrWidth)
			rhs = this->mainBuilder.CreateIntCast(rhs, intval->getType(), false);


		// this is the properly adjusted thing
		llvm::Value* newrhs = this->mainBuilder.CreateMul(rhs, intval);

		// convert the lhs pointer to an int value, so we can add/sub on it
		llvm::Value* ptrval = this->mainBuilder.CreatePtrToInt(lhs, newrhs->getType());

		// create the add/sub
		llvm::Value* res = this->mainBuilder.CreateBinOp(lop, ptrval, newrhs);

		// turn the int back into a pointer, so we can store it back into the var.
		llvm::Value* tempRes = lhsPtr ? lhsPtr : this->allocateInstanceInBlock(lhs->getType());

		llvm::Value* properres = this->mainBuilder.CreateIntToPtr(res, lhs->getType());
		this->mainBuilder.CreateStore(properres, tempRes);
		return Result_t(properres, tempRes);
	}


	static void errorNoReturn(Expr* e)
	{
		error(e, "Not all code paths return a value");
	}

	static bool verifyReturnType(CodegenInstance* cgi, Func* f, BracedBlock* bb, Return* r)
	{
		if(r)
		{
			llvm::Type* expected = 0;
			llvm::Type* have = 0;

			if(r->actualReturnValue)
				have = r->actualReturnValue->getType();

			if((have ? have : have = cgi->getLlvmType(r->val)) != (expected = cgi->getLlvmType(f->decl)))
				error(r, "Function has return type '%s', but return statement returned value of type '%s' instead", cgi->getReadableType(expected).c_str(), cgi->getReadableType(have).c_str());


			return true;
		}
		else
		{
			return false;
		}
	}

	static Return* recursiveVerifyBranch(CodegenInstance* cgi, Func* f, If* ifbranch, bool checkType);
	static Return* recursiveVerifyBlock(CodegenInstance* cgi, Func* f, BracedBlock* bb, bool checkType)
	{
		if(bb->statements.size() == 0)
			errorNoReturn(bb);

		Return* r = nullptr;
		for(Expr* e : bb->statements)
		{
			If* i = nullptr;
			if((i = dynamic_cast<If*>(e)))
			{
				Return* tmp = recursiveVerifyBranch(cgi, f, i, checkType);
				if(tmp)
				{
					r = tmp;
					break;
				}
			}

			else if((r = dynamic_cast<Return*>(e)))
				break;
		}

		if(checkType)
		{
			verifyReturnType(cgi, f, bb, r);
		}

		return r;
	}

	static Return* recursiveVerifyBranch(CodegenInstance* cgi, Func* f, If* ib, bool checkType)
	{
		Return* r = 0;
		bool first = true;
		for(std::pair<Expr*, BracedBlock*> pair : ib->_cases)	// use the preserved one
		{
			Return* tmp = recursiveVerifyBlock(cgi, f, pair.second, checkType);
			if(first)
				r = tmp;

			else if(r != nullptr)
				r = tmp;

			first = false;
		}

		if(ib->final)
		{
			if(r != nullptr)
				r = recursiveVerifyBlock(cgi, f, ib->final, checkType);
		}
		else
		{
			r = nullptr;
		}

		return r;
	}

	// if the function returns void, the return value of verifyAllPathsReturn indicates whether or not
	// all code paths have explicit returns -- if true, Func::codegen is expected to insert a ret void at the end
	// of the body.
	bool CodegenInstance::verifyAllPathsReturn(Func* func, size_t* stmtCounter, bool checkType)
	{
		if(stmtCounter)
			*stmtCounter = 0;


		bool isVoid = this->getLlvmType(func)->isVoidTy();

		// check the block
		if(func->block->statements.size() == 0 && !isVoid)
		{
			error(func, "Function %s has return type '%s', but returns nothing", func->decl->name.c_str(), func->decl->type.strType.c_str());
		}
		else if(isVoid)
		{
			return true;
		}


		// now loop through all exprs in the block
		Return* ret = 0;
		Expr* final = 0;
		for(Expr* e : func->block->statements)
		{
			if(stmtCounter)
				(*stmtCounter)++;

			If* i = dynamic_cast<If*>(e);
			final = e;

			if(i)
				ret = recursiveVerifyBranch(this, func, i, !isVoid && checkType);

			// "top level" returns we will just accept.
			if(ret || (ret = dynamic_cast<Return*>(e)))
				break;
		}

		if(!ret && (isVoid || !checkType || this->getLlvmType(final) == this->getLlvmType(func)))
			return true;

		if(!ret)
			error(func, "Function '%s' missing return statement", func->decl->name.c_str());

		if(checkType)
		{
			verifyReturnType(this, func, func->block, ret);
		}

		return false;
	}

	static void recursivelyResolveDependencies(Expr* expr, std::deque<Expr*>& resolved, std::deque<Expr*>& unresolved)
	{
		unresolved.push_back(expr);
		for(auto m : expr->dependencies)
		{
			if(std::find(resolved.begin(), resolved.end(), m.dep) == resolved.end())
			{
				if(std::find(unresolved.begin(), unresolved.end(), m.dep) != unresolved.end())
					error(0, expr, "Circular dependency!");

				recursivelyResolveDependencies(m.dep, resolved, unresolved);
			}
		}

		resolved.push_back(expr);
		unresolved.erase(std::find(unresolved.begin(), unresolved.end(), expr));
	}

	void CodegenInstance::evaluateDependencies(Expr* expr)
	{
		std::deque<Expr*> resolved;
		std::deque<Expr*> unresolved;
		recursivelyResolveDependencies(expr, resolved, unresolved);



	}

}














