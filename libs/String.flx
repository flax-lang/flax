// String.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Unicode
import LibCInterface

public class Character
{
	var utf8Bytes: Uint8* = null
	var byteCount: Uint64 = 0

	init()
	{
		self.utf8Bytes = null
		self.byteCount = 0
	}

	init(c: Int8)
	{
		self.utf8Bytes = alloc Uint8
		self.utf8Bytes[0] = c
		self.byteCount = 1
	}

	init(c: Uint8*, l: Uint64)
	{
		self.utf8Bytes = c
		self.byteCount = l
	}

	init(c: String)
	{
		self.utf8Bytes = alloc Uint8
		self.utf8Bytes[0] = c.data[0]
		self.byteCount = 1
	}


	func hasData() -> Bool
	{
		return self.utf8Bytes != null && self.byteCount > 0
	}

	func toAscii() -> Int8
	{
		if self.utf8Bytes != null && !(self.utf8Bytes[0] & 0x80)
		{
			// is ascii, return it
			return self.utf8Bytes[0]
		}
		else
		{
			return 0
		}
	}

	func isAscii() -> Bool
	{
		return self.utf8Bytes != null && !(self.utf8Bytes[0] & 0x80)
	}
}




public class String
{
	var data: Int8* = null
	var allocated: Uint64 = 0

	var length: Uint64
	{
		if self.data == null
		{
			return 0
		}

		Utf8Length(self.data)
	}

	var byteCount: Uint64
	{
		if self.data != null
		{
			return strlen(self.data)
		}

		return 0
	}

	init()
	{
		self.data = malloc(32)
		self.allocated = 32

		self.setString(@raw "")
	}

	init(str: Int8*)
	{
		self.allocated = 0
		self.setString(str)
	}

	init(str: String)
	{
		let l = strlen(str.data)

		self.grow(l + 1)
		self.setString(str.data)
	}

	func clear()
	{
		if self.allocated > 0
		{
			memset(self.data, (0 as Int32), self.length)
		}
		else
		{
			self.allocated = 0
			self.data = null
		}
	}

	func grow(newSize: Uint64)
	{
		var needFree = (self.allocated != 0)

		self.allocated = 32 * ((newSize + 31) / 32)

		let newDat = malloc(self.allocated)
		let moveCount = self.byteCount

		memcpy(newDat, self.data, moveCount)

		if needFree
		{
			free(self.data)
		}

		self.data = newDat
		self.data[self.byteCount] = 0
	}


	func setString(str: Int8*)
	{
		self.clear()
		let len = strlen(str)

		if self.allocated < len
		{
			self.grow(len + 1)
		}

		memcpy(self.data, str, len)
		self.data[len] = 0
	}




	func append(str: Int8*, addlen: Uint64)
	{
		if self.byteCount + addlen >= self.allocated
		{
			self.grow(self.byteCount + addlen + 1)
		}

		let prevBC = self.byteCount		// we need to fix a value on this, because byteCount is a computed property!!!
		memcpy(self.data + self.byteCount, str, addlen)
		self.data[prevBC + addlen] = 0
	}

	func append(char: Character)
	{
		self.append(char.utf8Bytes as Int8*, char.byteCount)
	}







	operator [] (index: Uint64) -> Character
	{
		get
		{
			if index >= self.length { return Character() }

			// else
			let chars = Utf8Index(self.data, index)
			let ret = Character(chars as Uint8*, Utf8CharLength(chars))

			return ret
		}
	}




	operator = (other: Int8*)
	{
		self.setString(other)
	}

	operator = (other: String)
	{
		self.setString(other.data)
	}

	operator += (other: String)
	{
		self.append(other.data, strlen(other))
	}

	operator += (other: Int8*)
	{
		self.append(other, strlen(other))
	}

	operator += (other: Character)
	{
		self.append(other)
	}
}



public operator + (lhs: String, rhs: String) -> String
{
	var ret: String(lhs.data)
	ret += rhs

	return ret
}

public operator + (lhs: String, rhs: Int8*) -> String
{
	var ret: String(lhs.data)
	ret += rhs

	return ret
}

public operator + (lhs: String, rhs: Character) -> String
{
	var ret: String(lhs.data)
	ret += rhs

	return ret
}

public operator == (lhs: String, rhs: Int8*) -> Bool
{
	// return false
	return strcmp(lhs.data, rhs) == 0
}

public operator == (lhs: String, rhs: String) -> Bool
{
	return strcmp(lhs.data, rhs.data) == 0
}

public operator == (lhs: Character, rhs: Character) -> Bool
{
	return lhs.byteCount == rhs.byteCount && strncmp(lhs.utf8Bytes as Int8*, rhs.utf8Bytes as Int8*, lhs.byteCount) == 0
}










