// String.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Unicode
import LibCInterface

public class Character
{
	var ascii: Int8 = 0
}

public class String
{
	var data: Int8* = null
	var allocated: Uint64 = 0

	var length: Uint64
	{
		if self.data == null
		{
			return 0
		}

		Utf8Length(self.data)
	}

	var byteCount: Uint64
	{
		if self.data != null
		{
			return strlen(self.data)
		}

		return 0
	}

	init()
	{
		self.data = malloc(32)
		self.allocated = 32

		self.setString(@raw "")
	}

	init(str: Int8*)
	{
		self.allocated = 0
		self.setString(str)
	}

	init(str: String)
	{
		let l = strlen(str.data)

		self.grow(l + 1)
		self.setString(str.data)
	}

	func clear()
	{
		if self.allocated > 0
		{
			memset(self.data, (0 as Int32), self.length)
		}
		else
		{
			self.allocated = 0
			self.data = null
		}
	}

	func grow(newSize: Uint64)
	{
		var needFree = (self.allocated != 0)

		self.allocated = 32 * ((newSize + 31) / 32)

		let newDat = malloc(self.allocated)
		let moveCount = self.byteCount

		memcpy(newDat, self.data, moveCount)

		if needFree
		{
			free(self.data)
		}

		self.data = newDat
		self.data[self.byteCount] = 0
	}


	func setString(str: Int8*)
	{
		self.clear()
		let len = strlen(str)

		if self.allocated < len
		{
			self.grow(len + 1)
		}

		memcpy(self.data, str, len)
		self.data[len] = 0
	}




	func append(str: Int8*)
	{
		let addlen = strlen(str)
		if self.byteCount + addlen >= self.allocated
		{
			self.grow(self.byteCount + addlen + 1)
		}

		let prevBC = self.byteCount		// we need to fix a value on this, because byteCount is a computed property!!!
		memcpy(self.data + self.byteCount, str, addlen)
		self.data[prevBC + addlen] = 0
	}






	operator [] (index: Int64) -> Int8
	{
		get
		{
			if index < self.length { return self.data[index] }
			else { return 0 }
		}
		set
		{
			if index < self.length
			{
				self.data[index] = newValue
			}
		}
	}




	operator = (other: Int8*)
	{
		self.setString(other)
	}

	operator = (other: String)
	{
		self.setString(other.data)
	}

	operator += (other: String)
	{
		self.append(other.data)
	}

	operator += (other: Int8*)
	{
		self.append(other)
	}
}



public operator + (this: String, other: String) -> String
{
	var ret: String(this.data)
	ret += other

	return ret
}

public operator + (this: String, other: Int8*) -> String
{
	var ret: String(this.data)
	ret += other

	return ret
}

public operator == (this: String, other: Int8*) -> Bool
{
	// return false
	return strcmp(this.data, other) == 0
}

public operator == (this: String, other: String) -> Bool
{
	return strcmp(this.data, other.data) == 0
}













