// ultratiny.flx
// Copyright (c) 2019, zhiayang
// Licensed under the Apache License Version 2.0.

// export ultratiny
// import libc as _
// import std::math

// trait Drop { fn deinit() }
// trait Copy { fn copy(other: &self) }
// trait Move { fn move(other: &self) }

// struct Foo : Drop, Copy, Move
// {
// 	fn deinit()
// 	{
// 		printf("lmao\n")
// 	}

// 	fn copy(other: &self)
// 	{
// 	}

// 	fn move(other: &mut self)
// 	{
// 	}
// }

// @entry fn main()
// {
// 	printf("hola amigo\n")
// }

import std::io
import libc as _

class X
{
	init(c: int)
	{
		this.data = c
	}

	var data: int
}

class Y: X
{
	init(c: int) : super(c: c + 30) { }
}

class Z: Y
{
	init(c: int) : super(c: c - 60) { }
}


class A
{
	init() { }
	virtual fn lol(a: Y) -> &Y
	{
		std::io::println("A::foo()")
		return alloc Y(c: 471)
	}
}

class B : A
{
	init() : super() { }

	override fn foo(a: Y) -> &Y
	{
		std::io::println("B::foo()")
		return alloc Z(c: 748)
		// return 3
	}
}

// import std::io as _

// @entry fn main()
// {
// 	println("hello, world!")
// }

// issue #0: we basically don't really even check for overriding methods properly.
// issue #1: co/contra-variance of return and parameter types for virtual methods
// issue #2: crashes when initialisers have default arguments??

// classes are a Bad Idea (tm) ):

struct Tmp
{
	k: int
	m: int

	fn meth() -> int => k * m
}

@entry fn main()
{
	// let a = B()
	// let q = a.foo(Y(c: 1)).data

	// let y: &X = alloc Y(c: 41)
	// std::io::println("y = %", y.data)

	// let q = Tmp(k: 3, m: 7).meth()

	// let q = B().foo(Y(c: 1)).data
	std::io::println("thing: %", q)
}






















