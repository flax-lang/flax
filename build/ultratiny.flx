// ultratiny.flx
// Copyright (c) 2019, zhiayang
// Licensed under the Apache License Version 2.0.

export ultratiny

import libc as _
import std::math

@compiler_support["raii_trait::drop"] trait Drop { fn deinit() }
@compiler_support["raii_trait::copy"] trait Copy { fn copy(other: &self) }
@compiler_support["raii_trait::move"] trait Move { fn move(other: &mut self) }

struct Foo : Drop, Copy, Move
{
	data: int

	fn deinit()
	{
		printf("is kill\n")
	}

	fn copy(other: &self)
	{
		printf("am copy\n")
	}

	fn move(other: &mut self)
	{
		printf("be move\n")
	}
}

/*
	tinyformat:
      115.76 real       345.23 user        26.28 sys
      117.63 real       349.01 user        26.86 sys
      118.45 real       348.56 user        26.33 sys
      115.53 real       346.42 user        26.40 sys
      115.75 real       345.30 user        26.11 sys

AVG:  116.62 real       346.90 user        26.39 sys

----------------------------------------------------

	zpr:
      101.56 real       340.92 user        22.60 sys
      102.43 real       341.59 user        22.76 sys
       99.60 real       337.48 user        22.46 sys
      100.78 real       340.38 user        22.63 sys
      102.06 real       341.57 user        22.75 sys

AVG:  101.28 real       340.38 user        22.64 sys

----------------------------------------------------

	fmt:
	  154.54 real       465.11 user        31.90 sys
	  163.59 real       481.25 user        32.88 sys
*/

class Bar
{
	var data: int
	init(x: int)
	{
		this.data = x
	}
}

fn stuff() -> Foo
{
	return Foo(data: 33)
}

fn stuff2() -> Bar
{
	return Bar(x: 57)
}

@entry fn main()
{
	let q = stuff()
	// let p = stuff2()
	printf("q = %d\n", q)
}



/*
	raii traits checklist:

	// 1. call the appropriate methods on structs.
		(kind of: still need Copy and Move)

	// 4. implement @compiler_support

	2. generalise the raii mechanism to by searching for traits instead of hardcoding for classes
	3. remove the copy/move/destruct stuff from FIR?
*/

















