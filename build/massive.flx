export massive
import "libc" as _
import "math" as _
ffi fn srand(s: i32)
ffi fn rand() -> i32

	let names0 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal0
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names0[rand() % names0.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog0 : Animal0
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation0 : Dog0
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList0<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff0()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog0 [5] {
				if i % 2 == 1   { it = alloc Dalmation0 }
				else            { it = alloc Dog0 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList0<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff0()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 0 done\n\n")
		}
	}
	

	let names1 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1[rand() % names1.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1 : Animal1
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1 : Dog1
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1 [5] {
				if i % 2 == 1   { it = alloc Dalmation1 }
				else            { it = alloc Dog1 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1 done\n\n")
		}
	}
	

	let names2 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal2
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names2[rand() % names2.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog2 : Animal2
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation2 : Dog2
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList2<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff2()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog2 [5] {
				if i % 2 == 1   { it = alloc Dalmation2 }
				else            { it = alloc Dog2 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList2<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff2()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 2 done\n\n")
		}
	}
	

	let names3 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal3
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names3[rand() % names3.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog3 : Animal3
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation3 : Dog3
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList3<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff3()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog3 [5] {
				if i % 2 == 1   { it = alloc Dalmation3 }
				else            { it = alloc Dog3 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList3<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff3()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 3 done\n\n")
		}
	}
	

	let names4 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal4
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names4[rand() % names4.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog4 : Animal4
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation4 : Dog4
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList4<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff4()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog4 [5] {
				if i % 2 == 1   { it = alloc Dalmation4 }
				else            { it = alloc Dog4 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList4<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff4()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 4 done\n\n")
		}
	}
	

	let names5 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal5
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names5[rand() % names5.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog5 : Animal5
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation5 : Dog5
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList5<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff5()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog5 [5] {
				if i % 2 == 1   { it = alloc Dalmation5 }
				else            { it = alloc Dog5 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList5<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff5()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 5 done\n\n")
		}
	}
	

	let names6 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal6
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names6[rand() % names6.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog6 : Animal6
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation6 : Dog6
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList6<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff6()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog6 [5] {
				if i % 2 == 1   { it = alloc Dalmation6 }
				else            { it = alloc Dog6 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList6<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff6()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 6 done\n\n")
		}
	}
	

	let names7 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal7
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names7[rand() % names7.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog7 : Animal7
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation7 : Dog7
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList7<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff7()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog7 [5] {
				if i % 2 == 1   { it = alloc Dalmation7 }
				else            { it = alloc Dog7 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList7<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff7()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 7 done\n\n")
		}
	}
	

	let names8 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal8
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names8[rand() % names8.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog8 : Animal8
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation8 : Dog8
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList8<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff8()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog8 [5] {
				if i % 2 == 1   { it = alloc Dalmation8 }
				else            { it = alloc Dog8 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList8<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff8()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 8 done\n\n")
		}
	}
	

	let names9 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal9
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names9[rand() % names9.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog9 : Animal9
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation9 : Dog9
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList9<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff9()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog9 [5] {
				if i % 2 == 1   { it = alloc Dalmation9 }
				else            { it = alloc Dog9 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList9<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff9()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 9 done\n\n")
		}
	}
	

	let names10 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal10
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names10[rand() % names10.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog10 : Animal10
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation10 : Dog10
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList10<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff10()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog10 [5] {
				if i % 2 == 1   { it = alloc Dalmation10 }
				else            { it = alloc Dog10 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList10<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff10()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 10 done\n\n")
		}
	}
	

	let names11 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal11
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names11[rand() % names11.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog11 : Animal11
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation11 : Dog11
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList11<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff11()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog11 [5] {
				if i % 2 == 1   { it = alloc Dalmation11 }
				else            { it = alloc Dog11 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList11<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff11()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 11 done\n\n")
		}
	}
	

	let names12 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal12
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names12[rand() % names12.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog12 : Animal12
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation12 : Dog12
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList12<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff12()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog12 [5] {
				if i % 2 == 1   { it = alloc Dalmation12 }
				else            { it = alloc Dog12 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList12<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff12()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 12 done\n\n")
		}
	}
	

	let names13 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal13
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names13[rand() % names13.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog13 : Animal13
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation13 : Dog13
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList13<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff13()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog13 [5] {
				if i % 2 == 1   { it = alloc Dalmation13 }
				else            { it = alloc Dog13 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList13<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff13()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 13 done\n\n")
		}
	}
	

	let names14 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal14
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names14[rand() % names14.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog14 : Animal14
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation14 : Dog14
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList14<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff14()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog14 [5] {
				if i % 2 == 1   { it = alloc Dalmation14 }
				else            { it = alloc Dog14 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList14<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff14()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 14 done\n\n")
		}
	}
	

	let names15 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal15
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names15[rand() % names15.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog15 : Animal15
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation15 : Dog15
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList15<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff15()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog15 [5] {
				if i % 2 == 1   { it = alloc Dalmation15 }
				else            { it = alloc Dog15 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList15<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff15()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 15 done\n\n")
		}
	}
	

	let names16 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal16
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names16[rand() % names16.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog16 : Animal16
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation16 : Dog16
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList16<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff16()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog16 [5] {
				if i % 2 == 1   { it = alloc Dalmation16 }
				else            { it = alloc Dog16 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList16<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff16()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 16 done\n\n")
		}
	}
	

	let names17 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal17
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names17[rand() % names17.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog17 : Animal17
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation17 : Dog17
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList17<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff17()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog17 [5] {
				if i % 2 == 1   { it = alloc Dalmation17 }
				else            { it = alloc Dog17 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList17<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff17()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 17 done\n\n")
		}
	}
	

	let names18 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal18
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names18[rand() % names18.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog18 : Animal18
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation18 : Dog18
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList18<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff18()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog18 [5] {
				if i % 2 == 1   { it = alloc Dalmation18 }
				else            { it = alloc Dog18 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList18<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff18()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 18 done\n\n")
		}
	}
	

	let names19 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal19
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names19[rand() % names19.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog19 : Animal19
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation19 : Dog19
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList19<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff19()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog19 [5] {
				if i % 2 == 1   { it = alloc Dalmation19 }
				else            { it = alloc Dog19 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList19<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff19()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 19 done\n\n")
		}
	}
	

	let names20 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal20
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names20[rand() % names20.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog20 : Animal20
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation20 : Dog20
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList20<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff20()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog20 [5] {
				if i % 2 == 1   { it = alloc Dalmation20 }
				else            { it = alloc Dog20 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList20<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff20()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 20 done\n\n")
		}
	}
	

	let names21 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal21
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names21[rand() % names21.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog21 : Animal21
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation21 : Dog21
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList21<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff21()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog21 [5] {
				if i % 2 == 1   { it = alloc Dalmation21 }
				else            { it = alloc Dog21 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList21<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff21()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 21 done\n\n")
		}
	}
	

	let names22 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal22
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names22[rand() % names22.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog22 : Animal22
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation22 : Dog22
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList22<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff22()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog22 [5] {
				if i % 2 == 1   { it = alloc Dalmation22 }
				else            { it = alloc Dog22 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList22<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff22()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 22 done\n\n")
		}
	}
	

	let names23 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal23
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names23[rand() % names23.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog23 : Animal23
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation23 : Dog23
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList23<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff23()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog23 [5] {
				if i % 2 == 1   { it = alloc Dalmation23 }
				else            { it = alloc Dog23 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList23<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff23()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 23 done\n\n")
		}
	}
	

	let names24 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal24
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names24[rand() % names24.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog24 : Animal24
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation24 : Dog24
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList24<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff24()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog24 [5] {
				if i % 2 == 1   { it = alloc Dalmation24 }
				else            { it = alloc Dog24 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList24<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff24()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 24 done\n\n")
		}
	}
	

	let names25 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal25
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names25[rand() % names25.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog25 : Animal25
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation25 : Dog25
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList25<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff25()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog25 [5] {
				if i % 2 == 1   { it = alloc Dalmation25 }
				else            { it = alloc Dog25 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList25<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff25()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 25 done\n\n")
		}
	}
	

	let names26 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal26
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names26[rand() % names26.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog26 : Animal26
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation26 : Dog26
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList26<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff26()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog26 [5] {
				if i % 2 == 1   { it = alloc Dalmation26 }
				else            { it = alloc Dog26 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList26<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff26()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 26 done\n\n")
		}
	}
	

	let names27 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal27
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names27[rand() % names27.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog27 : Animal27
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation27 : Dog27
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList27<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff27()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog27 [5] {
				if i % 2 == 1   { it = alloc Dalmation27 }
				else            { it = alloc Dog27 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList27<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff27()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 27 done\n\n")
		}
	}
	

	let names28 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal28
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names28[rand() % names28.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog28 : Animal28
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation28 : Dog28
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList28<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff28()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog28 [5] {
				if i % 2 == 1   { it = alloc Dalmation28 }
				else            { it = alloc Dog28 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList28<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff28()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 28 done\n\n")
		}
	}
	

	let names29 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal29
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names29[rand() % names29.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog29 : Animal29
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation29 : Dog29
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList29<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff29()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog29 [5] {
				if i % 2 == 1   { it = alloc Dalmation29 }
				else            { it = alloc Dog29 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList29<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff29()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 29 done\n\n")
		}
	}
	

	let names30 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal30
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names30[rand() % names30.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog30 : Animal30
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation30 : Dog30
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList30<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff30()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog30 [5] {
				if i % 2 == 1   { it = alloc Dalmation30 }
				else            { it = alloc Dog30 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList30<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff30()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 30 done\n\n")
		}
	}
	

	let names31 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal31
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names31[rand() % names31.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog31 : Animal31
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation31 : Dog31
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList31<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff31()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog31 [5] {
				if i % 2 == 1   { it = alloc Dalmation31 }
				else            { it = alloc Dog31 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList31<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff31()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 31 done\n\n")
		}
	}
	

	let names32 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal32
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names32[rand() % names32.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog32 : Animal32
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation32 : Dog32
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList32<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff32()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog32 [5] {
				if i % 2 == 1   { it = alloc Dalmation32 }
				else            { it = alloc Dog32 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList32<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff32()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 32 done\n\n")
		}
	}
	

	let names33 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal33
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names33[rand() % names33.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog33 : Animal33
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation33 : Dog33
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList33<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff33()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog33 [5] {
				if i % 2 == 1   { it = alloc Dalmation33 }
				else            { it = alloc Dog33 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList33<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff33()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 33 done\n\n")
		}
	}
	

	let names34 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal34
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names34[rand() % names34.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog34 : Animal34
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation34 : Dog34
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList34<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff34()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog34 [5] {
				if i % 2 == 1   { it = alloc Dalmation34 }
				else            { it = alloc Dog34 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList34<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff34()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 34 done\n\n")
		}
	}
	

	let names35 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal35
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names35[rand() % names35.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog35 : Animal35
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation35 : Dog35
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList35<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff35()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog35 [5] {
				if i % 2 == 1   { it = alloc Dalmation35 }
				else            { it = alloc Dog35 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList35<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff35()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 35 done\n\n")
		}
	}
	

	let names36 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal36
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names36[rand() % names36.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog36 : Animal36
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation36 : Dog36
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList36<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff36()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog36 [5] {
				if i % 2 == 1   { it = alloc Dalmation36 }
				else            { it = alloc Dog36 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList36<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff36()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 36 done\n\n")
		}
	}
	

	let names37 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal37
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names37[rand() % names37.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog37 : Animal37
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation37 : Dog37
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList37<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff37()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog37 [5] {
				if i % 2 == 1   { it = alloc Dalmation37 }
				else            { it = alloc Dog37 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList37<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff37()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 37 done\n\n")
		}
	}
	

	let names38 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal38
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names38[rand() % names38.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog38 : Animal38
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation38 : Dog38
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList38<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff38()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog38 [5] {
				if i % 2 == 1   { it = alloc Dalmation38 }
				else            { it = alloc Dog38 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList38<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff38()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 38 done\n\n")
		}
	}
	

	let names39 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal39
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names39[rand() % names39.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog39 : Animal39
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation39 : Dog39
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList39<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff39()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog39 [5] {
				if i % 2 == 1   { it = alloc Dalmation39 }
				else            { it = alloc Dog39 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList39<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff39()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 39 done\n\n")
		}
	}
	

	let names40 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal40
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names40[rand() % names40.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog40 : Animal40
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation40 : Dog40
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList40<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff40()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog40 [5] {
				if i % 2 == 1   { it = alloc Dalmation40 }
				else            { it = alloc Dog40 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList40<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff40()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 40 done\n\n")
		}
	}
	

	let names41 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal41
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names41[rand() % names41.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog41 : Animal41
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation41 : Dog41
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList41<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff41()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog41 [5] {
				if i % 2 == 1   { it = alloc Dalmation41 }
				else            { it = alloc Dog41 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList41<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff41()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 41 done\n\n")
		}
	}
	

	let names42 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal42
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names42[rand() % names42.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog42 : Animal42
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation42 : Dog42
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList42<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff42()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog42 [5] {
				if i % 2 == 1   { it = alloc Dalmation42 }
				else            { it = alloc Dog42 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList42<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff42()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 42 done\n\n")
		}
	}
	

	let names43 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal43
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names43[rand() % names43.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog43 : Animal43
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation43 : Dog43
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList43<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff43()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog43 [5] {
				if i % 2 == 1   { it = alloc Dalmation43 }
				else            { it = alloc Dog43 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList43<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff43()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 43 done\n\n")
		}
	}
	

	let names44 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal44
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names44[rand() % names44.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog44 : Animal44
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation44 : Dog44
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList44<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff44()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog44 [5] {
				if i % 2 == 1   { it = alloc Dalmation44 }
				else            { it = alloc Dog44 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList44<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff44()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 44 done\n\n")
		}
	}
	

	let names45 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal45
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names45[rand() % names45.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog45 : Animal45
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation45 : Dog45
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList45<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff45()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog45 [5] {
				if i % 2 == 1   { it = alloc Dalmation45 }
				else            { it = alloc Dog45 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList45<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff45()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 45 done\n\n")
		}
	}
	

	let names46 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal46
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names46[rand() % names46.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog46 : Animal46
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation46 : Dog46
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList46<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff46()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog46 [5] {
				if i % 2 == 1   { it = alloc Dalmation46 }
				else            { it = alloc Dog46 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList46<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff46()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 46 done\n\n")
		}
	}
	

	let names47 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal47
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names47[rand() % names47.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog47 : Animal47
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation47 : Dog47
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList47<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff47()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog47 [5] {
				if i % 2 == 1   { it = alloc Dalmation47 }
				else            { it = alloc Dog47 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList47<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff47()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 47 done\n\n")
		}
	}
	

	let names48 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal48
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names48[rand() % names48.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog48 : Animal48
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation48 : Dog48
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList48<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff48()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog48 [5] {
				if i % 2 == 1   { it = alloc Dalmation48 }
				else            { it = alloc Dog48 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList48<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff48()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 48 done\n\n")
		}
	}
	

	let names49 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal49
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names49[rand() % names49.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog49 : Animal49
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation49 : Dog49
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList49<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff49()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog49 [5] {
				if i % 2 == 1   { it = alloc Dalmation49 }
				else            { it = alloc Dog49 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList49<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff49()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 49 done\n\n")
		}
	}
	

	let names50 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal50
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names50[rand() % names50.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog50 : Animal50
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation50 : Dog50
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList50<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff50()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog50 [5] {
				if i % 2 == 1   { it = alloc Dalmation50 }
				else            { it = alloc Dog50 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList50<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff50()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 50 done\n\n")
		}
	}
	

	let names51 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal51
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names51[rand() % names51.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog51 : Animal51
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation51 : Dog51
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList51<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff51()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog51 [5] {
				if i % 2 == 1   { it = alloc Dalmation51 }
				else            { it = alloc Dog51 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList51<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff51()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 51 done\n\n")
		}
	}
	

	let names52 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal52
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names52[rand() % names52.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog52 : Animal52
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation52 : Dog52
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList52<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff52()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog52 [5] {
				if i % 2 == 1   { it = alloc Dalmation52 }
				else            { it = alloc Dog52 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList52<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff52()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 52 done\n\n")
		}
	}
	

	let names53 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal53
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names53[rand() % names53.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog53 : Animal53
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation53 : Dog53
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList53<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff53()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog53 [5] {
				if i % 2 == 1   { it = alloc Dalmation53 }
				else            { it = alloc Dog53 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList53<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff53()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 53 done\n\n")
		}
	}
	

	let names54 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal54
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names54[rand() % names54.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog54 : Animal54
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation54 : Dog54
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList54<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff54()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog54 [5] {
				if i % 2 == 1   { it = alloc Dalmation54 }
				else            { it = alloc Dog54 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList54<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff54()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 54 done\n\n")
		}
	}
	

	let names55 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal55
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names55[rand() % names55.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog55 : Animal55
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation55 : Dog55
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList55<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff55()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog55 [5] {
				if i % 2 == 1   { it = alloc Dalmation55 }
				else            { it = alloc Dog55 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList55<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff55()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 55 done\n\n")
		}
	}
	

	let names56 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal56
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names56[rand() % names56.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog56 : Animal56
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation56 : Dog56
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList56<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff56()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog56 [5] {
				if i % 2 == 1   { it = alloc Dalmation56 }
				else            { it = alloc Dog56 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList56<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff56()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 56 done\n\n")
		}
	}
	

	let names57 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal57
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names57[rand() % names57.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog57 : Animal57
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation57 : Dog57
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList57<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff57()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog57 [5] {
				if i % 2 == 1   { it = alloc Dalmation57 }
				else            { it = alloc Dog57 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList57<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff57()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 57 done\n\n")
		}
	}
	

	let names58 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal58
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names58[rand() % names58.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog58 : Animal58
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation58 : Dog58
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList58<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff58()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog58 [5] {
				if i % 2 == 1   { it = alloc Dalmation58 }
				else            { it = alloc Dog58 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList58<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff58()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 58 done\n\n")
		}
	}
	

	let names59 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal59
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names59[rand() % names59.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog59 : Animal59
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation59 : Dog59
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList59<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff59()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog59 [5] {
				if i % 2 == 1   { it = alloc Dalmation59 }
				else            { it = alloc Dog59 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList59<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff59()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 59 done\n\n")
		}
	}
	

	let names60 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal60
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names60[rand() % names60.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog60 : Animal60
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation60 : Dog60
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList60<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff60()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog60 [5] {
				if i % 2 == 1   { it = alloc Dalmation60 }
				else            { it = alloc Dog60 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList60<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff60()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 60 done\n\n")
		}
	}
	

	let names61 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal61
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names61[rand() % names61.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog61 : Animal61
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation61 : Dog61
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList61<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff61()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog61 [5] {
				if i % 2 == 1   { it = alloc Dalmation61 }
				else            { it = alloc Dog61 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList61<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff61()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 61 done\n\n")
		}
	}
	

	let names62 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal62
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names62[rand() % names62.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog62 : Animal62
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation62 : Dog62
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList62<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff62()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog62 [5] {
				if i % 2 == 1   { it = alloc Dalmation62 }
				else            { it = alloc Dog62 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList62<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff62()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 62 done\n\n")
		}
	}
	

	let names63 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal63
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names63[rand() % names63.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog63 : Animal63
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation63 : Dog63
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList63<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff63()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog63 [5] {
				if i % 2 == 1   { it = alloc Dalmation63 }
				else            { it = alloc Dog63 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList63<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff63()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 63 done\n\n")
		}
	}
	

	let names64 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal64
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names64[rand() % names64.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog64 : Animal64
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation64 : Dog64
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList64<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff64()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog64 [5] {
				if i % 2 == 1   { it = alloc Dalmation64 }
				else            { it = alloc Dog64 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList64<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff64()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 64 done\n\n")
		}
	}
	

	let names65 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal65
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names65[rand() % names65.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog65 : Animal65
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation65 : Dog65
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList65<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff65()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog65 [5] {
				if i % 2 == 1   { it = alloc Dalmation65 }
				else            { it = alloc Dog65 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList65<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff65()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 65 done\n\n")
		}
	}
	

	let names66 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal66
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names66[rand() % names66.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog66 : Animal66
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation66 : Dog66
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList66<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff66()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog66 [5] {
				if i % 2 == 1   { it = alloc Dalmation66 }
				else            { it = alloc Dog66 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList66<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff66()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 66 done\n\n")
		}
	}
	

	let names67 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal67
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names67[rand() % names67.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog67 : Animal67
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation67 : Dog67
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList67<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff67()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog67 [5] {
				if i % 2 == 1   { it = alloc Dalmation67 }
				else            { it = alloc Dog67 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList67<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff67()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 67 done\n\n")
		}
	}
	

	let names68 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal68
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names68[rand() % names68.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog68 : Animal68
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation68 : Dog68
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList68<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff68()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog68 [5] {
				if i % 2 == 1   { it = alloc Dalmation68 }
				else            { it = alloc Dog68 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList68<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff68()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 68 done\n\n")
		}
	}
	

	let names69 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal69
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names69[rand() % names69.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog69 : Animal69
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation69 : Dog69
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList69<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff69()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog69 [5] {
				if i % 2 == 1   { it = alloc Dalmation69 }
				else            { it = alloc Dog69 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList69<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff69()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 69 done\n\n")
		}
	}
	

	let names70 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal70
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names70[rand() % names70.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog70 : Animal70
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation70 : Dog70
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList70<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff70()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog70 [5] {
				if i % 2 == 1   { it = alloc Dalmation70 }
				else            { it = alloc Dog70 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList70<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff70()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 70 done\n\n")
		}
	}
	

	let names71 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal71
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names71[rand() % names71.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog71 : Animal71
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation71 : Dog71
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList71<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff71()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog71 [5] {
				if i % 2 == 1   { it = alloc Dalmation71 }
				else            { it = alloc Dog71 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList71<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff71()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 71 done\n\n")
		}
	}
	

	let names72 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal72
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names72[rand() % names72.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog72 : Animal72
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation72 : Dog72
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList72<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff72()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog72 [5] {
				if i % 2 == 1   { it = alloc Dalmation72 }
				else            { it = alloc Dog72 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList72<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff72()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 72 done\n\n")
		}
	}
	

	let names73 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal73
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names73[rand() % names73.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog73 : Animal73
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation73 : Dog73
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList73<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff73()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog73 [5] {
				if i % 2 == 1   { it = alloc Dalmation73 }
				else            { it = alloc Dog73 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList73<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff73()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 73 done\n\n")
		}
	}
	

	let names74 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal74
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names74[rand() % names74.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog74 : Animal74
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation74 : Dog74
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList74<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff74()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog74 [5] {
				if i % 2 == 1   { it = alloc Dalmation74 }
				else            { it = alloc Dog74 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList74<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff74()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 74 done\n\n")
		}
	}
	

	let names75 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal75
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names75[rand() % names75.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog75 : Animal75
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation75 : Dog75
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList75<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff75()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog75 [5] {
				if i % 2 == 1   { it = alloc Dalmation75 }
				else            { it = alloc Dog75 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList75<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff75()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 75 done\n\n")
		}
	}
	

	let names76 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal76
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names76[rand() % names76.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog76 : Animal76
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation76 : Dog76
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList76<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff76()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog76 [5] {
				if i % 2 == 1   { it = alloc Dalmation76 }
				else            { it = alloc Dog76 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList76<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff76()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 76 done\n\n")
		}
	}
	

	let names77 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal77
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names77[rand() % names77.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog77 : Animal77
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation77 : Dog77
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList77<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff77()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog77 [5] {
				if i % 2 == 1   { it = alloc Dalmation77 }
				else            { it = alloc Dog77 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList77<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff77()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 77 done\n\n")
		}
	}
	

	let names78 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal78
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names78[rand() % names78.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog78 : Animal78
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation78 : Dog78
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList78<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff78()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog78 [5] {
				if i % 2 == 1   { it = alloc Dalmation78 }
				else            { it = alloc Dog78 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList78<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff78()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 78 done\n\n")
		}
	}
	

	let names79 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal79
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names79[rand() % names79.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog79 : Animal79
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation79 : Dog79
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList79<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff79()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog79 [5] {
				if i % 2 == 1   { it = alloc Dalmation79 }
				else            { it = alloc Dog79 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList79<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff79()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 79 done\n\n")
		}
	}
	

	let names80 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal80
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names80[rand() % names80.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog80 : Animal80
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation80 : Dog80
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList80<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff80()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog80 [5] {
				if i % 2 == 1   { it = alloc Dalmation80 }
				else            { it = alloc Dog80 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList80<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff80()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 80 done\n\n")
		}
	}
	

	let names81 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal81
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names81[rand() % names81.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog81 : Animal81
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation81 : Dog81
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList81<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff81()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog81 [5] {
				if i % 2 == 1   { it = alloc Dalmation81 }
				else            { it = alloc Dog81 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList81<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff81()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 81 done\n\n")
		}
	}
	

	let names82 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal82
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names82[rand() % names82.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog82 : Animal82
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation82 : Dog82
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList82<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff82()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog82 [5] {
				if i % 2 == 1   { it = alloc Dalmation82 }
				else            { it = alloc Dog82 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList82<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff82()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 82 done\n\n")
		}
	}
	

	let names83 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal83
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names83[rand() % names83.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog83 : Animal83
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation83 : Dog83
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList83<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff83()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog83 [5] {
				if i % 2 == 1   { it = alloc Dalmation83 }
				else            { it = alloc Dog83 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList83<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff83()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 83 done\n\n")
		}
	}
	

	let names84 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal84
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names84[rand() % names84.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog84 : Animal84
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation84 : Dog84
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList84<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff84()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog84 [5] {
				if i % 2 == 1   { it = alloc Dalmation84 }
				else            { it = alloc Dog84 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList84<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff84()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 84 done\n\n")
		}
	}
	

	let names85 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal85
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names85[rand() % names85.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog85 : Animal85
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation85 : Dog85
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList85<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff85()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog85 [5] {
				if i % 2 == 1   { it = alloc Dalmation85 }
				else            { it = alloc Dog85 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList85<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff85()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 85 done\n\n")
		}
	}
	

	let names86 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal86
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names86[rand() % names86.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog86 : Animal86
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation86 : Dog86
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList86<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff86()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog86 [5] {
				if i % 2 == 1   { it = alloc Dalmation86 }
				else            { it = alloc Dog86 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList86<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff86()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 86 done\n\n")
		}
	}
	

	let names87 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal87
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names87[rand() % names87.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog87 : Animal87
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation87 : Dog87
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList87<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff87()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog87 [5] {
				if i % 2 == 1   { it = alloc Dalmation87 }
				else            { it = alloc Dog87 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList87<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff87()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 87 done\n\n")
		}
	}
	

	let names88 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal88
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names88[rand() % names88.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog88 : Animal88
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation88 : Dog88
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList88<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff88()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog88 [5] {
				if i % 2 == 1   { it = alloc Dalmation88 }
				else            { it = alloc Dog88 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList88<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff88()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 88 done\n\n")
		}
	}
	

	let names89 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal89
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names89[rand() % names89.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog89 : Animal89
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation89 : Dog89
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList89<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff89()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog89 [5] {
				if i % 2 == 1   { it = alloc Dalmation89 }
				else            { it = alloc Dog89 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList89<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff89()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 89 done\n\n")
		}
	}
	

	let names90 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal90
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names90[rand() % names90.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog90 : Animal90
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation90 : Dog90
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList90<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff90()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog90 [5] {
				if i % 2 == 1   { it = alloc Dalmation90 }
				else            { it = alloc Dog90 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList90<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff90()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 90 done\n\n")
		}
	}
	

	let names91 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal91
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names91[rand() % names91.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog91 : Animal91
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation91 : Dog91
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList91<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff91()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog91 [5] {
				if i % 2 == 1   { it = alloc Dalmation91 }
				else            { it = alloc Dog91 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList91<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff91()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 91 done\n\n")
		}
	}
	

	let names92 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal92
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names92[rand() % names92.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog92 : Animal92
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation92 : Dog92
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList92<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff92()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog92 [5] {
				if i % 2 == 1   { it = alloc Dalmation92 }
				else            { it = alloc Dog92 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList92<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff92()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 92 done\n\n")
		}
	}
	

	let names93 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal93
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names93[rand() % names93.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog93 : Animal93
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation93 : Dog93
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList93<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff93()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog93 [5] {
				if i % 2 == 1   { it = alloc Dalmation93 }
				else            { it = alloc Dog93 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList93<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff93()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 93 done\n\n")
		}
	}
	

	let names94 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal94
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names94[rand() % names94.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog94 : Animal94
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation94 : Dog94
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList94<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff94()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog94 [5] {
				if i % 2 == 1   { it = alloc Dalmation94 }
				else            { it = alloc Dog94 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList94<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff94()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 94 done\n\n")
		}
	}
	

	let names95 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal95
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names95[rand() % names95.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog95 : Animal95
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation95 : Dog95
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList95<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff95()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog95 [5] {
				if i % 2 == 1   { it = alloc Dalmation95 }
				else            { it = alloc Dog95 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList95<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff95()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 95 done\n\n")
		}
	}
	

	let names96 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal96
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names96[rand() % names96.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog96 : Animal96
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation96 : Dog96
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList96<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff96()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog96 [5] {
				if i % 2 == 1   { it = alloc Dalmation96 }
				else            { it = alloc Dog96 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList96<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff96()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 96 done\n\n")
		}
	}
	

	let names97 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal97
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names97[rand() % names97.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog97 : Animal97
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation97 : Dog97
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList97<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff97()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog97 [5] {
				if i % 2 == 1   { it = alloc Dalmation97 }
				else            { it = alloc Dog97 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList97<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff97()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 97 done\n\n")
		}
	}
	

	let names98 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal98
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names98[rand() % names98.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog98 : Animal98
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation98 : Dog98
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList98<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff98()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog98 [5] {
				if i % 2 == 1   { it = alloc Dalmation98 }
				else            { it = alloc Dog98 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList98<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff98()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 98 done\n\n")
		}
	}
	

	let names99 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal99
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names99[rand() % names99.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog99 : Animal99
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation99 : Dog99
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList99<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff99()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog99 [5] {
				if i % 2 == 1   { it = alloc Dalmation99 }
				else            { it = alloc Dog99 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList99<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff99()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 99 done\n\n")
		}
	}
	

	let names100 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal100
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names100[rand() % names100.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog100 : Animal100
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation100 : Dog100
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList100<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff100()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog100 [5] {
				if i % 2 == 1   { it = alloc Dalmation100 }
				else            { it = alloc Dog100 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList100<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff100()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 100 done\n\n")
		}
	}
	

	let names101 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal101
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names101[rand() % names101.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog101 : Animal101
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation101 : Dog101
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList101<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff101()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog101 [5] {
				if i % 2 == 1   { it = alloc Dalmation101 }
				else            { it = alloc Dog101 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList101<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff101()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 101 done\n\n")
		}
	}
	

	let names102 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal102
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names102[rand() % names102.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog102 : Animal102
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation102 : Dog102
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList102<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff102()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog102 [5] {
				if i % 2 == 1   { it = alloc Dalmation102 }
				else            { it = alloc Dog102 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList102<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff102()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 102 done\n\n")
		}
	}
	

	let names103 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal103
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names103[rand() % names103.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog103 : Animal103
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation103 : Dog103
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList103<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff103()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog103 [5] {
				if i % 2 == 1   { it = alloc Dalmation103 }
				else            { it = alloc Dog103 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList103<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff103()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 103 done\n\n")
		}
	}
	

	let names104 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal104
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names104[rand() % names104.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog104 : Animal104
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation104 : Dog104
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList104<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff104()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog104 [5] {
				if i % 2 == 1   { it = alloc Dalmation104 }
				else            { it = alloc Dog104 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList104<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff104()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 104 done\n\n")
		}
	}
	

	let names105 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal105
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names105[rand() % names105.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog105 : Animal105
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation105 : Dog105
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList105<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff105()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog105 [5] {
				if i % 2 == 1   { it = alloc Dalmation105 }
				else            { it = alloc Dog105 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList105<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff105()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 105 done\n\n")
		}
	}
	

	let names106 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal106
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names106[rand() % names106.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog106 : Animal106
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation106 : Dog106
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList106<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff106()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog106 [5] {
				if i % 2 == 1   { it = alloc Dalmation106 }
				else            { it = alloc Dog106 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList106<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff106()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 106 done\n\n")
		}
	}
	

	let names107 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal107
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names107[rand() % names107.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog107 : Animal107
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation107 : Dog107
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList107<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff107()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog107 [5] {
				if i % 2 == 1   { it = alloc Dalmation107 }
				else            { it = alloc Dog107 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList107<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff107()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 107 done\n\n")
		}
	}
	

	let names108 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal108
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names108[rand() % names108.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog108 : Animal108
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation108 : Dog108
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList108<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff108()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog108 [5] {
				if i % 2 == 1   { it = alloc Dalmation108 }
				else            { it = alloc Dog108 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList108<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff108()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 108 done\n\n")
		}
	}
	

	let names109 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal109
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names109[rand() % names109.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog109 : Animal109
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation109 : Dog109
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList109<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff109()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog109 [5] {
				if i % 2 == 1   { it = alloc Dalmation109 }
				else            { it = alloc Dog109 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList109<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff109()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 109 done\n\n")
		}
	}
	

	let names110 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal110
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names110[rand() % names110.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog110 : Animal110
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation110 : Dog110
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList110<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff110()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog110 [5] {
				if i % 2 == 1   { it = alloc Dalmation110 }
				else            { it = alloc Dog110 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList110<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff110()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 110 done\n\n")
		}
	}
	

	let names111 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal111
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names111[rand() % names111.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog111 : Animal111
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation111 : Dog111
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList111<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff111()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog111 [5] {
				if i % 2 == 1   { it = alloc Dalmation111 }
				else            { it = alloc Dog111 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList111<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff111()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 111 done\n\n")
		}
	}
	

	let names112 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal112
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names112[rand() % names112.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog112 : Animal112
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation112 : Dog112
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList112<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff112()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog112 [5] {
				if i % 2 == 1   { it = alloc Dalmation112 }
				else            { it = alloc Dog112 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList112<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff112()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 112 done\n\n")
		}
	}
	

	let names113 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal113
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names113[rand() % names113.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog113 : Animal113
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation113 : Dog113
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList113<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff113()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog113 [5] {
				if i % 2 == 1   { it = alloc Dalmation113 }
				else            { it = alloc Dog113 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList113<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff113()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 113 done\n\n")
		}
	}
	

	let names114 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal114
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names114[rand() % names114.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog114 : Animal114
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation114 : Dog114
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList114<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff114()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog114 [5] {
				if i % 2 == 1   { it = alloc Dalmation114 }
				else            { it = alloc Dog114 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList114<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff114()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 114 done\n\n")
		}
	}
	

	let names115 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal115
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names115[rand() % names115.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog115 : Animal115
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation115 : Dog115
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList115<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff115()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog115 [5] {
				if i % 2 == 1   { it = alloc Dalmation115 }
				else            { it = alloc Dog115 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList115<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff115()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 115 done\n\n")
		}
	}
	

	let names116 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal116
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names116[rand() % names116.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog116 : Animal116
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation116 : Dog116
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList116<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff116()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog116 [5] {
				if i % 2 == 1   { it = alloc Dalmation116 }
				else            { it = alloc Dog116 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList116<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff116()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 116 done\n\n")
		}
	}
	

	let names117 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal117
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names117[rand() % names117.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog117 : Animal117
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation117 : Dog117
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList117<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff117()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog117 [5] {
				if i % 2 == 1   { it = alloc Dalmation117 }
				else            { it = alloc Dog117 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList117<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff117()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 117 done\n\n")
		}
	}
	

	let names118 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal118
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names118[rand() % names118.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog118 : Animal118
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation118 : Dog118
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList118<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff118()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog118 [5] {
				if i % 2 == 1   { it = alloc Dalmation118 }
				else            { it = alloc Dog118 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList118<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff118()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 118 done\n\n")
		}
	}
	

	let names119 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal119
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names119[rand() % names119.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog119 : Animal119
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation119 : Dog119
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList119<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff119()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog119 [5] {
				if i % 2 == 1   { it = alloc Dalmation119 }
				else            { it = alloc Dog119 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList119<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff119()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 119 done\n\n")
		}
	}
	

	let names120 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal120
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names120[rand() % names120.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog120 : Animal120
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation120 : Dog120
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList120<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff120()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog120 [5] {
				if i % 2 == 1   { it = alloc Dalmation120 }
				else            { it = alloc Dog120 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList120<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff120()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 120 done\n\n")
		}
	}
	

	let names121 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal121
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names121[rand() % names121.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog121 : Animal121
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation121 : Dog121
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList121<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff121()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog121 [5] {
				if i % 2 == 1   { it = alloc Dalmation121 }
				else            { it = alloc Dog121 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList121<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff121()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 121 done\n\n")
		}
	}
	

	let names122 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal122
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names122[rand() % names122.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog122 : Animal122
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation122 : Dog122
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList122<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff122()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog122 [5] {
				if i % 2 == 1   { it = alloc Dalmation122 }
				else            { it = alloc Dog122 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList122<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff122()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 122 done\n\n")
		}
	}
	

	let names123 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal123
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names123[rand() % names123.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog123 : Animal123
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation123 : Dog123
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList123<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff123()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog123 [5] {
				if i % 2 == 1   { it = alloc Dalmation123 }
				else            { it = alloc Dog123 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList123<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff123()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 123 done\n\n")
		}
	}
	

	let names124 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal124
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names124[rand() % names124.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog124 : Animal124
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation124 : Dog124
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList124<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff124()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog124 [5] {
				if i % 2 == 1   { it = alloc Dalmation124 }
				else            { it = alloc Dog124 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList124<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff124()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 124 done\n\n")
		}
	}
	

	let names125 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal125
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names125[rand() % names125.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog125 : Animal125
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation125 : Dog125
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList125<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff125()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog125 [5] {
				if i % 2 == 1   { it = alloc Dalmation125 }
				else            { it = alloc Dog125 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList125<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff125()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 125 done\n\n")
		}
	}
	

	let names126 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal126
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names126[rand() % names126.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog126 : Animal126
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation126 : Dog126
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList126<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff126()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog126 [5] {
				if i % 2 == 1   { it = alloc Dalmation126 }
				else            { it = alloc Dog126 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList126<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff126()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 126 done\n\n")
		}
	}
	

	let names127 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal127
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names127[rand() % names127.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog127 : Animal127
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation127 : Dog127
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList127<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff127()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog127 [5] {
				if i % 2 == 1   { it = alloc Dalmation127 }
				else            { it = alloc Dog127 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList127<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff127()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 127 done\n\n")
		}
	}
	

	let names128 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal128
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names128[rand() % names128.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog128 : Animal128
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation128 : Dog128
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList128<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff128()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog128 [5] {
				if i % 2 == 1   { it = alloc Dalmation128 }
				else            { it = alloc Dog128 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList128<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff128()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 128 done\n\n")
		}
	}
	

	let names129 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal129
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names129[rand() % names129.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog129 : Animal129
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation129 : Dog129
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList129<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff129()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog129 [5] {
				if i % 2 == 1   { it = alloc Dalmation129 }
				else            { it = alloc Dog129 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList129<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff129()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 129 done\n\n")
		}
	}
	

	let names130 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal130
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names130[rand() % names130.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog130 : Animal130
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation130 : Dog130
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList130<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff130()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog130 [5] {
				if i % 2 == 1   { it = alloc Dalmation130 }
				else            { it = alloc Dog130 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList130<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff130()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 130 done\n\n")
		}
	}
	

	let names131 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal131
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names131[rand() % names131.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog131 : Animal131
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation131 : Dog131
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList131<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff131()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog131 [5] {
				if i % 2 == 1   { it = alloc Dalmation131 }
				else            { it = alloc Dog131 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList131<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff131()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 131 done\n\n")
		}
	}
	

	let names132 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal132
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names132[rand() % names132.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog132 : Animal132
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation132 : Dog132
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList132<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff132()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog132 [5] {
				if i % 2 == 1   { it = alloc Dalmation132 }
				else            { it = alloc Dog132 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList132<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff132()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 132 done\n\n")
		}
	}
	

	let names133 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal133
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names133[rand() % names133.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog133 : Animal133
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation133 : Dog133
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList133<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff133()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog133 [5] {
				if i % 2 == 1   { it = alloc Dalmation133 }
				else            { it = alloc Dog133 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList133<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff133()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 133 done\n\n")
		}
	}
	

	let names134 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal134
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names134[rand() % names134.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog134 : Animal134
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation134 : Dog134
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList134<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff134()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog134 [5] {
				if i % 2 == 1   { it = alloc Dalmation134 }
				else            { it = alloc Dog134 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList134<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff134()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 134 done\n\n")
		}
	}
	

	let names135 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal135
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names135[rand() % names135.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog135 : Animal135
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation135 : Dog135
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList135<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff135()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog135 [5] {
				if i % 2 == 1   { it = alloc Dalmation135 }
				else            { it = alloc Dog135 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList135<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff135()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 135 done\n\n")
		}
	}
	

	let names136 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal136
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names136[rand() % names136.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog136 : Animal136
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation136 : Dog136
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList136<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff136()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog136 [5] {
				if i % 2 == 1   { it = alloc Dalmation136 }
				else            { it = alloc Dog136 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList136<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff136()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 136 done\n\n")
		}
	}
	

	let names137 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal137
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names137[rand() % names137.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog137 : Animal137
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation137 : Dog137
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList137<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff137()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog137 [5] {
				if i % 2 == 1   { it = alloc Dalmation137 }
				else            { it = alloc Dog137 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList137<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff137()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 137 done\n\n")
		}
	}
	

	let names138 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal138
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names138[rand() % names138.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog138 : Animal138
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation138 : Dog138
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList138<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff138()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog138 [5] {
				if i % 2 == 1   { it = alloc Dalmation138 }
				else            { it = alloc Dog138 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList138<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff138()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 138 done\n\n")
		}
	}
	

	let names139 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal139
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names139[rand() % names139.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog139 : Animal139
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation139 : Dog139
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList139<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff139()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog139 [5] {
				if i % 2 == 1   { it = alloc Dalmation139 }
				else            { it = alloc Dog139 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList139<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff139()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 139 done\n\n")
		}
	}
	

	let names140 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal140
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names140[rand() % names140.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog140 : Animal140
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation140 : Dog140
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList140<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff140()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog140 [5] {
				if i % 2 == 1   { it = alloc Dalmation140 }
				else            { it = alloc Dog140 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList140<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff140()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 140 done\n\n")
		}
	}
	

	let names141 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal141
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names141[rand() % names141.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog141 : Animal141
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation141 : Dog141
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList141<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff141()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog141 [5] {
				if i % 2 == 1   { it = alloc Dalmation141 }
				else            { it = alloc Dog141 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList141<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff141()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 141 done\n\n")
		}
	}
	

	let names142 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal142
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names142[rand() % names142.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog142 : Animal142
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation142 : Dog142
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList142<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff142()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog142 [5] {
				if i % 2 == 1   { it = alloc Dalmation142 }
				else            { it = alloc Dog142 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList142<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff142()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 142 done\n\n")
		}
	}
	

	let names143 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal143
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names143[rand() % names143.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog143 : Animal143
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation143 : Dog143
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList143<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff143()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog143 [5] {
				if i % 2 == 1   { it = alloc Dalmation143 }
				else            { it = alloc Dog143 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList143<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff143()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 143 done\n\n")
		}
	}
	

	let names144 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal144
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names144[rand() % names144.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog144 : Animal144
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation144 : Dog144
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList144<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff144()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog144 [5] {
				if i % 2 == 1   { it = alloc Dalmation144 }
				else            { it = alloc Dog144 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList144<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff144()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 144 done\n\n")
		}
	}
	

	let names145 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal145
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names145[rand() % names145.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog145 : Animal145
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation145 : Dog145
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList145<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff145()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog145 [5] {
				if i % 2 == 1   { it = alloc Dalmation145 }
				else            { it = alloc Dog145 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList145<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff145()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 145 done\n\n")
		}
	}
	

	let names146 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal146
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names146[rand() % names146.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog146 : Animal146
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation146 : Dog146
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList146<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff146()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog146 [5] {
				if i % 2 == 1   { it = alloc Dalmation146 }
				else            { it = alloc Dog146 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList146<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff146()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 146 done\n\n")
		}
	}
	

	let names147 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal147
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names147[rand() % names147.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog147 : Animal147
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation147 : Dog147
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList147<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff147()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog147 [5] {
				if i % 2 == 1   { it = alloc Dalmation147 }
				else            { it = alloc Dog147 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList147<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff147()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 147 done\n\n")
		}
	}
	

	let names148 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal148
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names148[rand() % names148.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog148 : Animal148
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation148 : Dog148
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList148<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff148()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog148 [5] {
				if i % 2 == 1   { it = alloc Dalmation148 }
				else            { it = alloc Dog148 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList148<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff148()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 148 done\n\n")
		}
	}
	

	let names149 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal149
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names149[rand() % names149.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog149 : Animal149
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation149 : Dog149
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList149<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff149()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog149 [5] {
				if i % 2 == 1   { it = alloc Dalmation149 }
				else            { it = alloc Dog149 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList149<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff149()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 149 done\n\n")
		}
	}
	

	let names150 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal150
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names150[rand() % names150.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog150 : Animal150
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation150 : Dog150
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList150<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff150()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog150 [5] {
				if i % 2 == 1   { it = alloc Dalmation150 }
				else            { it = alloc Dog150 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList150<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff150()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 150 done\n\n")
		}
	}
	

	let names151 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal151
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names151[rand() % names151.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog151 : Animal151
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation151 : Dog151
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList151<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff151()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog151 [5] {
				if i % 2 == 1   { it = alloc Dalmation151 }
				else            { it = alloc Dog151 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList151<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff151()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 151 done\n\n")
		}
	}
	

	let names152 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal152
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names152[rand() % names152.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog152 : Animal152
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation152 : Dog152
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList152<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff152()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog152 [5] {
				if i % 2 == 1   { it = alloc Dalmation152 }
				else            { it = alloc Dog152 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList152<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff152()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 152 done\n\n")
		}
	}
	

	let names153 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal153
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names153[rand() % names153.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog153 : Animal153
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation153 : Dog153
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList153<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff153()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog153 [5] {
				if i % 2 == 1   { it = alloc Dalmation153 }
				else            { it = alloc Dog153 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList153<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff153()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 153 done\n\n")
		}
	}
	

	let names154 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal154
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names154[rand() % names154.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog154 : Animal154
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation154 : Dog154
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList154<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff154()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog154 [5] {
				if i % 2 == 1   { it = alloc Dalmation154 }
				else            { it = alloc Dog154 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList154<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff154()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 154 done\n\n")
		}
	}
	

	let names155 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal155
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names155[rand() % names155.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog155 : Animal155
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation155 : Dog155
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList155<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff155()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog155 [5] {
				if i % 2 == 1   { it = alloc Dalmation155 }
				else            { it = alloc Dog155 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList155<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff155()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 155 done\n\n")
		}
	}
	

	let names156 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal156
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names156[rand() % names156.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog156 : Animal156
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation156 : Dog156
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList156<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff156()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog156 [5] {
				if i % 2 == 1   { it = alloc Dalmation156 }
				else            { it = alloc Dog156 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList156<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff156()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 156 done\n\n")
		}
	}
	

	let names157 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal157
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names157[rand() % names157.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog157 : Animal157
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation157 : Dog157
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList157<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff157()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog157 [5] {
				if i % 2 == 1   { it = alloc Dalmation157 }
				else            { it = alloc Dog157 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList157<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff157()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 157 done\n\n")
		}
	}
	

	let names158 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal158
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names158[rand() % names158.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog158 : Animal158
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation158 : Dog158
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList158<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff158()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog158 [5] {
				if i % 2 == 1   { it = alloc Dalmation158 }
				else            { it = alloc Dog158 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList158<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff158()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 158 done\n\n")
		}
	}
	

	let names159 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal159
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names159[rand() % names159.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog159 : Animal159
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation159 : Dog159
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList159<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff159()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog159 [5] {
				if i % 2 == 1   { it = alloc Dalmation159 }
				else            { it = alloc Dog159 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList159<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff159()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 159 done\n\n")
		}
	}
	

	let names160 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal160
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names160[rand() % names160.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog160 : Animal160
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation160 : Dog160
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList160<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff160()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog160 [5] {
				if i % 2 == 1   { it = alloc Dalmation160 }
				else            { it = alloc Dog160 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList160<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff160()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 160 done\n\n")
		}
	}
	

	let names161 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal161
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names161[rand() % names161.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog161 : Animal161
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation161 : Dog161
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList161<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff161()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog161 [5] {
				if i % 2 == 1   { it = alloc Dalmation161 }
				else            { it = alloc Dog161 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList161<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff161()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 161 done\n\n")
		}
	}
	

	let names162 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal162
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names162[rand() % names162.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog162 : Animal162
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation162 : Dog162
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList162<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff162()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog162 [5] {
				if i % 2 == 1   { it = alloc Dalmation162 }
				else            { it = alloc Dog162 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList162<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff162()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 162 done\n\n")
		}
	}
	

	let names163 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal163
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names163[rand() % names163.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog163 : Animal163
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation163 : Dog163
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList163<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff163()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog163 [5] {
				if i % 2 == 1   { it = alloc Dalmation163 }
				else            { it = alloc Dog163 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList163<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff163()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 163 done\n\n")
		}
	}
	

	let names164 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal164
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names164[rand() % names164.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog164 : Animal164
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation164 : Dog164
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList164<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff164()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog164 [5] {
				if i % 2 == 1   { it = alloc Dalmation164 }
				else            { it = alloc Dog164 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList164<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff164()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 164 done\n\n")
		}
	}
	

	let names165 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal165
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names165[rand() % names165.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog165 : Animal165
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation165 : Dog165
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList165<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff165()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog165 [5] {
				if i % 2 == 1   { it = alloc Dalmation165 }
				else            { it = alloc Dog165 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList165<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff165()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 165 done\n\n")
		}
	}
	

	let names166 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal166
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names166[rand() % names166.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog166 : Animal166
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation166 : Dog166
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList166<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff166()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog166 [5] {
				if i % 2 == 1   { it = alloc Dalmation166 }
				else            { it = alloc Dog166 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList166<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff166()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 166 done\n\n")
		}
	}
	

	let names167 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal167
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names167[rand() % names167.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog167 : Animal167
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation167 : Dog167
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList167<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff167()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog167 [5] {
				if i % 2 == 1   { it = alloc Dalmation167 }
				else            { it = alloc Dog167 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList167<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff167()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 167 done\n\n")
		}
	}
	

	let names168 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal168
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names168[rand() % names168.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog168 : Animal168
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation168 : Dog168
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList168<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff168()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog168 [5] {
				if i % 2 == 1   { it = alloc Dalmation168 }
				else            { it = alloc Dog168 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList168<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff168()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 168 done\n\n")
		}
	}
	

	let names169 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal169
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names169[rand() % names169.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog169 : Animal169
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation169 : Dog169
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList169<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff169()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog169 [5] {
				if i % 2 == 1   { it = alloc Dalmation169 }
				else            { it = alloc Dog169 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList169<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff169()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 169 done\n\n")
		}
	}
	

	let names170 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal170
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names170[rand() % names170.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog170 : Animal170
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation170 : Dog170
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList170<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff170()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog170 [5] {
				if i % 2 == 1   { it = alloc Dalmation170 }
				else            { it = alloc Dog170 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList170<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff170()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 170 done\n\n")
		}
	}
	

	let names171 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal171
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names171[rand() % names171.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog171 : Animal171
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation171 : Dog171
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList171<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff171()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog171 [5] {
				if i % 2 == 1   { it = alloc Dalmation171 }
				else            { it = alloc Dog171 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList171<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff171()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 171 done\n\n")
		}
	}
	

	let names172 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal172
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names172[rand() % names172.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog172 : Animal172
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation172 : Dog172
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList172<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff172()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog172 [5] {
				if i % 2 == 1   { it = alloc Dalmation172 }
				else            { it = alloc Dog172 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList172<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff172()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 172 done\n\n")
		}
	}
	

	let names173 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal173
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names173[rand() % names173.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog173 : Animal173
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation173 : Dog173
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList173<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff173()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog173 [5] {
				if i % 2 == 1   { it = alloc Dalmation173 }
				else            { it = alloc Dog173 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList173<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff173()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 173 done\n\n")
		}
	}
	

	let names174 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal174
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names174[rand() % names174.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog174 : Animal174
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation174 : Dog174
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList174<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff174()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog174 [5] {
				if i % 2 == 1   { it = alloc Dalmation174 }
				else            { it = alloc Dog174 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList174<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff174()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 174 done\n\n")
		}
	}
	

	let names175 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal175
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names175[rand() % names175.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog175 : Animal175
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation175 : Dog175
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList175<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff175()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog175 [5] {
				if i % 2 == 1   { it = alloc Dalmation175 }
				else            { it = alloc Dog175 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList175<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff175()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 175 done\n\n")
		}
	}
	

	let names176 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal176
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names176[rand() % names176.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog176 : Animal176
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation176 : Dog176
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList176<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff176()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog176 [5] {
				if i % 2 == 1   { it = alloc Dalmation176 }
				else            { it = alloc Dog176 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList176<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff176()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 176 done\n\n")
		}
	}
	

	let names177 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal177
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names177[rand() % names177.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog177 : Animal177
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation177 : Dog177
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList177<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff177()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog177 [5] {
				if i % 2 == 1   { it = alloc Dalmation177 }
				else            { it = alloc Dog177 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList177<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff177()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 177 done\n\n")
		}
	}
	

	let names178 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal178
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names178[rand() % names178.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog178 : Animal178
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation178 : Dog178
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList178<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff178()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog178 [5] {
				if i % 2 == 1   { it = alloc Dalmation178 }
				else            { it = alloc Dog178 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList178<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff178()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 178 done\n\n")
		}
	}
	

	let names179 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal179
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names179[rand() % names179.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog179 : Animal179
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation179 : Dog179
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList179<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff179()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog179 [5] {
				if i % 2 == 1   { it = alloc Dalmation179 }
				else            { it = alloc Dog179 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList179<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff179()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 179 done\n\n")
		}
	}
	

	let names180 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal180
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names180[rand() % names180.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog180 : Animal180
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation180 : Dog180
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList180<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff180()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog180 [5] {
				if i % 2 == 1   { it = alloc Dalmation180 }
				else            { it = alloc Dog180 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList180<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff180()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 180 done\n\n")
		}
	}
	

	let names181 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal181
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names181[rand() % names181.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog181 : Animal181
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation181 : Dog181
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList181<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff181()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog181 [5] {
				if i % 2 == 1   { it = alloc Dalmation181 }
				else            { it = alloc Dog181 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList181<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff181()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 181 done\n\n")
		}
	}
	

	let names182 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal182
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names182[rand() % names182.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog182 : Animal182
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation182 : Dog182
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList182<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff182()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog182 [5] {
				if i % 2 == 1   { it = alloc Dalmation182 }
				else            { it = alloc Dog182 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList182<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff182()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 182 done\n\n")
		}
	}
	

	let names183 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal183
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names183[rand() % names183.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog183 : Animal183
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation183 : Dog183
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList183<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff183()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog183 [5] {
				if i % 2 == 1   { it = alloc Dalmation183 }
				else            { it = alloc Dog183 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList183<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff183()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 183 done\n\n")
		}
	}
	

	let names184 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal184
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names184[rand() % names184.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog184 : Animal184
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation184 : Dog184
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList184<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff184()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog184 [5] {
				if i % 2 == 1   { it = alloc Dalmation184 }
				else            { it = alloc Dog184 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList184<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff184()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 184 done\n\n")
		}
	}
	

	let names185 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal185
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names185[rand() % names185.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog185 : Animal185
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation185 : Dog185
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList185<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff185()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog185 [5] {
				if i % 2 == 1   { it = alloc Dalmation185 }
				else            { it = alloc Dog185 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList185<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff185()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 185 done\n\n")
		}
	}
	

	let names186 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal186
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names186[rand() % names186.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog186 : Animal186
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation186 : Dog186
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList186<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff186()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog186 [5] {
				if i % 2 == 1   { it = alloc Dalmation186 }
				else            { it = alloc Dog186 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList186<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff186()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 186 done\n\n")
		}
	}
	

	let names187 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal187
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names187[rand() % names187.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog187 : Animal187
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation187 : Dog187
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList187<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff187()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog187 [5] {
				if i % 2 == 1   { it = alloc Dalmation187 }
				else            { it = alloc Dog187 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList187<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff187()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 187 done\n\n")
		}
	}
	

	let names188 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal188
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names188[rand() % names188.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog188 : Animal188
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation188 : Dog188
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList188<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff188()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog188 [5] {
				if i % 2 == 1   { it = alloc Dalmation188 }
				else            { it = alloc Dog188 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList188<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff188()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 188 done\n\n")
		}
	}
	

	let names189 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal189
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names189[rand() % names189.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog189 : Animal189
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation189 : Dog189
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList189<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff189()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog189 [5] {
				if i % 2 == 1   { it = alloc Dalmation189 }
				else            { it = alloc Dog189 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList189<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff189()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 189 done\n\n")
		}
	}
	

	let names190 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal190
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names190[rand() % names190.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog190 : Animal190
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation190 : Dog190
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList190<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff190()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog190 [5] {
				if i % 2 == 1   { it = alloc Dalmation190 }
				else            { it = alloc Dog190 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList190<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff190()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 190 done\n\n")
		}
	}
	

	let names191 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal191
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names191[rand() % names191.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog191 : Animal191
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation191 : Dog191
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList191<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff191()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog191 [5] {
				if i % 2 == 1   { it = alloc Dalmation191 }
				else            { it = alloc Dog191 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList191<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff191()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 191 done\n\n")
		}
	}
	

	let names192 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal192
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names192[rand() % names192.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog192 : Animal192
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation192 : Dog192
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList192<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff192()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog192 [5] {
				if i % 2 == 1   { it = alloc Dalmation192 }
				else            { it = alloc Dog192 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList192<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff192()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 192 done\n\n")
		}
	}
	

	let names193 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal193
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names193[rand() % names193.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog193 : Animal193
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation193 : Dog193
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList193<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff193()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog193 [5] {
				if i % 2 == 1   { it = alloc Dalmation193 }
				else            { it = alloc Dog193 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList193<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff193()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 193 done\n\n")
		}
	}
	

	let names194 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal194
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names194[rand() % names194.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog194 : Animal194
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation194 : Dog194
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList194<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff194()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog194 [5] {
				if i % 2 == 1   { it = alloc Dalmation194 }
				else            { it = alloc Dog194 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList194<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff194()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 194 done\n\n")
		}
	}
	

	let names195 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal195
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names195[rand() % names195.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog195 : Animal195
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation195 : Dog195
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList195<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff195()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog195 [5] {
				if i % 2 == 1   { it = alloc Dalmation195 }
				else            { it = alloc Dog195 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList195<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff195()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 195 done\n\n")
		}
	}
	

	let names196 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal196
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names196[rand() % names196.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog196 : Animal196
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation196 : Dog196
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList196<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff196()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog196 [5] {
				if i % 2 == 1   { it = alloc Dalmation196 }
				else            { it = alloc Dog196 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList196<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff196()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 196 done\n\n")
		}
	}
	

	let names197 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal197
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names197[rand() % names197.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog197 : Animal197
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation197 : Dog197
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList197<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff197()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog197 [5] {
				if i % 2 == 1   { it = alloc Dalmation197 }
				else            { it = alloc Dog197 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList197<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff197()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 197 done\n\n")
		}
	}
	

	let names198 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal198
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names198[rand() % names198.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog198 : Animal198
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation198 : Dog198
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList198<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff198()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog198 [5] {
				if i % 2 == 1   { it = alloc Dalmation198 }
				else            { it = alloc Dog198 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList198<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff198()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 198 done\n\n")
		}
	}
	

	let names199 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal199
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names199[rand() % names199.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog199 : Animal199
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation199 : Dog199
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList199<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff199()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog199 [5] {
				if i % 2 == 1   { it = alloc Dalmation199 }
				else            { it = alloc Dog199 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList199<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff199()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 199 done\n\n")
		}
	}
	

	let names200 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal200
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names200[rand() % names200.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog200 : Animal200
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation200 : Dog200
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList200<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff200()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog200 [5] {
				if i % 2 == 1   { it = alloc Dalmation200 }
				else            { it = alloc Dog200 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList200<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff200()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 200 done\n\n")
		}
	}
	

	let names201 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal201
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names201[rand() % names201.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog201 : Animal201
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation201 : Dog201
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList201<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff201()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog201 [5] {
				if i % 2 == 1   { it = alloc Dalmation201 }
				else            { it = alloc Dog201 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList201<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff201()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 201 done\n\n")
		}
	}
	

	let names202 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal202
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names202[rand() % names202.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog202 : Animal202
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation202 : Dog202
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList202<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff202()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog202 [5] {
				if i % 2 == 1   { it = alloc Dalmation202 }
				else            { it = alloc Dog202 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList202<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff202()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 202 done\n\n")
		}
	}
	

	let names203 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal203
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names203[rand() % names203.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog203 : Animal203
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation203 : Dog203
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList203<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff203()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog203 [5] {
				if i % 2 == 1   { it = alloc Dalmation203 }
				else            { it = alloc Dog203 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList203<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff203()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 203 done\n\n")
		}
	}
	

	let names204 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal204
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names204[rand() % names204.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog204 : Animal204
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation204 : Dog204
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList204<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff204()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog204 [5] {
				if i % 2 == 1   { it = alloc Dalmation204 }
				else            { it = alloc Dog204 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList204<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff204()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 204 done\n\n")
		}
	}
	

	let names205 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal205
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names205[rand() % names205.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog205 : Animal205
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation205 : Dog205
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList205<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff205()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog205 [5] {
				if i % 2 == 1   { it = alloc Dalmation205 }
				else            { it = alloc Dog205 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList205<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff205()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 205 done\n\n")
		}
	}
	

	let names206 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal206
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names206[rand() % names206.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog206 : Animal206
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation206 : Dog206
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList206<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff206()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog206 [5] {
				if i % 2 == 1   { it = alloc Dalmation206 }
				else            { it = alloc Dog206 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList206<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff206()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 206 done\n\n")
		}
	}
	

	let names207 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal207
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names207[rand() % names207.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog207 : Animal207
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation207 : Dog207
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList207<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff207()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog207 [5] {
				if i % 2 == 1   { it = alloc Dalmation207 }
				else            { it = alloc Dog207 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList207<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff207()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 207 done\n\n")
		}
	}
	

	let names208 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal208
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names208[rand() % names208.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog208 : Animal208
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation208 : Dog208
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList208<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff208()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog208 [5] {
				if i % 2 == 1   { it = alloc Dalmation208 }
				else            { it = alloc Dog208 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList208<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff208()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 208 done\n\n")
		}
	}
	

	let names209 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal209
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names209[rand() % names209.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog209 : Animal209
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation209 : Dog209
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList209<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff209()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog209 [5] {
				if i % 2 == 1   { it = alloc Dalmation209 }
				else            { it = alloc Dog209 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList209<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff209()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 209 done\n\n")
		}
	}
	

	let names210 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal210
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names210[rand() % names210.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog210 : Animal210
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation210 : Dog210
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList210<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff210()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog210 [5] {
				if i % 2 == 1   { it = alloc Dalmation210 }
				else            { it = alloc Dog210 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList210<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff210()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 210 done\n\n")
		}
	}
	

	let names211 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal211
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names211[rand() % names211.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog211 : Animal211
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation211 : Dog211
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList211<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff211()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog211 [5] {
				if i % 2 == 1   { it = alloc Dalmation211 }
				else            { it = alloc Dog211 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList211<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff211()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 211 done\n\n")
		}
	}
	

	let names212 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal212
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names212[rand() % names212.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog212 : Animal212
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation212 : Dog212
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList212<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff212()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog212 [5] {
				if i % 2 == 1   { it = alloc Dalmation212 }
				else            { it = alloc Dog212 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList212<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff212()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 212 done\n\n")
		}
	}
	

	let names213 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal213
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names213[rand() % names213.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog213 : Animal213
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation213 : Dog213
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList213<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff213()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog213 [5] {
				if i % 2 == 1   { it = alloc Dalmation213 }
				else            { it = alloc Dog213 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList213<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff213()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 213 done\n\n")
		}
	}
	

	let names214 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal214
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names214[rand() % names214.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog214 : Animal214
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation214 : Dog214
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList214<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff214()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog214 [5] {
				if i % 2 == 1   { it = alloc Dalmation214 }
				else            { it = alloc Dog214 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList214<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff214()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 214 done\n\n")
		}
	}
	

	let names215 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal215
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names215[rand() % names215.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog215 : Animal215
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation215 : Dog215
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList215<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff215()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog215 [5] {
				if i % 2 == 1   { it = alloc Dalmation215 }
				else            { it = alloc Dog215 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList215<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff215()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 215 done\n\n")
		}
	}
	

	let names216 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal216
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names216[rand() % names216.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog216 : Animal216
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation216 : Dog216
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList216<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff216()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog216 [5] {
				if i % 2 == 1   { it = alloc Dalmation216 }
				else            { it = alloc Dog216 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList216<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff216()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 216 done\n\n")
		}
	}
	

	let names217 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal217
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names217[rand() % names217.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog217 : Animal217
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation217 : Dog217
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList217<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff217()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog217 [5] {
				if i % 2 == 1   { it = alloc Dalmation217 }
				else            { it = alloc Dog217 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList217<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff217()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 217 done\n\n")
		}
	}
	

	let names218 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal218
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names218[rand() % names218.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog218 : Animal218
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation218 : Dog218
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList218<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff218()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog218 [5] {
				if i % 2 == 1   { it = alloc Dalmation218 }
				else            { it = alloc Dog218 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList218<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff218()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 218 done\n\n")
		}
	}
	

	let names219 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal219
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names219[rand() % names219.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog219 : Animal219
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation219 : Dog219
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList219<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff219()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog219 [5] {
				if i % 2 == 1   { it = alloc Dalmation219 }
				else            { it = alloc Dog219 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList219<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff219()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 219 done\n\n")
		}
	}
	

	let names220 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal220
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names220[rand() % names220.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog220 : Animal220
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation220 : Dog220
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList220<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff220()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog220 [5] {
				if i % 2 == 1   { it = alloc Dalmation220 }
				else            { it = alloc Dog220 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList220<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff220()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 220 done\n\n")
		}
	}
	

	let names221 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal221
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names221[rand() % names221.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog221 : Animal221
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation221 : Dog221
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList221<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff221()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog221 [5] {
				if i % 2 == 1   { it = alloc Dalmation221 }
				else            { it = alloc Dog221 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList221<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff221()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 221 done\n\n")
		}
	}
	

	let names222 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal222
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names222[rand() % names222.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog222 : Animal222
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation222 : Dog222
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList222<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff222()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog222 [5] {
				if i % 2 == 1   { it = alloc Dalmation222 }
				else            { it = alloc Dog222 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList222<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff222()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 222 done\n\n")
		}
	}
	

	let names223 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal223
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names223[rand() % names223.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog223 : Animal223
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation223 : Dog223
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList223<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff223()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog223 [5] {
				if i % 2 == 1   { it = alloc Dalmation223 }
				else            { it = alloc Dog223 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList223<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff223()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 223 done\n\n")
		}
	}
	

	let names224 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal224
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names224[rand() % names224.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog224 : Animal224
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation224 : Dog224
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList224<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff224()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog224 [5] {
				if i % 2 == 1   { it = alloc Dalmation224 }
				else            { it = alloc Dog224 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList224<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff224()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 224 done\n\n")
		}
	}
	

	let names225 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal225
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names225[rand() % names225.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog225 : Animal225
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation225 : Dog225
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList225<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff225()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog225 [5] {
				if i % 2 == 1   { it = alloc Dalmation225 }
				else            { it = alloc Dog225 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList225<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff225()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 225 done\n\n")
		}
	}
	

	let names226 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal226
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names226[rand() % names226.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog226 : Animal226
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation226 : Dog226
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList226<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff226()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog226 [5] {
				if i % 2 == 1   { it = alloc Dalmation226 }
				else            { it = alloc Dog226 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList226<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff226()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 226 done\n\n")
		}
	}
	

	let names227 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal227
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names227[rand() % names227.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog227 : Animal227
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation227 : Dog227
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList227<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff227()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog227 [5] {
				if i % 2 == 1   { it = alloc Dalmation227 }
				else            { it = alloc Dog227 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList227<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff227()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 227 done\n\n")
		}
	}
	

	let names228 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal228
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names228[rand() % names228.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog228 : Animal228
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation228 : Dog228
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList228<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff228()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog228 [5] {
				if i % 2 == 1   { it = alloc Dalmation228 }
				else            { it = alloc Dog228 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList228<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff228()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 228 done\n\n")
		}
	}
	

	let names229 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal229
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names229[rand() % names229.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog229 : Animal229
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation229 : Dog229
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList229<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff229()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog229 [5] {
				if i % 2 == 1   { it = alloc Dalmation229 }
				else            { it = alloc Dog229 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList229<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff229()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 229 done\n\n")
		}
	}
	

	let names230 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal230
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names230[rand() % names230.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog230 : Animal230
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation230 : Dog230
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList230<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff230()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog230 [5] {
				if i % 2 == 1   { it = alloc Dalmation230 }
				else            { it = alloc Dog230 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList230<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff230()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 230 done\n\n")
		}
	}
	

	let names231 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal231
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names231[rand() % names231.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog231 : Animal231
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation231 : Dog231
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList231<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff231()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog231 [5] {
				if i % 2 == 1   { it = alloc Dalmation231 }
				else            { it = alloc Dog231 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList231<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff231()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 231 done\n\n")
		}
	}
	

	let names232 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal232
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names232[rand() % names232.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog232 : Animal232
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation232 : Dog232
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList232<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff232()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog232 [5] {
				if i % 2 == 1   { it = alloc Dalmation232 }
				else            { it = alloc Dog232 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList232<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff232()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 232 done\n\n")
		}
	}
	

	let names233 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal233
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names233[rand() % names233.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog233 : Animal233
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation233 : Dog233
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList233<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff233()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog233 [5] {
				if i % 2 == 1   { it = alloc Dalmation233 }
				else            { it = alloc Dog233 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList233<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff233()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 233 done\n\n")
		}
	}
	

	let names234 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal234
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names234[rand() % names234.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog234 : Animal234
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation234 : Dog234
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList234<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff234()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog234 [5] {
				if i % 2 == 1   { it = alloc Dalmation234 }
				else            { it = alloc Dog234 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList234<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff234()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 234 done\n\n")
		}
	}
	

	let names235 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal235
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names235[rand() % names235.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog235 : Animal235
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation235 : Dog235
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList235<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff235()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog235 [5] {
				if i % 2 == 1   { it = alloc Dalmation235 }
				else            { it = alloc Dog235 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList235<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff235()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 235 done\n\n")
		}
	}
	

	let names236 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal236
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names236[rand() % names236.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog236 : Animal236
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation236 : Dog236
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList236<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff236()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog236 [5] {
				if i % 2 == 1   { it = alloc Dalmation236 }
				else            { it = alloc Dog236 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList236<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff236()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 236 done\n\n")
		}
	}
	

	let names237 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal237
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names237[rand() % names237.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog237 : Animal237
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation237 : Dog237
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList237<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff237()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog237 [5] {
				if i % 2 == 1   { it = alloc Dalmation237 }
				else            { it = alloc Dog237 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList237<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff237()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 237 done\n\n")
		}
	}
	

	let names238 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal238
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names238[rand() % names238.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog238 : Animal238
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation238 : Dog238
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList238<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff238()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog238 [5] {
				if i % 2 == 1   { it = alloc Dalmation238 }
				else            { it = alloc Dog238 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList238<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff238()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 238 done\n\n")
		}
	}
	

	let names239 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal239
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names239[rand() % names239.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog239 : Animal239
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation239 : Dog239
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList239<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff239()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog239 [5] {
				if i % 2 == 1   { it = alloc Dalmation239 }
				else            { it = alloc Dog239 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList239<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff239()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 239 done\n\n")
		}
	}
	

	let names240 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal240
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names240[rand() % names240.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog240 : Animal240
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation240 : Dog240
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList240<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff240()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog240 [5] {
				if i % 2 == 1   { it = alloc Dalmation240 }
				else            { it = alloc Dog240 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList240<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff240()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 240 done\n\n")
		}
	}
	

	let names241 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal241
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names241[rand() % names241.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog241 : Animal241
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation241 : Dog241
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList241<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff241()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog241 [5] {
				if i % 2 == 1   { it = alloc Dalmation241 }
				else            { it = alloc Dog241 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList241<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff241()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 241 done\n\n")
		}
	}
	

	let names242 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal242
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names242[rand() % names242.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog242 : Animal242
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation242 : Dog242
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList242<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff242()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog242 [5] {
				if i % 2 == 1   { it = alloc Dalmation242 }
				else            { it = alloc Dog242 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList242<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff242()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 242 done\n\n")
		}
	}
	

	let names243 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal243
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names243[rand() % names243.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog243 : Animal243
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation243 : Dog243
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList243<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff243()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog243 [5] {
				if i % 2 == 1   { it = alloc Dalmation243 }
				else            { it = alloc Dog243 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList243<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff243()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 243 done\n\n")
		}
	}
	

	let names244 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal244
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names244[rand() % names244.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog244 : Animal244
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation244 : Dog244
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList244<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff244()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog244 [5] {
				if i % 2 == 1   { it = alloc Dalmation244 }
				else            { it = alloc Dog244 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList244<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff244()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 244 done\n\n")
		}
	}
	

	let names245 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal245
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names245[rand() % names245.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog245 : Animal245
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation245 : Dog245
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList245<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff245()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog245 [5] {
				if i % 2 == 1   { it = alloc Dalmation245 }
				else            { it = alloc Dog245 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList245<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff245()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 245 done\n\n")
		}
	}
	

	let names246 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal246
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names246[rand() % names246.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog246 : Animal246
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation246 : Dog246
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList246<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff246()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog246 [5] {
				if i % 2 == 1   { it = alloc Dalmation246 }
				else            { it = alloc Dog246 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList246<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff246()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 246 done\n\n")
		}
	}
	

	let names247 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal247
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names247[rand() % names247.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog247 : Animal247
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation247 : Dog247
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList247<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff247()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog247 [5] {
				if i % 2 == 1   { it = alloc Dalmation247 }
				else            { it = alloc Dog247 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList247<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff247()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 247 done\n\n")
		}
	}
	

	let names248 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal248
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names248[rand() % names248.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog248 : Animal248
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation248 : Dog248
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList248<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff248()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog248 [5] {
				if i % 2 == 1   { it = alloc Dalmation248 }
				else            { it = alloc Dog248 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList248<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff248()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 248 done\n\n")
		}
	}
	

	let names249 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal249
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names249[rand() % names249.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog249 : Animal249
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation249 : Dog249
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList249<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff249()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog249 [5] {
				if i % 2 == 1   { it = alloc Dalmation249 }
				else            { it = alloc Dog249 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList249<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff249()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 249 done\n\n")
		}
	}
	

	let names250 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal250
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names250[rand() % names250.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog250 : Animal250
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation250 : Dog250
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList250<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff250()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog250 [5] {
				if i % 2 == 1   { it = alloc Dalmation250 }
				else            { it = alloc Dog250 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList250<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff250()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 250 done\n\n")
		}
	}
	

	let names251 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal251
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names251[rand() % names251.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog251 : Animal251
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation251 : Dog251
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList251<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff251()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog251 [5] {
				if i % 2 == 1   { it = alloc Dalmation251 }
				else            { it = alloc Dog251 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList251<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff251()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 251 done\n\n")
		}
	}
	

	let names252 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal252
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names252[rand() % names252.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog252 : Animal252
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation252 : Dog252
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList252<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff252()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog252 [5] {
				if i % 2 == 1   { it = alloc Dalmation252 }
				else            { it = alloc Dog252 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList252<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff252()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 252 done\n\n")
		}
	}
	

	let names253 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal253
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names253[rand() % names253.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog253 : Animal253
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation253 : Dog253
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList253<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff253()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog253 [5] {
				if i % 2 == 1   { it = alloc Dalmation253 }
				else            { it = alloc Dog253 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList253<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff253()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 253 done\n\n")
		}
	}
	

	let names254 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal254
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names254[rand() % names254.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog254 : Animal254
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation254 : Dog254
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList254<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff254()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog254 [5] {
				if i % 2 == 1   { it = alloc Dalmation254 }
				else            { it = alloc Dog254 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList254<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff254()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 254 done\n\n")
		}
	}
	

	let names255 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal255
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names255[rand() % names255.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog255 : Animal255
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation255 : Dog255
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList255<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff255()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog255 [5] {
				if i % 2 == 1   { it = alloc Dalmation255 }
				else            { it = alloc Dog255 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList255<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff255()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 255 done\n\n")
		}
	}
	

	let names256 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal256
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names256[rand() % names256.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog256 : Animal256
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation256 : Dog256
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList256<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff256()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog256 [5] {
				if i % 2 == 1   { it = alloc Dalmation256 }
				else            { it = alloc Dog256 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList256<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff256()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 256 done\n\n")
		}
	}
	

	let names257 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal257
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names257[rand() % names257.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog257 : Animal257
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation257 : Dog257
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList257<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff257()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog257 [5] {
				if i % 2 == 1   { it = alloc Dalmation257 }
				else            { it = alloc Dog257 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList257<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff257()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 257 done\n\n")
		}
	}
	

	let names258 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal258
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names258[rand() % names258.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog258 : Animal258
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation258 : Dog258
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList258<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff258()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog258 [5] {
				if i % 2 == 1   { it = alloc Dalmation258 }
				else            { it = alloc Dog258 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList258<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff258()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 258 done\n\n")
		}
	}
	

	let names259 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal259
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names259[rand() % names259.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog259 : Animal259
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation259 : Dog259
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList259<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff259()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog259 [5] {
				if i % 2 == 1   { it = alloc Dalmation259 }
				else            { it = alloc Dog259 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList259<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff259()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 259 done\n\n")
		}
	}
	

	let names260 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal260
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names260[rand() % names260.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog260 : Animal260
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation260 : Dog260
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList260<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff260()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog260 [5] {
				if i % 2 == 1   { it = alloc Dalmation260 }
				else            { it = alloc Dog260 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList260<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff260()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 260 done\n\n")
		}
	}
	

	let names261 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal261
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names261[rand() % names261.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog261 : Animal261
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation261 : Dog261
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList261<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff261()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog261 [5] {
				if i % 2 == 1   { it = alloc Dalmation261 }
				else            { it = alloc Dog261 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList261<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff261()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 261 done\n\n")
		}
	}
	

	let names262 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal262
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names262[rand() % names262.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog262 : Animal262
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation262 : Dog262
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList262<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff262()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog262 [5] {
				if i % 2 == 1   { it = alloc Dalmation262 }
				else            { it = alloc Dog262 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList262<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff262()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 262 done\n\n")
		}
	}
	

	let names263 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal263
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names263[rand() % names263.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog263 : Animal263
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation263 : Dog263
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList263<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff263()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog263 [5] {
				if i % 2 == 1   { it = alloc Dalmation263 }
				else            { it = alloc Dog263 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList263<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff263()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 263 done\n\n")
		}
	}
	

	let names264 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal264
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names264[rand() % names264.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog264 : Animal264
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation264 : Dog264
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList264<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff264()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog264 [5] {
				if i % 2 == 1   { it = alloc Dalmation264 }
				else            { it = alloc Dog264 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList264<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff264()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 264 done\n\n")
		}
	}
	

	let names265 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal265
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names265[rand() % names265.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog265 : Animal265
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation265 : Dog265
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList265<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff265()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog265 [5] {
				if i % 2 == 1   { it = alloc Dalmation265 }
				else            { it = alloc Dog265 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList265<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff265()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 265 done\n\n")
		}
	}
	

	let names266 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal266
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names266[rand() % names266.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog266 : Animal266
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation266 : Dog266
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList266<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff266()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog266 [5] {
				if i % 2 == 1   { it = alloc Dalmation266 }
				else            { it = alloc Dog266 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList266<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff266()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 266 done\n\n")
		}
	}
	

	let names267 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal267
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names267[rand() % names267.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog267 : Animal267
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation267 : Dog267
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList267<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff267()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog267 [5] {
				if i % 2 == 1   { it = alloc Dalmation267 }
				else            { it = alloc Dog267 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList267<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff267()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 267 done\n\n")
		}
	}
	

	let names268 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal268
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names268[rand() % names268.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog268 : Animal268
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation268 : Dog268
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList268<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff268()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog268 [5] {
				if i % 2 == 1   { it = alloc Dalmation268 }
				else            { it = alloc Dog268 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList268<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff268()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 268 done\n\n")
		}
	}
	

	let names269 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal269
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names269[rand() % names269.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog269 : Animal269
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation269 : Dog269
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList269<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff269()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog269 [5] {
				if i % 2 == 1   { it = alloc Dalmation269 }
				else            { it = alloc Dog269 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList269<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff269()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 269 done\n\n")
		}
	}
	

	let names270 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal270
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names270[rand() % names270.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog270 : Animal270
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation270 : Dog270
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList270<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff270()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog270 [5] {
				if i % 2 == 1   { it = alloc Dalmation270 }
				else            { it = alloc Dog270 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList270<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff270()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 270 done\n\n")
		}
	}
	

	let names271 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal271
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names271[rand() % names271.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog271 : Animal271
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation271 : Dog271
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList271<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff271()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog271 [5] {
				if i % 2 == 1   { it = alloc Dalmation271 }
				else            { it = alloc Dog271 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList271<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff271()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 271 done\n\n")
		}
	}
	

	let names272 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal272
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names272[rand() % names272.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog272 : Animal272
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation272 : Dog272
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList272<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff272()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog272 [5] {
				if i % 2 == 1   { it = alloc Dalmation272 }
				else            { it = alloc Dog272 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList272<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff272()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 272 done\n\n")
		}
	}
	

	let names273 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal273
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names273[rand() % names273.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog273 : Animal273
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation273 : Dog273
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList273<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff273()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog273 [5] {
				if i % 2 == 1   { it = alloc Dalmation273 }
				else            { it = alloc Dog273 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList273<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff273()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 273 done\n\n")
		}
	}
	

	let names274 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal274
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names274[rand() % names274.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog274 : Animal274
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation274 : Dog274
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList274<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff274()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog274 [5] {
				if i % 2 == 1   { it = alloc Dalmation274 }
				else            { it = alloc Dog274 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList274<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff274()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 274 done\n\n")
		}
	}
	

	let names275 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal275
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names275[rand() % names275.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog275 : Animal275
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation275 : Dog275
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList275<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff275()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog275 [5] {
				if i % 2 == 1   { it = alloc Dalmation275 }
				else            { it = alloc Dog275 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList275<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff275()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 275 done\n\n")
		}
	}
	

	let names276 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal276
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names276[rand() % names276.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog276 : Animal276
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation276 : Dog276
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList276<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff276()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog276 [5] {
				if i % 2 == 1   { it = alloc Dalmation276 }
				else            { it = alloc Dog276 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList276<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff276()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 276 done\n\n")
		}
	}
	

	let names277 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal277
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names277[rand() % names277.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog277 : Animal277
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation277 : Dog277
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList277<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff277()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog277 [5] {
				if i % 2 == 1   { it = alloc Dalmation277 }
				else            { it = alloc Dog277 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList277<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff277()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 277 done\n\n")
		}
	}
	

	let names278 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal278
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names278[rand() % names278.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog278 : Animal278
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation278 : Dog278
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList278<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff278()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog278 [5] {
				if i % 2 == 1   { it = alloc Dalmation278 }
				else            { it = alloc Dog278 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList278<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff278()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 278 done\n\n")
		}
	}
	

	let names279 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal279
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names279[rand() % names279.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog279 : Animal279
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation279 : Dog279
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList279<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff279()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog279 [5] {
				if i % 2 == 1   { it = alloc Dalmation279 }
				else            { it = alloc Dog279 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList279<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff279()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 279 done\n\n")
		}
	}
	

	let names280 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal280
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names280[rand() % names280.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog280 : Animal280
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation280 : Dog280
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList280<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff280()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog280 [5] {
				if i % 2 == 1   { it = alloc Dalmation280 }
				else            { it = alloc Dog280 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList280<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff280()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 280 done\n\n")
		}
	}
	

	let names281 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal281
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names281[rand() % names281.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog281 : Animal281
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation281 : Dog281
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList281<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff281()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog281 [5] {
				if i % 2 == 1   { it = alloc Dalmation281 }
				else            { it = alloc Dog281 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList281<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff281()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 281 done\n\n")
		}
	}
	

	let names282 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal282
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names282[rand() % names282.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog282 : Animal282
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation282 : Dog282
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList282<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff282()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog282 [5] {
				if i % 2 == 1   { it = alloc Dalmation282 }
				else            { it = alloc Dog282 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList282<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff282()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 282 done\n\n")
		}
	}
	

	let names283 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal283
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names283[rand() % names283.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog283 : Animal283
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation283 : Dog283
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList283<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff283()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog283 [5] {
				if i % 2 == 1   { it = alloc Dalmation283 }
				else            { it = alloc Dog283 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList283<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff283()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 283 done\n\n")
		}
	}
	

	let names284 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal284
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names284[rand() % names284.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog284 : Animal284
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation284 : Dog284
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList284<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff284()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog284 [5] {
				if i % 2 == 1   { it = alloc Dalmation284 }
				else            { it = alloc Dog284 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList284<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff284()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 284 done\n\n")
		}
	}
	

	let names285 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal285
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names285[rand() % names285.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog285 : Animal285
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation285 : Dog285
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList285<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff285()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog285 [5] {
				if i % 2 == 1   { it = alloc Dalmation285 }
				else            { it = alloc Dog285 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList285<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff285()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 285 done\n\n")
		}
	}
	

	let names286 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal286
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names286[rand() % names286.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog286 : Animal286
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation286 : Dog286
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList286<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff286()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog286 [5] {
				if i % 2 == 1   { it = alloc Dalmation286 }
				else            { it = alloc Dog286 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList286<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff286()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 286 done\n\n")
		}
	}
	

	let names287 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal287
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names287[rand() % names287.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog287 : Animal287
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation287 : Dog287
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList287<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff287()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog287 [5] {
				if i % 2 == 1   { it = alloc Dalmation287 }
				else            { it = alloc Dog287 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList287<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff287()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 287 done\n\n")
		}
	}
	

	let names288 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal288
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names288[rand() % names288.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog288 : Animal288
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation288 : Dog288
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList288<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff288()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog288 [5] {
				if i % 2 == 1   { it = alloc Dalmation288 }
				else            { it = alloc Dog288 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList288<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff288()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 288 done\n\n")
		}
	}
	

	let names289 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal289
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names289[rand() % names289.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog289 : Animal289
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation289 : Dog289
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList289<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff289()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog289 [5] {
				if i % 2 == 1   { it = alloc Dalmation289 }
				else            { it = alloc Dog289 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList289<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff289()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 289 done\n\n")
		}
	}
	

	let names290 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal290
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names290[rand() % names290.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog290 : Animal290
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation290 : Dog290
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList290<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff290()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog290 [5] {
				if i % 2 == 1   { it = alloc Dalmation290 }
				else            { it = alloc Dog290 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList290<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff290()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 290 done\n\n")
		}
	}
	

	let names291 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal291
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names291[rand() % names291.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog291 : Animal291
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation291 : Dog291
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList291<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff291()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog291 [5] {
				if i % 2 == 1   { it = alloc Dalmation291 }
				else            { it = alloc Dog291 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList291<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff291()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 291 done\n\n")
		}
	}
	

	let names292 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal292
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names292[rand() % names292.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog292 : Animal292
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation292 : Dog292
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList292<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff292()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog292 [5] {
				if i % 2 == 1   { it = alloc Dalmation292 }
				else            { it = alloc Dog292 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList292<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff292()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 292 done\n\n")
		}
	}
	

	let names293 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal293
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names293[rand() % names293.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog293 : Animal293
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation293 : Dog293
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList293<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff293()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog293 [5] {
				if i % 2 == 1   { it = alloc Dalmation293 }
				else            { it = alloc Dog293 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList293<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff293()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 293 done\n\n")
		}
	}
	

	let names294 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal294
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names294[rand() % names294.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog294 : Animal294
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation294 : Dog294
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList294<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff294()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog294 [5] {
				if i % 2 == 1   { it = alloc Dalmation294 }
				else            { it = alloc Dog294 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList294<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff294()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 294 done\n\n")
		}
	}
	

	let names295 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal295
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names295[rand() % names295.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog295 : Animal295
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation295 : Dog295
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList295<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff295()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog295 [5] {
				if i % 2 == 1   { it = alloc Dalmation295 }
				else            { it = alloc Dog295 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList295<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff295()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 295 done\n\n")
		}
	}
	

	let names296 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal296
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names296[rand() % names296.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog296 : Animal296
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation296 : Dog296
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList296<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff296()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog296 [5] {
				if i % 2 == 1   { it = alloc Dalmation296 }
				else            { it = alloc Dog296 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList296<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff296()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 296 done\n\n")
		}
	}
	

	let names297 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal297
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names297[rand() % names297.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog297 : Animal297
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation297 : Dog297
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList297<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff297()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog297 [5] {
				if i % 2 == 1   { it = alloc Dalmation297 }
				else            { it = alloc Dog297 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList297<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff297()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 297 done\n\n")
		}
	}
	

	let names298 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal298
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names298[rand() % names298.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog298 : Animal298
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation298 : Dog298
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList298<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff298()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog298 [5] {
				if i % 2 == 1   { it = alloc Dalmation298 }
				else            { it = alloc Dog298 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList298<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff298()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 298 done\n\n")
		}
	}
	

	let names299 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal299
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names299[rand() % names299.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog299 : Animal299
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation299 : Dog299
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList299<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff299()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog299 [5] {
				if i % 2 == 1   { it = alloc Dalmation299 }
				else            { it = alloc Dog299 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList299<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff299()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 299 done\n\n")
		}
	}
	

	let names300 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal300
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names300[rand() % names300.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog300 : Animal300
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation300 : Dog300
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList300<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff300()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog300 [5] {
				if i % 2 == 1   { it = alloc Dalmation300 }
				else            { it = alloc Dog300 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList300<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff300()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 300 done\n\n")
		}
	}
	

	let names301 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal301
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names301[rand() % names301.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog301 : Animal301
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation301 : Dog301
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList301<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff301()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog301 [5] {
				if i % 2 == 1   { it = alloc Dalmation301 }
				else            { it = alloc Dog301 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList301<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff301()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 301 done\n\n")
		}
	}
	

	let names302 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal302
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names302[rand() % names302.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog302 : Animal302
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation302 : Dog302
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList302<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff302()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog302 [5] {
				if i % 2 == 1   { it = alloc Dalmation302 }
				else            { it = alloc Dog302 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList302<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff302()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 302 done\n\n")
		}
	}
	

	let names303 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal303
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names303[rand() % names303.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog303 : Animal303
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation303 : Dog303
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList303<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff303()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog303 [5] {
				if i % 2 == 1   { it = alloc Dalmation303 }
				else            { it = alloc Dog303 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList303<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff303()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 303 done\n\n")
		}
	}
	

	let names304 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal304
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names304[rand() % names304.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog304 : Animal304
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation304 : Dog304
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList304<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff304()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog304 [5] {
				if i % 2 == 1   { it = alloc Dalmation304 }
				else            { it = alloc Dog304 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList304<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff304()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 304 done\n\n")
		}
	}
	

	let names305 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal305
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names305[rand() % names305.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog305 : Animal305
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation305 : Dog305
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList305<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff305()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog305 [5] {
				if i % 2 == 1   { it = alloc Dalmation305 }
				else            { it = alloc Dog305 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList305<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff305()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 305 done\n\n")
		}
	}
	

	let names306 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal306
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names306[rand() % names306.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog306 : Animal306
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation306 : Dog306
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList306<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff306()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog306 [5] {
				if i % 2 == 1   { it = alloc Dalmation306 }
				else            { it = alloc Dog306 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList306<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff306()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 306 done\n\n")
		}
	}
	

	let names307 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal307
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names307[rand() % names307.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog307 : Animal307
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation307 : Dog307
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList307<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff307()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog307 [5] {
				if i % 2 == 1   { it = alloc Dalmation307 }
				else            { it = alloc Dog307 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList307<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff307()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 307 done\n\n")
		}
	}
	

	let names308 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal308
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names308[rand() % names308.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog308 : Animal308
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation308 : Dog308
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList308<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff308()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog308 [5] {
				if i % 2 == 1   { it = alloc Dalmation308 }
				else            { it = alloc Dog308 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList308<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff308()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 308 done\n\n")
		}
	}
	

	let names309 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal309
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names309[rand() % names309.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog309 : Animal309
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation309 : Dog309
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList309<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff309()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog309 [5] {
				if i % 2 == 1   { it = alloc Dalmation309 }
				else            { it = alloc Dog309 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList309<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff309()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 309 done\n\n")
		}
	}
	

	let names310 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal310
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names310[rand() % names310.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog310 : Animal310
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation310 : Dog310
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList310<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff310()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog310 [5] {
				if i % 2 == 1   { it = alloc Dalmation310 }
				else            { it = alloc Dog310 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList310<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff310()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 310 done\n\n")
		}
	}
	

	let names311 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal311
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names311[rand() % names311.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog311 : Animal311
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation311 : Dog311
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList311<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff311()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog311 [5] {
				if i % 2 == 1   { it = alloc Dalmation311 }
				else            { it = alloc Dog311 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList311<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff311()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 311 done\n\n")
		}
	}
	

	let names312 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal312
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names312[rand() % names312.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog312 : Animal312
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation312 : Dog312
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList312<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff312()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog312 [5] {
				if i % 2 == 1   { it = alloc Dalmation312 }
				else            { it = alloc Dog312 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList312<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff312()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 312 done\n\n")
		}
	}
	

	let names313 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal313
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names313[rand() % names313.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog313 : Animal313
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation313 : Dog313
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList313<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff313()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog313 [5] {
				if i % 2 == 1   { it = alloc Dalmation313 }
				else            { it = alloc Dog313 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList313<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff313()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 313 done\n\n")
		}
	}
	

	let names314 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal314
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names314[rand() % names314.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog314 : Animal314
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation314 : Dog314
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList314<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff314()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog314 [5] {
				if i % 2 == 1   { it = alloc Dalmation314 }
				else            { it = alloc Dog314 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList314<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff314()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 314 done\n\n")
		}
	}
	

	let names315 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal315
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names315[rand() % names315.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog315 : Animal315
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation315 : Dog315
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList315<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff315()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog315 [5] {
				if i % 2 == 1   { it = alloc Dalmation315 }
				else            { it = alloc Dog315 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList315<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff315()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 315 done\n\n")
		}
	}
	

	let names316 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal316
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names316[rand() % names316.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog316 : Animal316
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation316 : Dog316
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList316<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff316()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog316 [5] {
				if i % 2 == 1   { it = alloc Dalmation316 }
				else            { it = alloc Dog316 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList316<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff316()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 316 done\n\n")
		}
	}
	

	let names317 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal317
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names317[rand() % names317.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog317 : Animal317
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation317 : Dog317
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList317<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff317()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog317 [5] {
				if i % 2 == 1   { it = alloc Dalmation317 }
				else            { it = alloc Dog317 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList317<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff317()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 317 done\n\n")
		}
	}
	

	let names318 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal318
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names318[rand() % names318.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog318 : Animal318
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation318 : Dog318
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList318<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff318()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog318 [5] {
				if i % 2 == 1   { it = alloc Dalmation318 }
				else            { it = alloc Dog318 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList318<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff318()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 318 done\n\n")
		}
	}
	

	let names319 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal319
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names319[rand() % names319.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog319 : Animal319
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation319 : Dog319
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList319<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff319()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog319 [5] {
				if i % 2 == 1   { it = alloc Dalmation319 }
				else            { it = alloc Dog319 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList319<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff319()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 319 done\n\n")
		}
	}
	

	let names320 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal320
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names320[rand() % names320.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog320 : Animal320
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation320 : Dog320
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList320<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff320()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog320 [5] {
				if i % 2 == 1   { it = alloc Dalmation320 }
				else            { it = alloc Dog320 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList320<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff320()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 320 done\n\n")
		}
	}
	

	let names321 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal321
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names321[rand() % names321.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog321 : Animal321
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation321 : Dog321
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList321<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff321()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog321 [5] {
				if i % 2 == 1   { it = alloc Dalmation321 }
				else            { it = alloc Dog321 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList321<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff321()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 321 done\n\n")
		}
	}
	

	let names322 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal322
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names322[rand() % names322.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog322 : Animal322
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation322 : Dog322
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList322<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff322()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog322 [5] {
				if i % 2 == 1   { it = alloc Dalmation322 }
				else            { it = alloc Dog322 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList322<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff322()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 322 done\n\n")
		}
	}
	

	let names323 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal323
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names323[rand() % names323.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog323 : Animal323
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation323 : Dog323
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList323<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff323()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog323 [5] {
				if i % 2 == 1   { it = alloc Dalmation323 }
				else            { it = alloc Dog323 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList323<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff323()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 323 done\n\n")
		}
	}
	

	let names324 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal324
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names324[rand() % names324.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog324 : Animal324
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation324 : Dog324
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList324<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff324()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog324 [5] {
				if i % 2 == 1   { it = alloc Dalmation324 }
				else            { it = alloc Dog324 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList324<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff324()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 324 done\n\n")
		}
	}
	

	let names325 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal325
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names325[rand() % names325.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog325 : Animal325
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation325 : Dog325
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList325<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff325()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog325 [5] {
				if i % 2 == 1   { it = alloc Dalmation325 }
				else            { it = alloc Dog325 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList325<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff325()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 325 done\n\n")
		}
	}
	

	let names326 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal326
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names326[rand() % names326.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog326 : Animal326
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation326 : Dog326
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList326<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff326()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog326 [5] {
				if i % 2 == 1   { it = alloc Dalmation326 }
				else            { it = alloc Dog326 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList326<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff326()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 326 done\n\n")
		}
	}
	

	let names327 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal327
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names327[rand() % names327.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog327 : Animal327
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation327 : Dog327
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList327<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff327()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog327 [5] {
				if i % 2 == 1   { it = alloc Dalmation327 }
				else            { it = alloc Dog327 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList327<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff327()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 327 done\n\n")
		}
	}
	

	let names328 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal328
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names328[rand() % names328.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog328 : Animal328
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation328 : Dog328
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList328<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff328()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog328 [5] {
				if i % 2 == 1   { it = alloc Dalmation328 }
				else            { it = alloc Dog328 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList328<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff328()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 328 done\n\n")
		}
	}
	

	let names329 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal329
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names329[rand() % names329.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog329 : Animal329
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation329 : Dog329
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList329<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff329()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog329 [5] {
				if i % 2 == 1   { it = alloc Dalmation329 }
				else            { it = alloc Dog329 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList329<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff329()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 329 done\n\n")
		}
	}
	

	let names330 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal330
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names330[rand() % names330.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog330 : Animal330
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation330 : Dog330
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList330<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff330()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog330 [5] {
				if i % 2 == 1   { it = alloc Dalmation330 }
				else            { it = alloc Dog330 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList330<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff330()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 330 done\n\n")
		}
	}
	

	let names331 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal331
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names331[rand() % names331.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog331 : Animal331
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation331 : Dog331
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList331<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff331()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog331 [5] {
				if i % 2 == 1   { it = alloc Dalmation331 }
				else            { it = alloc Dog331 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList331<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff331()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 331 done\n\n")
		}
	}
	

	let names332 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal332
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names332[rand() % names332.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog332 : Animal332
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation332 : Dog332
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList332<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff332()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog332 [5] {
				if i % 2 == 1   { it = alloc Dalmation332 }
				else            { it = alloc Dog332 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList332<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff332()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 332 done\n\n")
		}
	}
	

	let names333 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal333
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names333[rand() % names333.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog333 : Animal333
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation333 : Dog333
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList333<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff333()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog333 [5] {
				if i % 2 == 1   { it = alloc Dalmation333 }
				else            { it = alloc Dog333 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList333<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff333()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 333 done\n\n")
		}
	}
	

	let names334 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal334
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names334[rand() % names334.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog334 : Animal334
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation334 : Dog334
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList334<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff334()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog334 [5] {
				if i % 2 == 1   { it = alloc Dalmation334 }
				else            { it = alloc Dog334 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList334<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff334()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 334 done\n\n")
		}
	}
	

	let names335 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal335
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names335[rand() % names335.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog335 : Animal335
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation335 : Dog335
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList335<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff335()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog335 [5] {
				if i % 2 == 1   { it = alloc Dalmation335 }
				else            { it = alloc Dog335 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList335<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff335()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 335 done\n\n")
		}
	}
	

	let names336 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal336
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names336[rand() % names336.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog336 : Animal336
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation336 : Dog336
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList336<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff336()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog336 [5] {
				if i % 2 == 1   { it = alloc Dalmation336 }
				else            { it = alloc Dog336 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList336<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff336()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 336 done\n\n")
		}
	}
	

	let names337 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal337
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names337[rand() % names337.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog337 : Animal337
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation337 : Dog337
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList337<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff337()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog337 [5] {
				if i % 2 == 1   { it = alloc Dalmation337 }
				else            { it = alloc Dog337 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList337<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff337()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 337 done\n\n")
		}
	}
	

	let names338 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal338
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names338[rand() % names338.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog338 : Animal338
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation338 : Dog338
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList338<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff338()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog338 [5] {
				if i % 2 == 1   { it = alloc Dalmation338 }
				else            { it = alloc Dog338 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList338<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff338()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 338 done\n\n")
		}
	}
	

	let names339 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal339
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names339[rand() % names339.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog339 : Animal339
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation339 : Dog339
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList339<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff339()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog339 [5] {
				if i % 2 == 1   { it = alloc Dalmation339 }
				else            { it = alloc Dog339 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList339<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff339()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 339 done\n\n")
		}
	}
	

	let names340 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal340
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names340[rand() % names340.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog340 : Animal340
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation340 : Dog340
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList340<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff340()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog340 [5] {
				if i % 2 == 1   { it = alloc Dalmation340 }
				else            { it = alloc Dog340 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList340<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff340()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 340 done\n\n")
		}
	}
	

	let names341 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal341
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names341[rand() % names341.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog341 : Animal341
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation341 : Dog341
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList341<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff341()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog341 [5] {
				if i % 2 == 1   { it = alloc Dalmation341 }
				else            { it = alloc Dog341 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList341<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff341()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 341 done\n\n")
		}
	}
	

	let names342 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal342
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names342[rand() % names342.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog342 : Animal342
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation342 : Dog342
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList342<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff342()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog342 [5] {
				if i % 2 == 1   { it = alloc Dalmation342 }
				else            { it = alloc Dog342 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList342<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff342()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 342 done\n\n")
		}
	}
	

	let names343 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal343
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names343[rand() % names343.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog343 : Animal343
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation343 : Dog343
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList343<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff343()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog343 [5] {
				if i % 2 == 1   { it = alloc Dalmation343 }
				else            { it = alloc Dog343 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList343<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff343()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 343 done\n\n")
		}
	}
	

	let names344 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal344
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names344[rand() % names344.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog344 : Animal344
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation344 : Dog344
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList344<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff344()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog344 [5] {
				if i % 2 == 1   { it = alloc Dalmation344 }
				else            { it = alloc Dog344 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList344<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff344()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 344 done\n\n")
		}
	}
	

	let names345 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal345
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names345[rand() % names345.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog345 : Animal345
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation345 : Dog345
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList345<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff345()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog345 [5] {
				if i % 2 == 1   { it = alloc Dalmation345 }
				else            { it = alloc Dog345 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList345<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff345()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 345 done\n\n")
		}
	}
	

	let names346 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal346
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names346[rand() % names346.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog346 : Animal346
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation346 : Dog346
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList346<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff346()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog346 [5] {
				if i % 2 == 1   { it = alloc Dalmation346 }
				else            { it = alloc Dog346 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList346<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff346()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 346 done\n\n")
		}
	}
	

	let names347 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal347
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names347[rand() % names347.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog347 : Animal347
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation347 : Dog347
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList347<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff347()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog347 [5] {
				if i % 2 == 1   { it = alloc Dalmation347 }
				else            { it = alloc Dog347 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList347<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff347()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 347 done\n\n")
		}
	}
	

	let names348 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal348
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names348[rand() % names348.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog348 : Animal348
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation348 : Dog348
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList348<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff348()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog348 [5] {
				if i % 2 == 1   { it = alloc Dalmation348 }
				else            { it = alloc Dog348 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList348<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff348()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 348 done\n\n")
		}
	}
	

	let names349 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal349
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names349[rand() % names349.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog349 : Animal349
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation349 : Dog349
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList349<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff349()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog349 [5] {
				if i % 2 == 1   { it = alloc Dalmation349 }
				else            { it = alloc Dog349 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList349<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff349()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 349 done\n\n")
		}
	}
	

	let names350 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal350
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names350[rand() % names350.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog350 : Animal350
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation350 : Dog350
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList350<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff350()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog350 [5] {
				if i % 2 == 1   { it = alloc Dalmation350 }
				else            { it = alloc Dog350 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList350<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff350()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 350 done\n\n")
		}
	}
	

	let names351 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal351
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names351[rand() % names351.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog351 : Animal351
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation351 : Dog351
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList351<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff351()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog351 [5] {
				if i % 2 == 1   { it = alloc Dalmation351 }
				else            { it = alloc Dog351 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList351<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff351()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 351 done\n\n")
		}
	}
	

	let names352 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal352
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names352[rand() % names352.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog352 : Animal352
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation352 : Dog352
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList352<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff352()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog352 [5] {
				if i % 2 == 1   { it = alloc Dalmation352 }
				else            { it = alloc Dog352 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList352<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff352()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 352 done\n\n")
		}
	}
	

	let names353 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal353
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names353[rand() % names353.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog353 : Animal353
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation353 : Dog353
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList353<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff353()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog353 [5] {
				if i % 2 == 1   { it = alloc Dalmation353 }
				else            { it = alloc Dog353 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList353<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff353()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 353 done\n\n")
		}
	}
	

	let names354 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal354
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names354[rand() % names354.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog354 : Animal354
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation354 : Dog354
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList354<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff354()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog354 [5] {
				if i % 2 == 1   { it = alloc Dalmation354 }
				else            { it = alloc Dog354 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList354<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff354()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 354 done\n\n")
		}
	}
	

	let names355 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal355
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names355[rand() % names355.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog355 : Animal355
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation355 : Dog355
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList355<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff355()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog355 [5] {
				if i % 2 == 1   { it = alloc Dalmation355 }
				else            { it = alloc Dog355 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList355<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff355()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 355 done\n\n")
		}
	}
	

	let names356 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal356
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names356[rand() % names356.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog356 : Animal356
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation356 : Dog356
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList356<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff356()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog356 [5] {
				if i % 2 == 1   { it = alloc Dalmation356 }
				else            { it = alloc Dog356 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList356<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff356()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 356 done\n\n")
		}
	}
	

	let names357 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal357
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names357[rand() % names357.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog357 : Animal357
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation357 : Dog357
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList357<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff357()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog357 [5] {
				if i % 2 == 1   { it = alloc Dalmation357 }
				else            { it = alloc Dog357 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList357<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff357()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 357 done\n\n")
		}
	}
	

	let names358 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal358
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names358[rand() % names358.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog358 : Animal358
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation358 : Dog358
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList358<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff358()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog358 [5] {
				if i % 2 == 1   { it = alloc Dalmation358 }
				else            { it = alloc Dog358 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList358<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff358()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 358 done\n\n")
		}
	}
	

	let names359 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal359
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names359[rand() % names359.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog359 : Animal359
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation359 : Dog359
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList359<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff359()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog359 [5] {
				if i % 2 == 1   { it = alloc Dalmation359 }
				else            { it = alloc Dog359 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList359<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff359()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 359 done\n\n")
		}
	}
	

	let names360 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal360
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names360[rand() % names360.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog360 : Animal360
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation360 : Dog360
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList360<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff360()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog360 [5] {
				if i % 2 == 1   { it = alloc Dalmation360 }
				else            { it = alloc Dog360 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList360<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff360()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 360 done\n\n")
		}
	}
	

	let names361 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal361
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names361[rand() % names361.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog361 : Animal361
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation361 : Dog361
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList361<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff361()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog361 [5] {
				if i % 2 == 1   { it = alloc Dalmation361 }
				else            { it = alloc Dog361 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList361<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff361()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 361 done\n\n")
		}
	}
	

	let names362 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal362
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names362[rand() % names362.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog362 : Animal362
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation362 : Dog362
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList362<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff362()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog362 [5] {
				if i % 2 == 1   { it = alloc Dalmation362 }
				else            { it = alloc Dog362 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList362<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff362()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 362 done\n\n")
		}
	}
	

	let names363 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal363
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names363[rand() % names363.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog363 : Animal363
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation363 : Dog363
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList363<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff363()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog363 [5] {
				if i % 2 == 1   { it = alloc Dalmation363 }
				else            { it = alloc Dog363 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList363<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff363()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 363 done\n\n")
		}
	}
	

	let names364 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal364
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names364[rand() % names364.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog364 : Animal364
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation364 : Dog364
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList364<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff364()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog364 [5] {
				if i % 2 == 1   { it = alloc Dalmation364 }
				else            { it = alloc Dog364 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList364<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff364()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 364 done\n\n")
		}
	}
	

	let names365 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal365
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names365[rand() % names365.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog365 : Animal365
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation365 : Dog365
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList365<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff365()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog365 [5] {
				if i % 2 == 1   { it = alloc Dalmation365 }
				else            { it = alloc Dog365 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList365<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff365()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 365 done\n\n")
		}
	}
	

	let names366 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal366
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names366[rand() % names366.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog366 : Animal366
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation366 : Dog366
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList366<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff366()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog366 [5] {
				if i % 2 == 1   { it = alloc Dalmation366 }
				else            { it = alloc Dog366 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList366<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff366()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 366 done\n\n")
		}
	}
	

	let names367 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal367
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names367[rand() % names367.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog367 : Animal367
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation367 : Dog367
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList367<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff367()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog367 [5] {
				if i % 2 == 1   { it = alloc Dalmation367 }
				else            { it = alloc Dog367 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList367<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff367()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 367 done\n\n")
		}
	}
	

	let names368 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal368
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names368[rand() % names368.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog368 : Animal368
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation368 : Dog368
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList368<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff368()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog368 [5] {
				if i % 2 == 1   { it = alloc Dalmation368 }
				else            { it = alloc Dog368 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList368<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff368()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 368 done\n\n")
		}
	}
	

	let names369 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal369
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names369[rand() % names369.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog369 : Animal369
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation369 : Dog369
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList369<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff369()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog369 [5] {
				if i % 2 == 1   { it = alloc Dalmation369 }
				else            { it = alloc Dog369 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList369<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff369()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 369 done\n\n")
		}
	}
	

	let names370 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal370
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names370[rand() % names370.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog370 : Animal370
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation370 : Dog370
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList370<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff370()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog370 [5] {
				if i % 2 == 1   { it = alloc Dalmation370 }
				else            { it = alloc Dog370 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList370<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff370()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 370 done\n\n")
		}
	}
	

	let names371 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal371
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names371[rand() % names371.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog371 : Animal371
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation371 : Dog371
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList371<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff371()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog371 [5] {
				if i % 2 == 1   { it = alloc Dalmation371 }
				else            { it = alloc Dog371 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList371<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff371()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 371 done\n\n")
		}
	}
	

	let names372 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal372
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names372[rand() % names372.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog372 : Animal372
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation372 : Dog372
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList372<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff372()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog372 [5] {
				if i % 2 == 1   { it = alloc Dalmation372 }
				else            { it = alloc Dog372 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList372<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff372()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 372 done\n\n")
		}
	}
	

	let names373 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal373
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names373[rand() % names373.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog373 : Animal373
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation373 : Dog373
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList373<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff373()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog373 [5] {
				if i % 2 == 1   { it = alloc Dalmation373 }
				else            { it = alloc Dog373 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList373<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff373()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 373 done\n\n")
		}
	}
	

	let names374 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal374
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names374[rand() % names374.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog374 : Animal374
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation374 : Dog374
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList374<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff374()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog374 [5] {
				if i % 2 == 1   { it = alloc Dalmation374 }
				else            { it = alloc Dog374 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList374<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff374()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 374 done\n\n")
		}
	}
	

	let names375 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal375
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names375[rand() % names375.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog375 : Animal375
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation375 : Dog375
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList375<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff375()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog375 [5] {
				if i % 2 == 1   { it = alloc Dalmation375 }
				else            { it = alloc Dog375 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList375<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff375()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 375 done\n\n")
		}
	}
	

	let names376 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal376
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names376[rand() % names376.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog376 : Animal376
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation376 : Dog376
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList376<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff376()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog376 [5] {
				if i % 2 == 1   { it = alloc Dalmation376 }
				else            { it = alloc Dog376 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList376<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff376()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 376 done\n\n")
		}
	}
	

	let names377 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal377
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names377[rand() % names377.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog377 : Animal377
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation377 : Dog377
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList377<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff377()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog377 [5] {
				if i % 2 == 1   { it = alloc Dalmation377 }
				else            { it = alloc Dog377 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList377<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff377()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 377 done\n\n")
		}
	}
	

	let names378 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal378
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names378[rand() % names378.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog378 : Animal378
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation378 : Dog378
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList378<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff378()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog378 [5] {
				if i % 2 == 1   { it = alloc Dalmation378 }
				else            { it = alloc Dog378 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList378<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff378()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 378 done\n\n")
		}
	}
	

	let names379 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal379
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names379[rand() % names379.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog379 : Animal379
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation379 : Dog379
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList379<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff379()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog379 [5] {
				if i % 2 == 1   { it = alloc Dalmation379 }
				else            { it = alloc Dog379 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList379<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff379()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 379 done\n\n")
		}
	}
	

	let names380 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal380
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names380[rand() % names380.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog380 : Animal380
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation380 : Dog380
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList380<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff380()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog380 [5] {
				if i % 2 == 1   { it = alloc Dalmation380 }
				else            { it = alloc Dog380 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList380<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff380()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 380 done\n\n")
		}
	}
	

	let names381 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal381
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names381[rand() % names381.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog381 : Animal381
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation381 : Dog381
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList381<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff381()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog381 [5] {
				if i % 2 == 1   { it = alloc Dalmation381 }
				else            { it = alloc Dog381 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList381<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff381()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 381 done\n\n")
		}
	}
	

	let names382 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal382
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names382[rand() % names382.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog382 : Animal382
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation382 : Dog382
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList382<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff382()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog382 [5] {
				if i % 2 == 1   { it = alloc Dalmation382 }
				else            { it = alloc Dog382 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList382<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff382()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 382 done\n\n")
		}
	}
	

	let names383 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal383
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names383[rand() % names383.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog383 : Animal383
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation383 : Dog383
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList383<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff383()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog383 [5] {
				if i % 2 == 1   { it = alloc Dalmation383 }
				else            { it = alloc Dog383 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList383<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff383()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 383 done\n\n")
		}
	}
	

	let names384 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal384
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names384[rand() % names384.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog384 : Animal384
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation384 : Dog384
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList384<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff384()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog384 [5] {
				if i % 2 == 1   { it = alloc Dalmation384 }
				else            { it = alloc Dog384 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList384<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff384()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 384 done\n\n")
		}
	}
	

	let names385 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal385
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names385[rand() % names385.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog385 : Animal385
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation385 : Dog385
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList385<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff385()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog385 [5] {
				if i % 2 == 1   { it = alloc Dalmation385 }
				else            { it = alloc Dog385 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList385<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff385()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 385 done\n\n")
		}
	}
	

	let names386 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal386
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names386[rand() % names386.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog386 : Animal386
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation386 : Dog386
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList386<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff386()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog386 [5] {
				if i % 2 == 1   { it = alloc Dalmation386 }
				else            { it = alloc Dog386 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList386<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff386()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 386 done\n\n")
		}
	}
	

	let names387 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal387
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names387[rand() % names387.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog387 : Animal387
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation387 : Dog387
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList387<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff387()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog387 [5] {
				if i % 2 == 1   { it = alloc Dalmation387 }
				else            { it = alloc Dog387 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList387<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff387()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 387 done\n\n")
		}
	}
	

	let names388 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal388
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names388[rand() % names388.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog388 : Animal388
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation388 : Dog388
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList388<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff388()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog388 [5] {
				if i % 2 == 1   { it = alloc Dalmation388 }
				else            { it = alloc Dog388 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList388<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff388()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 388 done\n\n")
		}
	}
	

	let names389 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal389
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names389[rand() % names389.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog389 : Animal389
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation389 : Dog389
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList389<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff389()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog389 [5] {
				if i % 2 == 1   { it = alloc Dalmation389 }
				else            { it = alloc Dog389 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList389<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff389()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 389 done\n\n")
		}
	}
	

	let names390 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal390
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names390[rand() % names390.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog390 : Animal390
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation390 : Dog390
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList390<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff390()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog390 [5] {
				if i % 2 == 1   { it = alloc Dalmation390 }
				else            { it = alloc Dog390 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList390<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff390()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 390 done\n\n")
		}
	}
	

	let names391 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal391
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names391[rand() % names391.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog391 : Animal391
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation391 : Dog391
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList391<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff391()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog391 [5] {
				if i % 2 == 1   { it = alloc Dalmation391 }
				else            { it = alloc Dog391 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList391<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff391()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 391 done\n\n")
		}
	}
	

	let names392 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal392
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names392[rand() % names392.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog392 : Animal392
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation392 : Dog392
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList392<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff392()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog392 [5] {
				if i % 2 == 1   { it = alloc Dalmation392 }
				else            { it = alloc Dog392 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList392<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff392()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 392 done\n\n")
		}
	}
	

	let names393 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal393
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names393[rand() % names393.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog393 : Animal393
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation393 : Dog393
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList393<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff393()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog393 [5] {
				if i % 2 == 1   { it = alloc Dalmation393 }
				else            { it = alloc Dog393 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList393<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff393()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 393 done\n\n")
		}
	}
	

	let names394 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal394
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names394[rand() % names394.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog394 : Animal394
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation394 : Dog394
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList394<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff394()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog394 [5] {
				if i % 2 == 1   { it = alloc Dalmation394 }
				else            { it = alloc Dog394 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList394<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff394()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 394 done\n\n")
		}
	}
	

	let names395 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal395
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names395[rand() % names395.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog395 : Animal395
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation395 : Dog395
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList395<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff395()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog395 [5] {
				if i % 2 == 1   { it = alloc Dalmation395 }
				else            { it = alloc Dog395 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList395<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff395()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 395 done\n\n")
		}
	}
	

	let names396 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal396
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names396[rand() % names396.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog396 : Animal396
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation396 : Dog396
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList396<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff396()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog396 [5] {
				if i % 2 == 1   { it = alloc Dalmation396 }
				else            { it = alloc Dog396 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList396<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff396()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 396 done\n\n")
		}
	}
	

	let names397 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal397
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names397[rand() % names397.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog397 : Animal397
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation397 : Dog397
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList397<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff397()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog397 [5] {
				if i % 2 == 1   { it = alloc Dalmation397 }
				else            { it = alloc Dog397 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList397<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff397()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 397 done\n\n")
		}
	}
	

	let names398 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal398
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names398[rand() % names398.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog398 : Animal398
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation398 : Dog398
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList398<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff398()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog398 [5] {
				if i % 2 == 1   { it = alloc Dalmation398 }
				else            { it = alloc Dog398 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList398<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff398()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 398 done\n\n")
		}
	}
	

	let names399 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal399
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names399[rand() % names399.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog399 : Animal399
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation399 : Dog399
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList399<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff399()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog399 [5] {
				if i % 2 == 1   { it = alloc Dalmation399 }
				else            { it = alloc Dog399 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList399<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff399()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 399 done\n\n")
		}
	}
	

	let names400 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal400
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names400[rand() % names400.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog400 : Animal400
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation400 : Dog400
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList400<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff400()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog400 [5] {
				if i % 2 == 1   { it = alloc Dalmation400 }
				else            { it = alloc Dog400 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList400<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff400()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 400 done\n\n")
		}
	}
	

	let names401 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal401
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names401[rand() % names401.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog401 : Animal401
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation401 : Dog401
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList401<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff401()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog401 [5] {
				if i % 2 == 1   { it = alloc Dalmation401 }
				else            { it = alloc Dog401 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList401<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff401()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 401 done\n\n")
		}
	}
	

	let names402 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal402
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names402[rand() % names402.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog402 : Animal402
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation402 : Dog402
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList402<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff402()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog402 [5] {
				if i % 2 == 1   { it = alloc Dalmation402 }
				else            { it = alloc Dog402 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList402<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff402()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 402 done\n\n")
		}
	}
	

	let names403 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal403
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names403[rand() % names403.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog403 : Animal403
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation403 : Dog403
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList403<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff403()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog403 [5] {
				if i % 2 == 1   { it = alloc Dalmation403 }
				else            { it = alloc Dog403 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList403<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff403()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 403 done\n\n")
		}
	}
	

	let names404 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal404
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names404[rand() % names404.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog404 : Animal404
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation404 : Dog404
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList404<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff404()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog404 [5] {
				if i % 2 == 1   { it = alloc Dalmation404 }
				else            { it = alloc Dog404 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList404<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff404()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 404 done\n\n")
		}
	}
	

	let names405 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal405
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names405[rand() % names405.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog405 : Animal405
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation405 : Dog405
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList405<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff405()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog405 [5] {
				if i % 2 == 1   { it = alloc Dalmation405 }
				else            { it = alloc Dog405 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList405<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff405()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 405 done\n\n")
		}
	}
	

	let names406 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal406
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names406[rand() % names406.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog406 : Animal406
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation406 : Dog406
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList406<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff406()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog406 [5] {
				if i % 2 == 1   { it = alloc Dalmation406 }
				else            { it = alloc Dog406 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList406<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff406()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 406 done\n\n")
		}
	}
	

	let names407 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal407
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names407[rand() % names407.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog407 : Animal407
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation407 : Dog407
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList407<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff407()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog407 [5] {
				if i % 2 == 1   { it = alloc Dalmation407 }
				else            { it = alloc Dog407 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList407<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff407()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 407 done\n\n")
		}
	}
	

	let names408 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal408
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names408[rand() % names408.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog408 : Animal408
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation408 : Dog408
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList408<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff408()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog408 [5] {
				if i % 2 == 1   { it = alloc Dalmation408 }
				else            { it = alloc Dog408 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList408<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff408()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 408 done\n\n")
		}
	}
	

	let names409 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal409
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names409[rand() % names409.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog409 : Animal409
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation409 : Dog409
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList409<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff409()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog409 [5] {
				if i % 2 == 1   { it = alloc Dalmation409 }
				else            { it = alloc Dog409 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList409<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff409()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 409 done\n\n")
		}
	}
	

	let names410 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal410
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names410[rand() % names410.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog410 : Animal410
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation410 : Dog410
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList410<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff410()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog410 [5] {
				if i % 2 == 1   { it = alloc Dalmation410 }
				else            { it = alloc Dog410 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList410<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff410()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 410 done\n\n")
		}
	}
	

	let names411 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal411
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names411[rand() % names411.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog411 : Animal411
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation411 : Dog411
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList411<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff411()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog411 [5] {
				if i % 2 == 1   { it = alloc Dalmation411 }
				else            { it = alloc Dog411 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList411<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff411()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 411 done\n\n")
		}
	}
	

	let names412 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal412
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names412[rand() % names412.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog412 : Animal412
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation412 : Dog412
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList412<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff412()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog412 [5] {
				if i % 2 == 1   { it = alloc Dalmation412 }
				else            { it = alloc Dog412 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList412<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff412()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 412 done\n\n")
		}
	}
	

	let names413 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal413
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names413[rand() % names413.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog413 : Animal413
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation413 : Dog413
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList413<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff413()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog413 [5] {
				if i % 2 == 1   { it = alloc Dalmation413 }
				else            { it = alloc Dog413 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList413<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff413()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 413 done\n\n")
		}
	}
	

	let names414 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal414
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names414[rand() % names414.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog414 : Animal414
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation414 : Dog414
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList414<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff414()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog414 [5] {
				if i % 2 == 1   { it = alloc Dalmation414 }
				else            { it = alloc Dog414 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList414<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff414()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 414 done\n\n")
		}
	}
	

	let names415 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal415
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names415[rand() % names415.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog415 : Animal415
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation415 : Dog415
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList415<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff415()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog415 [5] {
				if i % 2 == 1   { it = alloc Dalmation415 }
				else            { it = alloc Dog415 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList415<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff415()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 415 done\n\n")
		}
	}
	

	let names416 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal416
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names416[rand() % names416.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog416 : Animal416
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation416 : Dog416
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList416<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff416()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog416 [5] {
				if i % 2 == 1   { it = alloc Dalmation416 }
				else            { it = alloc Dog416 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList416<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff416()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 416 done\n\n")
		}
	}
	

	let names417 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal417
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names417[rand() % names417.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog417 : Animal417
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation417 : Dog417
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList417<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff417()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog417 [5] {
				if i % 2 == 1   { it = alloc Dalmation417 }
				else            { it = alloc Dog417 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList417<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff417()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 417 done\n\n")
		}
	}
	

	let names418 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal418
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names418[rand() % names418.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog418 : Animal418
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation418 : Dog418
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList418<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff418()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog418 [5] {
				if i % 2 == 1   { it = alloc Dalmation418 }
				else            { it = alloc Dog418 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList418<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff418()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 418 done\n\n")
		}
	}
	

	let names419 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal419
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names419[rand() % names419.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog419 : Animal419
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation419 : Dog419
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList419<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff419()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog419 [5] {
				if i % 2 == 1   { it = alloc Dalmation419 }
				else            { it = alloc Dog419 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList419<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff419()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 419 done\n\n")
		}
	}
	

	let names420 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal420
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names420[rand() % names420.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog420 : Animal420
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation420 : Dog420
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList420<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff420()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog420 [5] {
				if i % 2 == 1   { it = alloc Dalmation420 }
				else            { it = alloc Dog420 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList420<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff420()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 420 done\n\n")
		}
	}
	

	let names421 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal421
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names421[rand() % names421.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog421 : Animal421
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation421 : Dog421
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList421<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff421()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog421 [5] {
				if i % 2 == 1   { it = alloc Dalmation421 }
				else            { it = alloc Dog421 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList421<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff421()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 421 done\n\n")
		}
	}
	

	let names422 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal422
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names422[rand() % names422.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog422 : Animal422
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation422 : Dog422
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList422<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff422()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog422 [5] {
				if i % 2 == 1   { it = alloc Dalmation422 }
				else            { it = alloc Dog422 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList422<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff422()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 422 done\n\n")
		}
	}
	

	let names423 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal423
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names423[rand() % names423.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog423 : Animal423
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation423 : Dog423
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList423<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff423()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog423 [5] {
				if i % 2 == 1   { it = alloc Dalmation423 }
				else            { it = alloc Dog423 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList423<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff423()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 423 done\n\n")
		}
	}
	

	let names424 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal424
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names424[rand() % names424.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog424 : Animal424
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation424 : Dog424
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList424<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff424()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog424 [5] {
				if i % 2 == 1   { it = alloc Dalmation424 }
				else            { it = alloc Dog424 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList424<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff424()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 424 done\n\n")
		}
	}
	

	let names425 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal425
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names425[rand() % names425.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog425 : Animal425
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation425 : Dog425
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList425<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff425()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog425 [5] {
				if i % 2 == 1   { it = alloc Dalmation425 }
				else            { it = alloc Dog425 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList425<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff425()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 425 done\n\n")
		}
	}
	

	let names426 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal426
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names426[rand() % names426.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog426 : Animal426
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation426 : Dog426
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList426<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff426()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog426 [5] {
				if i % 2 == 1   { it = alloc Dalmation426 }
				else            { it = alloc Dog426 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList426<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff426()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 426 done\n\n")
		}
	}
	

	let names427 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal427
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names427[rand() % names427.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog427 : Animal427
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation427 : Dog427
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList427<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff427()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog427 [5] {
				if i % 2 == 1   { it = alloc Dalmation427 }
				else            { it = alloc Dog427 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList427<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff427()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 427 done\n\n")
		}
	}
	

	let names428 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal428
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names428[rand() % names428.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog428 : Animal428
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation428 : Dog428
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList428<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff428()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog428 [5] {
				if i % 2 == 1   { it = alloc Dalmation428 }
				else            { it = alloc Dog428 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList428<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff428()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 428 done\n\n")
		}
	}
	

	let names429 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal429
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names429[rand() % names429.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog429 : Animal429
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation429 : Dog429
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList429<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff429()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog429 [5] {
				if i % 2 == 1   { it = alloc Dalmation429 }
				else            { it = alloc Dog429 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList429<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff429()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 429 done\n\n")
		}
	}
	

	let names430 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal430
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names430[rand() % names430.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog430 : Animal430
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation430 : Dog430
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList430<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff430()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog430 [5] {
				if i % 2 == 1   { it = alloc Dalmation430 }
				else            { it = alloc Dog430 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList430<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff430()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 430 done\n\n")
		}
	}
	

	let names431 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal431
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names431[rand() % names431.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog431 : Animal431
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation431 : Dog431
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList431<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff431()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog431 [5] {
				if i % 2 == 1   { it = alloc Dalmation431 }
				else            { it = alloc Dog431 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList431<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff431()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 431 done\n\n")
		}
	}
	

	let names432 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal432
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names432[rand() % names432.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog432 : Animal432
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation432 : Dog432
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList432<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff432()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog432 [5] {
				if i % 2 == 1   { it = alloc Dalmation432 }
				else            { it = alloc Dog432 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList432<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff432()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 432 done\n\n")
		}
	}
	

	let names433 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal433
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names433[rand() % names433.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog433 : Animal433
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation433 : Dog433
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList433<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff433()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog433 [5] {
				if i % 2 == 1   { it = alloc Dalmation433 }
				else            { it = alloc Dog433 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList433<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff433()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 433 done\n\n")
		}
	}
	

	let names434 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal434
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names434[rand() % names434.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog434 : Animal434
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation434 : Dog434
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList434<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff434()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog434 [5] {
				if i % 2 == 1   { it = alloc Dalmation434 }
				else            { it = alloc Dog434 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList434<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff434()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 434 done\n\n")
		}
	}
	

	let names435 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal435
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names435[rand() % names435.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog435 : Animal435
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation435 : Dog435
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList435<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff435()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog435 [5] {
				if i % 2 == 1   { it = alloc Dalmation435 }
				else            { it = alloc Dog435 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList435<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff435()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 435 done\n\n")
		}
	}
	

	let names436 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal436
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names436[rand() % names436.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog436 : Animal436
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation436 : Dog436
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList436<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff436()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog436 [5] {
				if i % 2 == 1   { it = alloc Dalmation436 }
				else            { it = alloc Dog436 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList436<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff436()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 436 done\n\n")
		}
	}
	

	let names437 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal437
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names437[rand() % names437.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog437 : Animal437
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation437 : Dog437
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList437<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff437()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog437 [5] {
				if i % 2 == 1   { it = alloc Dalmation437 }
				else            { it = alloc Dog437 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList437<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff437()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 437 done\n\n")
		}
	}
	

	let names438 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal438
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names438[rand() % names438.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog438 : Animal438
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation438 : Dog438
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList438<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff438()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog438 [5] {
				if i % 2 == 1   { it = alloc Dalmation438 }
				else            { it = alloc Dog438 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList438<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff438()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 438 done\n\n")
		}
	}
	

	let names439 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal439
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names439[rand() % names439.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog439 : Animal439
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation439 : Dog439
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList439<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff439()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog439 [5] {
				if i % 2 == 1   { it = alloc Dalmation439 }
				else            { it = alloc Dog439 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList439<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff439()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 439 done\n\n")
		}
	}
	

	let names440 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal440
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names440[rand() % names440.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog440 : Animal440
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation440 : Dog440
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList440<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff440()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog440 [5] {
				if i % 2 == 1   { it = alloc Dalmation440 }
				else            { it = alloc Dog440 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList440<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff440()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 440 done\n\n")
		}
	}
	

	let names441 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal441
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names441[rand() % names441.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog441 : Animal441
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation441 : Dog441
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList441<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff441()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog441 [5] {
				if i % 2 == 1   { it = alloc Dalmation441 }
				else            { it = alloc Dog441 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList441<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff441()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 441 done\n\n")
		}
	}
	

	let names442 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal442
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names442[rand() % names442.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog442 : Animal442
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation442 : Dog442
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList442<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff442()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog442 [5] {
				if i % 2 == 1   { it = alloc Dalmation442 }
				else            { it = alloc Dog442 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList442<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff442()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 442 done\n\n")
		}
	}
	

	let names443 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal443
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names443[rand() % names443.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog443 : Animal443
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation443 : Dog443
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList443<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff443()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog443 [5] {
				if i % 2 == 1   { it = alloc Dalmation443 }
				else            { it = alloc Dog443 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList443<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff443()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 443 done\n\n")
		}
	}
	

	let names444 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal444
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names444[rand() % names444.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog444 : Animal444
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation444 : Dog444
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList444<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff444()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog444 [5] {
				if i % 2 == 1   { it = alloc Dalmation444 }
				else            { it = alloc Dog444 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList444<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff444()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 444 done\n\n")
		}
	}
	

	let names445 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal445
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names445[rand() % names445.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog445 : Animal445
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation445 : Dog445
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList445<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff445()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog445 [5] {
				if i % 2 == 1   { it = alloc Dalmation445 }
				else            { it = alloc Dog445 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList445<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff445()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 445 done\n\n")
		}
	}
	

	let names446 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal446
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names446[rand() % names446.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog446 : Animal446
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation446 : Dog446
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList446<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff446()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog446 [5] {
				if i % 2 == 1   { it = alloc Dalmation446 }
				else            { it = alloc Dog446 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList446<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff446()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 446 done\n\n")
		}
	}
	

	let names447 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal447
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names447[rand() % names447.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog447 : Animal447
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation447 : Dog447
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList447<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff447()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog447 [5] {
				if i % 2 == 1   { it = alloc Dalmation447 }
				else            { it = alloc Dog447 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList447<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff447()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 447 done\n\n")
		}
	}
	

	let names448 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal448
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names448[rand() % names448.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog448 : Animal448
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation448 : Dog448
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList448<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff448()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog448 [5] {
				if i % 2 == 1   { it = alloc Dalmation448 }
				else            { it = alloc Dog448 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList448<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff448()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 448 done\n\n")
		}
	}
	

	let names449 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal449
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names449[rand() % names449.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog449 : Animal449
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation449 : Dog449
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList449<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff449()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog449 [5] {
				if i % 2 == 1   { it = alloc Dalmation449 }
				else            { it = alloc Dog449 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList449<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff449()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 449 done\n\n")
		}
	}
	

	let names450 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal450
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names450[rand() % names450.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog450 : Animal450
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation450 : Dog450
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList450<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff450()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog450 [5] {
				if i % 2 == 1   { it = alloc Dalmation450 }
				else            { it = alloc Dog450 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList450<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff450()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 450 done\n\n")
		}
	}
	

	let names451 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal451
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names451[rand() % names451.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog451 : Animal451
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation451 : Dog451
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList451<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff451()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog451 [5] {
				if i % 2 == 1   { it = alloc Dalmation451 }
				else            { it = alloc Dog451 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList451<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff451()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 451 done\n\n")
		}
	}
	

	let names452 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal452
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names452[rand() % names452.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog452 : Animal452
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation452 : Dog452
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList452<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff452()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog452 [5] {
				if i % 2 == 1   { it = alloc Dalmation452 }
				else            { it = alloc Dog452 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList452<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff452()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 452 done\n\n")
		}
	}
	

	let names453 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal453
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names453[rand() % names453.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog453 : Animal453
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation453 : Dog453
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList453<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff453()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog453 [5] {
				if i % 2 == 1   { it = alloc Dalmation453 }
				else            { it = alloc Dog453 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList453<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff453()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 453 done\n\n")
		}
	}
	

	let names454 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal454
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names454[rand() % names454.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog454 : Animal454
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation454 : Dog454
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList454<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff454()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog454 [5] {
				if i % 2 == 1   { it = alloc Dalmation454 }
				else            { it = alloc Dog454 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList454<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff454()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 454 done\n\n")
		}
	}
	

	let names455 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal455
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names455[rand() % names455.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog455 : Animal455
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation455 : Dog455
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList455<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff455()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog455 [5] {
				if i % 2 == 1   { it = alloc Dalmation455 }
				else            { it = alloc Dog455 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList455<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff455()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 455 done\n\n")
		}
	}
	

	let names456 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal456
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names456[rand() % names456.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog456 : Animal456
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation456 : Dog456
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList456<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff456()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog456 [5] {
				if i % 2 == 1   { it = alloc Dalmation456 }
				else            { it = alloc Dog456 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList456<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff456()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 456 done\n\n")
		}
	}
	

	let names457 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal457
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names457[rand() % names457.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog457 : Animal457
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation457 : Dog457
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList457<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff457()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog457 [5] {
				if i % 2 == 1   { it = alloc Dalmation457 }
				else            { it = alloc Dog457 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList457<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff457()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 457 done\n\n")
		}
	}
	

	let names458 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal458
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names458[rand() % names458.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog458 : Animal458
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation458 : Dog458
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList458<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff458()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog458 [5] {
				if i % 2 == 1   { it = alloc Dalmation458 }
				else            { it = alloc Dog458 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList458<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff458()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 458 done\n\n")
		}
	}
	

	let names459 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal459
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names459[rand() % names459.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog459 : Animal459
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation459 : Dog459
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList459<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff459()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog459 [5] {
				if i % 2 == 1   { it = alloc Dalmation459 }
				else            { it = alloc Dog459 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList459<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff459()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 459 done\n\n")
		}
	}
	

	let names460 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal460
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names460[rand() % names460.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog460 : Animal460
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation460 : Dog460
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList460<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff460()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog460 [5] {
				if i % 2 == 1   { it = alloc Dalmation460 }
				else            { it = alloc Dog460 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList460<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff460()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 460 done\n\n")
		}
	}
	

	let names461 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal461
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names461[rand() % names461.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog461 : Animal461
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation461 : Dog461
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList461<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff461()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog461 [5] {
				if i % 2 == 1   { it = alloc Dalmation461 }
				else            { it = alloc Dog461 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList461<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff461()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 461 done\n\n")
		}
	}
	

	let names462 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal462
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names462[rand() % names462.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog462 : Animal462
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation462 : Dog462
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList462<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff462()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog462 [5] {
				if i % 2 == 1   { it = alloc Dalmation462 }
				else            { it = alloc Dog462 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList462<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff462()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 462 done\n\n")
		}
	}
	

	let names463 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal463
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names463[rand() % names463.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog463 : Animal463
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation463 : Dog463
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList463<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff463()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog463 [5] {
				if i % 2 == 1   { it = alloc Dalmation463 }
				else            { it = alloc Dog463 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList463<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff463()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 463 done\n\n")
		}
	}
	

	let names464 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal464
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names464[rand() % names464.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog464 : Animal464
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation464 : Dog464
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList464<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff464()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog464 [5] {
				if i % 2 == 1   { it = alloc Dalmation464 }
				else            { it = alloc Dog464 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList464<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff464()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 464 done\n\n")
		}
	}
	

	let names465 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal465
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names465[rand() % names465.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog465 : Animal465
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation465 : Dog465
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList465<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff465()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog465 [5] {
				if i % 2 == 1   { it = alloc Dalmation465 }
				else            { it = alloc Dog465 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList465<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff465()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 465 done\n\n")
		}
	}
	

	let names466 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal466
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names466[rand() % names466.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog466 : Animal466
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation466 : Dog466
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList466<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff466()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog466 [5] {
				if i % 2 == 1   { it = alloc Dalmation466 }
				else            { it = alloc Dog466 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList466<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff466()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 466 done\n\n")
		}
	}
	

	let names467 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal467
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names467[rand() % names467.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog467 : Animal467
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation467 : Dog467
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList467<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff467()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog467 [5] {
				if i % 2 == 1   { it = alloc Dalmation467 }
				else            { it = alloc Dog467 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList467<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff467()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 467 done\n\n")
		}
	}
	

	let names468 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal468
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names468[rand() % names468.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog468 : Animal468
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation468 : Dog468
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList468<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff468()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog468 [5] {
				if i % 2 == 1   { it = alloc Dalmation468 }
				else            { it = alloc Dog468 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList468<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff468()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 468 done\n\n")
		}
	}
	

	let names469 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal469
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names469[rand() % names469.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog469 : Animal469
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation469 : Dog469
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList469<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff469()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog469 [5] {
				if i % 2 == 1   { it = alloc Dalmation469 }
				else            { it = alloc Dog469 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList469<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff469()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 469 done\n\n")
		}
	}
	

	let names470 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal470
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names470[rand() % names470.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog470 : Animal470
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation470 : Dog470
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList470<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff470()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog470 [5] {
				if i % 2 == 1   { it = alloc Dalmation470 }
				else            { it = alloc Dog470 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList470<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff470()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 470 done\n\n")
		}
	}
	

	let names471 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal471
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names471[rand() % names471.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog471 : Animal471
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation471 : Dog471
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList471<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff471()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog471 [5] {
				if i % 2 == 1   { it = alloc Dalmation471 }
				else            { it = alloc Dog471 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList471<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff471()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 471 done\n\n")
		}
	}
	

	let names472 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal472
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names472[rand() % names472.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog472 : Animal472
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation472 : Dog472
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList472<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff472()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog472 [5] {
				if i % 2 == 1   { it = alloc Dalmation472 }
				else            { it = alloc Dog472 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList472<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff472()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 472 done\n\n")
		}
	}
	

	let names473 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal473
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names473[rand() % names473.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog473 : Animal473
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation473 : Dog473
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList473<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff473()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog473 [5] {
				if i % 2 == 1   { it = alloc Dalmation473 }
				else            { it = alloc Dog473 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList473<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff473()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 473 done\n\n")
		}
	}
	

	let names474 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal474
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names474[rand() % names474.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog474 : Animal474
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation474 : Dog474
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList474<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff474()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog474 [5] {
				if i % 2 == 1   { it = alloc Dalmation474 }
				else            { it = alloc Dog474 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList474<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff474()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 474 done\n\n")
		}
	}
	

	let names475 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal475
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names475[rand() % names475.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog475 : Animal475
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation475 : Dog475
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList475<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff475()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog475 [5] {
				if i % 2 == 1   { it = alloc Dalmation475 }
				else            { it = alloc Dog475 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList475<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff475()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 475 done\n\n")
		}
	}
	

	let names476 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal476
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names476[rand() % names476.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog476 : Animal476
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation476 : Dog476
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList476<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff476()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog476 [5] {
				if i % 2 == 1   { it = alloc Dalmation476 }
				else            { it = alloc Dog476 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList476<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff476()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 476 done\n\n")
		}
	}
	

	let names477 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal477
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names477[rand() % names477.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog477 : Animal477
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation477 : Dog477
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList477<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff477()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog477 [5] {
				if i % 2 == 1   { it = alloc Dalmation477 }
				else            { it = alloc Dog477 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList477<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff477()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 477 done\n\n")
		}
	}
	

	let names478 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal478
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names478[rand() % names478.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog478 : Animal478
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation478 : Dog478
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList478<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff478()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog478 [5] {
				if i % 2 == 1   { it = alloc Dalmation478 }
				else            { it = alloc Dog478 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList478<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff478()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 478 done\n\n")
		}
	}
	

	let names479 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal479
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names479[rand() % names479.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog479 : Animal479
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation479 : Dog479
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList479<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff479()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog479 [5] {
				if i % 2 == 1   { it = alloc Dalmation479 }
				else            { it = alloc Dog479 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList479<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff479()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 479 done\n\n")
		}
	}
	

	let names480 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal480
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names480[rand() % names480.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog480 : Animal480
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation480 : Dog480
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList480<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff480()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog480 [5] {
				if i % 2 == 1   { it = alloc Dalmation480 }
				else            { it = alloc Dog480 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList480<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff480()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 480 done\n\n")
		}
	}
	

	let names481 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal481
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names481[rand() % names481.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog481 : Animal481
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation481 : Dog481
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList481<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff481()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog481 [5] {
				if i % 2 == 1   { it = alloc Dalmation481 }
				else            { it = alloc Dog481 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList481<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff481()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 481 done\n\n")
		}
	}
	

	let names482 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal482
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names482[rand() % names482.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog482 : Animal482
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation482 : Dog482
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList482<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff482()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog482 [5] {
				if i % 2 == 1   { it = alloc Dalmation482 }
				else            { it = alloc Dog482 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList482<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff482()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 482 done\n\n")
		}
	}
	

	let names483 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal483
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names483[rand() % names483.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog483 : Animal483
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation483 : Dog483
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList483<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff483()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog483 [5] {
				if i % 2 == 1   { it = alloc Dalmation483 }
				else            { it = alloc Dog483 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList483<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff483()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 483 done\n\n")
		}
	}
	

	let names484 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal484
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names484[rand() % names484.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog484 : Animal484
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation484 : Dog484
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList484<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff484()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog484 [5] {
				if i % 2 == 1   { it = alloc Dalmation484 }
				else            { it = alloc Dog484 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList484<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff484()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 484 done\n\n")
		}
	}
	

	let names485 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal485
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names485[rand() % names485.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog485 : Animal485
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation485 : Dog485
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList485<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff485()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog485 [5] {
				if i % 2 == 1   { it = alloc Dalmation485 }
				else            { it = alloc Dog485 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList485<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff485()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 485 done\n\n")
		}
	}
	

	let names486 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal486
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names486[rand() % names486.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog486 : Animal486
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation486 : Dog486
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList486<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff486()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog486 [5] {
				if i % 2 == 1   { it = alloc Dalmation486 }
				else            { it = alloc Dog486 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList486<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff486()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 486 done\n\n")
		}
	}
	

	let names487 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal487
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names487[rand() % names487.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog487 : Animal487
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation487 : Dog487
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList487<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff487()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog487 [5] {
				if i % 2 == 1   { it = alloc Dalmation487 }
				else            { it = alloc Dog487 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList487<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff487()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 487 done\n\n")
		}
	}
	

	let names488 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal488
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names488[rand() % names488.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog488 : Animal488
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation488 : Dog488
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList488<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff488()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog488 [5] {
				if i % 2 == 1   { it = alloc Dalmation488 }
				else            { it = alloc Dog488 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList488<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff488()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 488 done\n\n")
		}
	}
	

	let names489 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal489
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names489[rand() % names489.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog489 : Animal489
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation489 : Dog489
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList489<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff489()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog489 [5] {
				if i % 2 == 1   { it = alloc Dalmation489 }
				else            { it = alloc Dog489 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList489<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff489()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 489 done\n\n")
		}
	}
	

	let names490 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal490
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names490[rand() % names490.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog490 : Animal490
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation490 : Dog490
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList490<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff490()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog490 [5] {
				if i % 2 == 1   { it = alloc Dalmation490 }
				else            { it = alloc Dog490 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList490<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff490()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 490 done\n\n")
		}
	}
	

	let names491 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal491
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names491[rand() % names491.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog491 : Animal491
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation491 : Dog491
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList491<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff491()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog491 [5] {
				if i % 2 == 1   { it = alloc Dalmation491 }
				else            { it = alloc Dog491 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList491<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff491()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 491 done\n\n")
		}
	}
	

	let names492 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal492
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names492[rand() % names492.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog492 : Animal492
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation492 : Dog492
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList492<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff492()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog492 [5] {
				if i % 2 == 1   { it = alloc Dalmation492 }
				else            { it = alloc Dog492 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList492<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff492()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 492 done\n\n")
		}
	}
	

	let names493 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal493
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names493[rand() % names493.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog493 : Animal493
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation493 : Dog493
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList493<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff493()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog493 [5] {
				if i % 2 == 1   { it = alloc Dalmation493 }
				else            { it = alloc Dog493 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList493<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff493()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 493 done\n\n")
		}
	}
	

	let names494 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal494
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names494[rand() % names494.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog494 : Animal494
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation494 : Dog494
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList494<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff494()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog494 [5] {
				if i % 2 == 1   { it = alloc Dalmation494 }
				else            { it = alloc Dog494 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList494<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff494()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 494 done\n\n")
		}
	}
	

	let names495 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal495
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names495[rand() % names495.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog495 : Animal495
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation495 : Dog495
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList495<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff495()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog495 [5] {
				if i % 2 == 1   { it = alloc Dalmation495 }
				else            { it = alloc Dog495 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList495<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff495()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 495 done\n\n")
		}
	}
	

	let names496 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal496
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names496[rand() % names496.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog496 : Animal496
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation496 : Dog496
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList496<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff496()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog496 [5] {
				if i % 2 == 1   { it = alloc Dalmation496 }
				else            { it = alloc Dog496 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList496<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff496()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 496 done\n\n")
		}
	}
	

	let names497 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal497
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names497[rand() % names497.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog497 : Animal497
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation497 : Dog497
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList497<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff497()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog497 [5] {
				if i % 2 == 1   { it = alloc Dalmation497 }
				else            { it = alloc Dog497 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList497<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff497()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 497 done\n\n")
		}
	}
	

	let names498 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal498
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names498[rand() % names498.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog498 : Animal498
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation498 : Dog498
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList498<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff498()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog498 [5] {
				if i % 2 == 1   { it = alloc Dalmation498 }
				else            { it = alloc Dog498 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList498<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff498()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 498 done\n\n")
		}
	}
	

	let names499 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal499
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names499[rand() % names499.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog499 : Animal499
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation499 : Dog499
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList499<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff499()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog499 [5] {
				if i % 2 == 1   { it = alloc Dalmation499 }
				else            { it = alloc Dog499 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList499<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff499()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 499 done\n\n")
		}
	}
	

	let names500 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal500
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names500[rand() % names500.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog500 : Animal500
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation500 : Dog500
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList500<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff500()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog500 [5] {
				if i % 2 == 1   { it = alloc Dalmation500 }
				else            { it = alloc Dog500 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList500<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff500()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 500 done\n\n")
		}
	}
	

	let names501 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal501
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names501[rand() % names501.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog501 : Animal501
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation501 : Dog501
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList501<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff501()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog501 [5] {
				if i % 2 == 1   { it = alloc Dalmation501 }
				else            { it = alloc Dog501 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList501<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff501()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 501 done\n\n")
		}
	}
	

	let names502 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal502
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names502[rand() % names502.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog502 : Animal502
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation502 : Dog502
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList502<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff502()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog502 [5] {
				if i % 2 == 1   { it = alloc Dalmation502 }
				else            { it = alloc Dog502 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList502<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff502()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 502 done\n\n")
		}
	}
	

	let names503 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal503
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names503[rand() % names503.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog503 : Animal503
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation503 : Dog503
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList503<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff503()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog503 [5] {
				if i % 2 == 1   { it = alloc Dalmation503 }
				else            { it = alloc Dog503 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList503<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff503()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 503 done\n\n")
		}
	}
	

	let names504 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal504
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names504[rand() % names504.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog504 : Animal504
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation504 : Dog504
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList504<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff504()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog504 [5] {
				if i % 2 == 1   { it = alloc Dalmation504 }
				else            { it = alloc Dog504 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList504<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff504()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 504 done\n\n")
		}
	}
	

	let names505 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal505
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names505[rand() % names505.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog505 : Animal505
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation505 : Dog505
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList505<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff505()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog505 [5] {
				if i % 2 == 1   { it = alloc Dalmation505 }
				else            { it = alloc Dog505 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList505<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff505()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 505 done\n\n")
		}
	}
	

	let names506 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal506
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names506[rand() % names506.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog506 : Animal506
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation506 : Dog506
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList506<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff506()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog506 [5] {
				if i % 2 == 1   { it = alloc Dalmation506 }
				else            { it = alloc Dog506 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList506<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff506()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 506 done\n\n")
		}
	}
	

	let names507 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal507
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names507[rand() % names507.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog507 : Animal507
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation507 : Dog507
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList507<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff507()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog507 [5] {
				if i % 2 == 1   { it = alloc Dalmation507 }
				else            { it = alloc Dog507 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList507<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff507()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 507 done\n\n")
		}
	}
	

	let names508 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal508
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names508[rand() % names508.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog508 : Animal508
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation508 : Dog508
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList508<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff508()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog508 [5] {
				if i % 2 == 1   { it = alloc Dalmation508 }
				else            { it = alloc Dog508 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList508<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff508()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 508 done\n\n")
		}
	}
	

	let names509 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal509
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names509[rand() % names509.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog509 : Animal509
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation509 : Dog509
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList509<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff509()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog509 [5] {
				if i % 2 == 1   { it = alloc Dalmation509 }
				else            { it = alloc Dog509 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList509<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff509()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 509 done\n\n")
		}
	}
	

	let names510 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal510
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names510[rand() % names510.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog510 : Animal510
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation510 : Dog510
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList510<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff510()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog510 [5] {
				if i % 2 == 1   { it = alloc Dalmation510 }
				else            { it = alloc Dog510 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList510<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff510()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 510 done\n\n")
		}
	}
	

	let names511 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal511
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names511[rand() % names511.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog511 : Animal511
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation511 : Dog511
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList511<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff511()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog511 [5] {
				if i % 2 == 1   { it = alloc Dalmation511 }
				else            { it = alloc Dog511 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList511<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff511()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 511 done\n\n")
		}
	}
	

	let names512 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal512
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names512[rand() % names512.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog512 : Animal512
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation512 : Dog512
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList512<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff512()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog512 [5] {
				if i % 2 == 1   { it = alloc Dalmation512 }
				else            { it = alloc Dog512 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList512<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff512()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 512 done\n\n")
		}
	}
	

	let names513 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal513
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names513[rand() % names513.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog513 : Animal513
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation513 : Dog513
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList513<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff513()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog513 [5] {
				if i % 2 == 1   { it = alloc Dalmation513 }
				else            { it = alloc Dog513 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList513<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff513()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 513 done\n\n")
		}
	}
	

	let names514 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal514
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names514[rand() % names514.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog514 : Animal514
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation514 : Dog514
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList514<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff514()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog514 [5] {
				if i % 2 == 1   { it = alloc Dalmation514 }
				else            { it = alloc Dog514 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList514<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff514()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 514 done\n\n")
		}
	}
	

	let names515 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal515
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names515[rand() % names515.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog515 : Animal515
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation515 : Dog515
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList515<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff515()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog515 [5] {
				if i % 2 == 1   { it = alloc Dalmation515 }
				else            { it = alloc Dog515 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList515<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff515()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 515 done\n\n")
		}
	}
	

	let names516 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal516
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names516[rand() % names516.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog516 : Animal516
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation516 : Dog516
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList516<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff516()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog516 [5] {
				if i % 2 == 1   { it = alloc Dalmation516 }
				else            { it = alloc Dog516 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList516<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff516()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 516 done\n\n")
		}
	}
	

	let names517 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal517
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names517[rand() % names517.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog517 : Animal517
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation517 : Dog517
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList517<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff517()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog517 [5] {
				if i % 2 == 1   { it = alloc Dalmation517 }
				else            { it = alloc Dog517 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList517<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff517()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 517 done\n\n")
		}
	}
	

	let names518 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal518
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names518[rand() % names518.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog518 : Animal518
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation518 : Dog518
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList518<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff518()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog518 [5] {
				if i % 2 == 1   { it = alloc Dalmation518 }
				else            { it = alloc Dog518 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList518<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff518()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 518 done\n\n")
		}
	}
	

	let names519 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal519
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names519[rand() % names519.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog519 : Animal519
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation519 : Dog519
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList519<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff519()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog519 [5] {
				if i % 2 == 1   { it = alloc Dalmation519 }
				else            { it = alloc Dog519 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList519<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff519()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 519 done\n\n")
		}
	}
	

	let names520 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal520
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names520[rand() % names520.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog520 : Animal520
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation520 : Dog520
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList520<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff520()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog520 [5] {
				if i % 2 == 1   { it = alloc Dalmation520 }
				else            { it = alloc Dog520 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList520<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff520()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 520 done\n\n")
		}
	}
	

	let names521 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal521
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names521[rand() % names521.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog521 : Animal521
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation521 : Dog521
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList521<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff521()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog521 [5] {
				if i % 2 == 1   { it = alloc Dalmation521 }
				else            { it = alloc Dog521 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList521<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff521()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 521 done\n\n")
		}
	}
	

	let names522 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal522
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names522[rand() % names522.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog522 : Animal522
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation522 : Dog522
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList522<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff522()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog522 [5] {
				if i % 2 == 1   { it = alloc Dalmation522 }
				else            { it = alloc Dog522 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList522<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff522()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 522 done\n\n")
		}
	}
	

	let names523 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal523
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names523[rand() % names523.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog523 : Animal523
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation523 : Dog523
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList523<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff523()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog523 [5] {
				if i % 2 == 1   { it = alloc Dalmation523 }
				else            { it = alloc Dog523 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList523<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff523()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 523 done\n\n")
		}
	}
	

	let names524 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal524
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names524[rand() % names524.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog524 : Animal524
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation524 : Dog524
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList524<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff524()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog524 [5] {
				if i % 2 == 1   { it = alloc Dalmation524 }
				else            { it = alloc Dog524 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList524<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff524()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 524 done\n\n")
		}
	}
	

	let names525 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal525
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names525[rand() % names525.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog525 : Animal525
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation525 : Dog525
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList525<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff525()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog525 [5] {
				if i % 2 == 1   { it = alloc Dalmation525 }
				else            { it = alloc Dog525 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList525<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff525()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 525 done\n\n")
		}
	}
	

	let names526 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal526
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names526[rand() % names526.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog526 : Animal526
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation526 : Dog526
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList526<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff526()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog526 [5] {
				if i % 2 == 1   { it = alloc Dalmation526 }
				else            { it = alloc Dog526 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList526<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff526()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 526 done\n\n")
		}
	}
	

	let names527 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal527
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names527[rand() % names527.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog527 : Animal527
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation527 : Dog527
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList527<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff527()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog527 [5] {
				if i % 2 == 1   { it = alloc Dalmation527 }
				else            { it = alloc Dog527 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList527<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff527()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 527 done\n\n")
		}
	}
	

	let names528 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal528
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names528[rand() % names528.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog528 : Animal528
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation528 : Dog528
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList528<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff528()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog528 [5] {
				if i % 2 == 1   { it = alloc Dalmation528 }
				else            { it = alloc Dog528 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList528<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff528()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 528 done\n\n")
		}
	}
	

	let names529 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal529
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names529[rand() % names529.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog529 : Animal529
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation529 : Dog529
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList529<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff529()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog529 [5] {
				if i % 2 == 1   { it = alloc Dalmation529 }
				else            { it = alloc Dog529 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList529<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff529()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 529 done\n\n")
		}
	}
	

	let names530 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal530
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names530[rand() % names530.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog530 : Animal530
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation530 : Dog530
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList530<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff530()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog530 [5] {
				if i % 2 == 1   { it = alloc Dalmation530 }
				else            { it = alloc Dog530 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList530<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff530()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 530 done\n\n")
		}
	}
	

	let names531 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal531
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names531[rand() % names531.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog531 : Animal531
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation531 : Dog531
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList531<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff531()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog531 [5] {
				if i % 2 == 1   { it = alloc Dalmation531 }
				else            { it = alloc Dog531 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList531<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff531()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 531 done\n\n")
		}
	}
	

	let names532 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal532
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names532[rand() % names532.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog532 : Animal532
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation532 : Dog532
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList532<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff532()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog532 [5] {
				if i % 2 == 1   { it = alloc Dalmation532 }
				else            { it = alloc Dog532 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList532<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff532()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 532 done\n\n")
		}
	}
	

	let names533 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal533
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names533[rand() % names533.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog533 : Animal533
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation533 : Dog533
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList533<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff533()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog533 [5] {
				if i % 2 == 1   { it = alloc Dalmation533 }
				else            { it = alloc Dog533 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList533<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff533()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 533 done\n\n")
		}
	}
	

	let names534 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal534
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names534[rand() % names534.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog534 : Animal534
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation534 : Dog534
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList534<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff534()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog534 [5] {
				if i % 2 == 1   { it = alloc Dalmation534 }
				else            { it = alloc Dog534 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList534<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff534()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 534 done\n\n")
		}
	}
	

	let names535 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal535
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names535[rand() % names535.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog535 : Animal535
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation535 : Dog535
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList535<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff535()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog535 [5] {
				if i % 2 == 1   { it = alloc Dalmation535 }
				else            { it = alloc Dog535 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList535<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff535()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 535 done\n\n")
		}
	}
	

	let names536 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal536
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names536[rand() % names536.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog536 : Animal536
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation536 : Dog536
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList536<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff536()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog536 [5] {
				if i % 2 == 1   { it = alloc Dalmation536 }
				else            { it = alloc Dog536 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList536<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff536()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 536 done\n\n")
		}
	}
	

	let names537 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal537
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names537[rand() % names537.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog537 : Animal537
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation537 : Dog537
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList537<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff537()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog537 [5] {
				if i % 2 == 1   { it = alloc Dalmation537 }
				else            { it = alloc Dog537 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList537<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff537()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 537 done\n\n")
		}
	}
	

	let names538 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal538
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names538[rand() % names538.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog538 : Animal538
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation538 : Dog538
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList538<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff538()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog538 [5] {
				if i % 2 == 1   { it = alloc Dalmation538 }
				else            { it = alloc Dog538 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList538<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff538()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 538 done\n\n")
		}
	}
	

	let names539 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal539
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names539[rand() % names539.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog539 : Animal539
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation539 : Dog539
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList539<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff539()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog539 [5] {
				if i % 2 == 1   { it = alloc Dalmation539 }
				else            { it = alloc Dog539 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList539<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff539()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 539 done\n\n")
		}
	}
	

	let names540 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal540
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names540[rand() % names540.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog540 : Animal540
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation540 : Dog540
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList540<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff540()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog540 [5] {
				if i % 2 == 1   { it = alloc Dalmation540 }
				else            { it = alloc Dog540 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList540<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff540()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 540 done\n\n")
		}
	}
	

	let names541 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal541
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names541[rand() % names541.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog541 : Animal541
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation541 : Dog541
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList541<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff541()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog541 [5] {
				if i % 2 == 1   { it = alloc Dalmation541 }
				else            { it = alloc Dog541 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList541<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff541()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 541 done\n\n")
		}
	}
	

	let names542 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal542
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names542[rand() % names542.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog542 : Animal542
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation542 : Dog542
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList542<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff542()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog542 [5] {
				if i % 2 == 1   { it = alloc Dalmation542 }
				else            { it = alloc Dog542 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList542<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff542()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 542 done\n\n")
		}
	}
	

	let names543 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal543
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names543[rand() % names543.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog543 : Animal543
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation543 : Dog543
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList543<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff543()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog543 [5] {
				if i % 2 == 1   { it = alloc Dalmation543 }
				else            { it = alloc Dog543 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList543<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff543()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 543 done\n\n")
		}
	}
	

	let names544 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal544
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names544[rand() % names544.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog544 : Animal544
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation544 : Dog544
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList544<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff544()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog544 [5] {
				if i % 2 == 1   { it = alloc Dalmation544 }
				else            { it = alloc Dog544 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList544<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff544()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 544 done\n\n")
		}
	}
	

	let names545 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal545
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names545[rand() % names545.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog545 : Animal545
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation545 : Dog545
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList545<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff545()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog545 [5] {
				if i % 2 == 1   { it = alloc Dalmation545 }
				else            { it = alloc Dog545 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList545<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff545()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 545 done\n\n")
		}
	}
	

	let names546 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal546
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names546[rand() % names546.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog546 : Animal546
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation546 : Dog546
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList546<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff546()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog546 [5] {
				if i % 2 == 1   { it = alloc Dalmation546 }
				else            { it = alloc Dog546 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList546<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff546()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 546 done\n\n")
		}
	}
	

	let names547 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal547
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names547[rand() % names547.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog547 : Animal547
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation547 : Dog547
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList547<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff547()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog547 [5] {
				if i % 2 == 1   { it = alloc Dalmation547 }
				else            { it = alloc Dog547 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList547<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff547()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 547 done\n\n")
		}
	}
	

	let names548 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal548
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names548[rand() % names548.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog548 : Animal548
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation548 : Dog548
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList548<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff548()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog548 [5] {
				if i % 2 == 1   { it = alloc Dalmation548 }
				else            { it = alloc Dog548 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList548<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff548()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 548 done\n\n")
		}
	}
	

	let names549 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal549
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names549[rand() % names549.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog549 : Animal549
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation549 : Dog549
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList549<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff549()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog549 [5] {
				if i % 2 == 1   { it = alloc Dalmation549 }
				else            { it = alloc Dog549 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList549<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff549()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 549 done\n\n")
		}
	}
	

	let names550 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal550
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names550[rand() % names550.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog550 : Animal550
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation550 : Dog550
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList550<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff550()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog550 [5] {
				if i % 2 == 1   { it = alloc Dalmation550 }
				else            { it = alloc Dog550 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList550<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff550()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 550 done\n\n")
		}
	}
	

	let names551 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal551
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names551[rand() % names551.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog551 : Animal551
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation551 : Dog551
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList551<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff551()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog551 [5] {
				if i % 2 == 1   { it = alloc Dalmation551 }
				else            { it = alloc Dog551 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList551<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff551()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 551 done\n\n")
		}
	}
	

	let names552 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal552
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names552[rand() % names552.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog552 : Animal552
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation552 : Dog552
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList552<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff552()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog552 [5] {
				if i % 2 == 1   { it = alloc Dalmation552 }
				else            { it = alloc Dog552 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList552<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff552()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 552 done\n\n")
		}
	}
	

	let names553 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal553
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names553[rand() % names553.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog553 : Animal553
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation553 : Dog553
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList553<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff553()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog553 [5] {
				if i % 2 == 1   { it = alloc Dalmation553 }
				else            { it = alloc Dog553 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList553<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff553()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 553 done\n\n")
		}
	}
	

	let names554 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal554
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names554[rand() % names554.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog554 : Animal554
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation554 : Dog554
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList554<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff554()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog554 [5] {
				if i % 2 == 1   { it = alloc Dalmation554 }
				else            { it = alloc Dog554 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList554<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff554()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 554 done\n\n")
		}
	}
	

	let names555 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal555
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names555[rand() % names555.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog555 : Animal555
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation555 : Dog555
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList555<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff555()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog555 [5] {
				if i % 2 == 1   { it = alloc Dalmation555 }
				else            { it = alloc Dog555 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList555<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff555()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 555 done\n\n")
		}
	}
	

	let names556 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal556
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names556[rand() % names556.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog556 : Animal556
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation556 : Dog556
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList556<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff556()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog556 [5] {
				if i % 2 == 1   { it = alloc Dalmation556 }
				else            { it = alloc Dog556 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList556<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff556()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 556 done\n\n")
		}
	}
	

	let names557 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal557
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names557[rand() % names557.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog557 : Animal557
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation557 : Dog557
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList557<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff557()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog557 [5] {
				if i % 2 == 1   { it = alloc Dalmation557 }
				else            { it = alloc Dog557 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList557<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff557()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 557 done\n\n")
		}
	}
	

	let names558 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal558
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names558[rand() % names558.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog558 : Animal558
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation558 : Dog558
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList558<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff558()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog558 [5] {
				if i % 2 == 1   { it = alloc Dalmation558 }
				else            { it = alloc Dog558 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList558<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff558()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 558 done\n\n")
		}
	}
	

	let names559 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal559
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names559[rand() % names559.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog559 : Animal559
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation559 : Dog559
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList559<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff559()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog559 [5] {
				if i % 2 == 1   { it = alloc Dalmation559 }
				else            { it = alloc Dog559 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList559<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff559()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 559 done\n\n")
		}
	}
	

	let names560 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal560
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names560[rand() % names560.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog560 : Animal560
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation560 : Dog560
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList560<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff560()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog560 [5] {
				if i % 2 == 1   { it = alloc Dalmation560 }
				else            { it = alloc Dog560 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList560<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff560()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 560 done\n\n")
		}
	}
	

	let names561 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal561
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names561[rand() % names561.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog561 : Animal561
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation561 : Dog561
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList561<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff561()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog561 [5] {
				if i % 2 == 1   { it = alloc Dalmation561 }
				else            { it = alloc Dog561 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList561<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff561()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 561 done\n\n")
		}
	}
	

	let names562 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal562
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names562[rand() % names562.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog562 : Animal562
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation562 : Dog562
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList562<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff562()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog562 [5] {
				if i % 2 == 1   { it = alloc Dalmation562 }
				else            { it = alloc Dog562 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList562<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff562()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 562 done\n\n")
		}
	}
	

	let names563 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal563
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names563[rand() % names563.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog563 : Animal563
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation563 : Dog563
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList563<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff563()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog563 [5] {
				if i % 2 == 1   { it = alloc Dalmation563 }
				else            { it = alloc Dog563 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList563<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff563()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 563 done\n\n")
		}
	}
	

	let names564 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal564
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names564[rand() % names564.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog564 : Animal564
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation564 : Dog564
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList564<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff564()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog564 [5] {
				if i % 2 == 1   { it = alloc Dalmation564 }
				else            { it = alloc Dog564 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList564<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff564()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 564 done\n\n")
		}
	}
	

	let names565 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal565
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names565[rand() % names565.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog565 : Animal565
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation565 : Dog565
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList565<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff565()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog565 [5] {
				if i % 2 == 1   { it = alloc Dalmation565 }
				else            { it = alloc Dog565 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList565<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff565()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 565 done\n\n")
		}
	}
	

	let names566 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal566
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names566[rand() % names566.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog566 : Animal566
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation566 : Dog566
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList566<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff566()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog566 [5] {
				if i % 2 == 1   { it = alloc Dalmation566 }
				else            { it = alloc Dog566 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList566<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff566()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 566 done\n\n")
		}
	}
	

	let names567 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal567
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names567[rand() % names567.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog567 : Animal567
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation567 : Dog567
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList567<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff567()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog567 [5] {
				if i % 2 == 1   { it = alloc Dalmation567 }
				else            { it = alloc Dog567 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList567<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff567()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 567 done\n\n")
		}
	}
	

	let names568 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal568
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names568[rand() % names568.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog568 : Animal568
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation568 : Dog568
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList568<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff568()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog568 [5] {
				if i % 2 == 1   { it = alloc Dalmation568 }
				else            { it = alloc Dog568 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList568<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff568()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 568 done\n\n")
		}
	}
	

	let names569 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal569
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names569[rand() % names569.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog569 : Animal569
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation569 : Dog569
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList569<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff569()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog569 [5] {
				if i % 2 == 1   { it = alloc Dalmation569 }
				else            { it = alloc Dog569 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList569<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff569()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 569 done\n\n")
		}
	}
	

	let names570 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal570
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names570[rand() % names570.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog570 : Animal570
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation570 : Dog570
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList570<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff570()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog570 [5] {
				if i % 2 == 1   { it = alloc Dalmation570 }
				else            { it = alloc Dog570 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList570<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff570()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 570 done\n\n")
		}
	}
	

	let names571 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal571
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names571[rand() % names571.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog571 : Animal571
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation571 : Dog571
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList571<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff571()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog571 [5] {
				if i % 2 == 1   { it = alloc Dalmation571 }
				else            { it = alloc Dog571 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList571<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff571()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 571 done\n\n")
		}
	}
	

	let names572 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal572
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names572[rand() % names572.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog572 : Animal572
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation572 : Dog572
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList572<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff572()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog572 [5] {
				if i % 2 == 1   { it = alloc Dalmation572 }
				else            { it = alloc Dog572 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList572<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff572()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 572 done\n\n")
		}
	}
	

	let names573 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal573
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names573[rand() % names573.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog573 : Animal573
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation573 : Dog573
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList573<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff573()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog573 [5] {
				if i % 2 == 1   { it = alloc Dalmation573 }
				else            { it = alloc Dog573 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList573<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff573()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 573 done\n\n")
		}
	}
	

	let names574 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal574
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names574[rand() % names574.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog574 : Animal574
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation574 : Dog574
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList574<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff574()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog574 [5] {
				if i % 2 == 1   { it = alloc Dalmation574 }
				else            { it = alloc Dog574 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList574<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff574()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 574 done\n\n")
		}
	}
	

	let names575 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal575
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names575[rand() % names575.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog575 : Animal575
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation575 : Dog575
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList575<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff575()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog575 [5] {
				if i % 2 == 1   { it = alloc Dalmation575 }
				else            { it = alloc Dog575 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList575<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff575()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 575 done\n\n")
		}
	}
	

	let names576 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal576
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names576[rand() % names576.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog576 : Animal576
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation576 : Dog576
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList576<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff576()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog576 [5] {
				if i % 2 == 1   { it = alloc Dalmation576 }
				else            { it = alloc Dog576 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList576<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff576()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 576 done\n\n")
		}
	}
	

	let names577 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal577
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names577[rand() % names577.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog577 : Animal577
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation577 : Dog577
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList577<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff577()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog577 [5] {
				if i % 2 == 1   { it = alloc Dalmation577 }
				else            { it = alloc Dog577 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList577<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff577()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 577 done\n\n")
		}
	}
	

	let names578 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal578
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names578[rand() % names578.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog578 : Animal578
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation578 : Dog578
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList578<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff578()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog578 [5] {
				if i % 2 == 1   { it = alloc Dalmation578 }
				else            { it = alloc Dog578 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList578<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff578()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 578 done\n\n")
		}
	}
	

	let names579 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal579
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names579[rand() % names579.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog579 : Animal579
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation579 : Dog579
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList579<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff579()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog579 [5] {
				if i % 2 == 1   { it = alloc Dalmation579 }
				else            { it = alloc Dog579 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList579<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff579()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 579 done\n\n")
		}
	}
	

	let names580 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal580
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names580[rand() % names580.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog580 : Animal580
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation580 : Dog580
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList580<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff580()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog580 [5] {
				if i % 2 == 1   { it = alloc Dalmation580 }
				else            { it = alloc Dog580 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList580<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff580()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 580 done\n\n")
		}
	}
	

	let names581 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal581
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names581[rand() % names581.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog581 : Animal581
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation581 : Dog581
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList581<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff581()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog581 [5] {
				if i % 2 == 1   { it = alloc Dalmation581 }
				else            { it = alloc Dog581 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList581<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff581()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 581 done\n\n")
		}
	}
	

	let names582 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal582
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names582[rand() % names582.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog582 : Animal582
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation582 : Dog582
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList582<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff582()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog582 [5] {
				if i % 2 == 1   { it = alloc Dalmation582 }
				else            { it = alloc Dog582 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList582<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff582()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 582 done\n\n")
		}
	}
	

	let names583 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal583
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names583[rand() % names583.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog583 : Animal583
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation583 : Dog583
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList583<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff583()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog583 [5] {
				if i % 2 == 1   { it = alloc Dalmation583 }
				else            { it = alloc Dog583 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList583<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff583()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 583 done\n\n")
		}
	}
	

	let names584 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal584
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names584[rand() % names584.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog584 : Animal584
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation584 : Dog584
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList584<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff584()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog584 [5] {
				if i % 2 == 1   { it = alloc Dalmation584 }
				else            { it = alloc Dog584 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList584<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff584()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 584 done\n\n")
		}
	}
	

	let names585 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal585
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names585[rand() % names585.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog585 : Animal585
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation585 : Dog585
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList585<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff585()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog585 [5] {
				if i % 2 == 1   { it = alloc Dalmation585 }
				else            { it = alloc Dog585 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList585<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff585()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 585 done\n\n")
		}
	}
	

	let names586 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal586
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names586[rand() % names586.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog586 : Animal586
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation586 : Dog586
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList586<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff586()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog586 [5] {
				if i % 2 == 1   { it = alloc Dalmation586 }
				else            { it = alloc Dog586 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList586<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff586()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 586 done\n\n")
		}
	}
	

	let names587 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal587
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names587[rand() % names587.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog587 : Animal587
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation587 : Dog587
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList587<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff587()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog587 [5] {
				if i % 2 == 1   { it = alloc Dalmation587 }
				else            { it = alloc Dog587 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList587<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff587()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 587 done\n\n")
		}
	}
	

	let names588 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal588
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names588[rand() % names588.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog588 : Animal588
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation588 : Dog588
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList588<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff588()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog588 [5] {
				if i % 2 == 1   { it = alloc Dalmation588 }
				else            { it = alloc Dog588 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList588<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff588()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 588 done\n\n")
		}
	}
	

	let names589 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal589
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names589[rand() % names589.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog589 : Animal589
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation589 : Dog589
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList589<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff589()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog589 [5] {
				if i % 2 == 1   { it = alloc Dalmation589 }
				else            { it = alloc Dog589 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList589<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff589()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 589 done\n\n")
		}
	}
	

	let names590 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal590
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names590[rand() % names590.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog590 : Animal590
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation590 : Dog590
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList590<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff590()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog590 [5] {
				if i % 2 == 1   { it = alloc Dalmation590 }
				else            { it = alloc Dog590 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList590<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff590()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 590 done\n\n")
		}
	}
	

	let names591 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal591
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names591[rand() % names591.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog591 : Animal591
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation591 : Dog591
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList591<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff591()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog591 [5] {
				if i % 2 == 1   { it = alloc Dalmation591 }
				else            { it = alloc Dog591 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList591<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff591()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 591 done\n\n")
		}
	}
	

	let names592 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal592
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names592[rand() % names592.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog592 : Animal592
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation592 : Dog592
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList592<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff592()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog592 [5] {
				if i % 2 == 1   { it = alloc Dalmation592 }
				else            { it = alloc Dog592 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList592<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff592()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 592 done\n\n")
		}
	}
	

	let names593 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal593
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names593[rand() % names593.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog593 : Animal593
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation593 : Dog593
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList593<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff593()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog593 [5] {
				if i % 2 == 1   { it = alloc Dalmation593 }
				else            { it = alloc Dog593 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList593<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff593()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 593 done\n\n")
		}
	}
	

	let names594 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal594
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names594[rand() % names594.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog594 : Animal594
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation594 : Dog594
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList594<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff594()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog594 [5] {
				if i % 2 == 1   { it = alloc Dalmation594 }
				else            { it = alloc Dog594 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList594<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff594()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 594 done\n\n")
		}
	}
	

	let names595 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal595
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names595[rand() % names595.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog595 : Animal595
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation595 : Dog595
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList595<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff595()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog595 [5] {
				if i % 2 == 1   { it = alloc Dalmation595 }
				else            { it = alloc Dog595 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList595<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff595()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 595 done\n\n")
		}
	}
	

	let names596 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal596
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names596[rand() % names596.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog596 : Animal596
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation596 : Dog596
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList596<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff596()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog596 [5] {
				if i % 2 == 1   { it = alloc Dalmation596 }
				else            { it = alloc Dog596 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList596<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff596()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 596 done\n\n")
		}
	}
	

	let names597 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal597
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names597[rand() % names597.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog597 : Animal597
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation597 : Dog597
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList597<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff597()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog597 [5] {
				if i % 2 == 1   { it = alloc Dalmation597 }
				else            { it = alloc Dog597 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList597<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff597()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 597 done\n\n")
		}
	}
	

	let names598 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal598
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names598[rand() % names598.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog598 : Animal598
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation598 : Dog598
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList598<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff598()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog598 [5] {
				if i % 2 == 1   { it = alloc Dalmation598 }
				else            { it = alloc Dog598 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList598<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff598()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 598 done\n\n")
		}
	}
	

	let names599 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal599
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names599[rand() % names599.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog599 : Animal599
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation599 : Dog599
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList599<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff599()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog599 [5] {
				if i % 2 == 1   { it = alloc Dalmation599 }
				else            { it = alloc Dog599 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList599<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff599()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 599 done\n\n")
		}
	}
	

	let names600 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal600
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names600[rand() % names600.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog600 : Animal600
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation600 : Dog600
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList600<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff600()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog600 [5] {
				if i % 2 == 1   { it = alloc Dalmation600 }
				else            { it = alloc Dog600 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList600<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff600()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 600 done\n\n")
		}
	}
	

	let names601 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal601
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names601[rand() % names601.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog601 : Animal601
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation601 : Dog601
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList601<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff601()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog601 [5] {
				if i % 2 == 1   { it = alloc Dalmation601 }
				else            { it = alloc Dog601 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList601<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff601()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 601 done\n\n")
		}
	}
	

	let names602 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal602
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names602[rand() % names602.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog602 : Animal602
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation602 : Dog602
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList602<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff602()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog602 [5] {
				if i % 2 == 1   { it = alloc Dalmation602 }
				else            { it = alloc Dog602 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList602<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff602()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 602 done\n\n")
		}
	}
	

	let names603 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal603
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names603[rand() % names603.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog603 : Animal603
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation603 : Dog603
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList603<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff603()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog603 [5] {
				if i % 2 == 1   { it = alloc Dalmation603 }
				else            { it = alloc Dog603 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList603<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff603()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 603 done\n\n")
		}
	}
	

	let names604 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal604
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names604[rand() % names604.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog604 : Animal604
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation604 : Dog604
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList604<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff604()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog604 [5] {
				if i % 2 == 1   { it = alloc Dalmation604 }
				else            { it = alloc Dog604 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList604<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff604()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 604 done\n\n")
		}
	}
	

	let names605 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal605
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names605[rand() % names605.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog605 : Animal605
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation605 : Dog605
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList605<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff605()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog605 [5] {
				if i % 2 == 1   { it = alloc Dalmation605 }
				else            { it = alloc Dog605 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList605<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff605()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 605 done\n\n")
		}
	}
	

	let names606 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal606
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names606[rand() % names606.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog606 : Animal606
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation606 : Dog606
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList606<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff606()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog606 [5] {
				if i % 2 == 1   { it = alloc Dalmation606 }
				else            { it = alloc Dog606 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList606<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff606()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 606 done\n\n")
		}
	}
	

	let names607 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal607
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names607[rand() % names607.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog607 : Animal607
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation607 : Dog607
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList607<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff607()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog607 [5] {
				if i % 2 == 1   { it = alloc Dalmation607 }
				else            { it = alloc Dog607 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList607<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff607()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 607 done\n\n")
		}
	}
	

	let names608 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal608
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names608[rand() % names608.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog608 : Animal608
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation608 : Dog608
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList608<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff608()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog608 [5] {
				if i % 2 == 1   { it = alloc Dalmation608 }
				else            { it = alloc Dog608 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList608<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff608()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 608 done\n\n")
		}
	}
	

	let names609 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal609
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names609[rand() % names609.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog609 : Animal609
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation609 : Dog609
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList609<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff609()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog609 [5] {
				if i % 2 == 1   { it = alloc Dalmation609 }
				else            { it = alloc Dog609 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList609<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff609()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 609 done\n\n")
		}
	}
	

	let names610 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal610
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names610[rand() % names610.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog610 : Animal610
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation610 : Dog610
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList610<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff610()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog610 [5] {
				if i % 2 == 1   { it = alloc Dalmation610 }
				else            { it = alloc Dog610 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList610<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff610()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 610 done\n\n")
		}
	}
	

	let names611 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal611
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names611[rand() % names611.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog611 : Animal611
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation611 : Dog611
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList611<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff611()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog611 [5] {
				if i % 2 == 1   { it = alloc Dalmation611 }
				else            { it = alloc Dog611 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList611<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff611()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 611 done\n\n")
		}
	}
	

	let names612 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal612
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names612[rand() % names612.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog612 : Animal612
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation612 : Dog612
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList612<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff612()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog612 [5] {
				if i % 2 == 1   { it = alloc Dalmation612 }
				else            { it = alloc Dog612 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList612<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff612()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 612 done\n\n")
		}
	}
	

	let names613 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal613
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names613[rand() % names613.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog613 : Animal613
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation613 : Dog613
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList613<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff613()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog613 [5] {
				if i % 2 == 1   { it = alloc Dalmation613 }
				else            { it = alloc Dog613 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList613<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff613()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 613 done\n\n")
		}
	}
	

	let names614 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal614
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names614[rand() % names614.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog614 : Animal614
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation614 : Dog614
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList614<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff614()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog614 [5] {
				if i % 2 == 1   { it = alloc Dalmation614 }
				else            { it = alloc Dog614 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList614<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff614()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 614 done\n\n")
		}
	}
	

	let names615 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal615
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names615[rand() % names615.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog615 : Animal615
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation615 : Dog615
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList615<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff615()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog615 [5] {
				if i % 2 == 1   { it = alloc Dalmation615 }
				else            { it = alloc Dog615 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList615<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff615()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 615 done\n\n")
		}
	}
	

	let names616 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal616
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names616[rand() % names616.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog616 : Animal616
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation616 : Dog616
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList616<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff616()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog616 [5] {
				if i % 2 == 1   { it = alloc Dalmation616 }
				else            { it = alloc Dog616 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList616<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff616()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 616 done\n\n")
		}
	}
	

	let names617 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal617
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names617[rand() % names617.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog617 : Animal617
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation617 : Dog617
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList617<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff617()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog617 [5] {
				if i % 2 == 1   { it = alloc Dalmation617 }
				else            { it = alloc Dog617 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList617<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff617()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 617 done\n\n")
		}
	}
	

	let names618 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal618
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names618[rand() % names618.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog618 : Animal618
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation618 : Dog618
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList618<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff618()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog618 [5] {
				if i % 2 == 1   { it = alloc Dalmation618 }
				else            { it = alloc Dog618 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList618<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff618()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 618 done\n\n")
		}
	}
	

	let names619 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal619
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names619[rand() % names619.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog619 : Animal619
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation619 : Dog619
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList619<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff619()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog619 [5] {
				if i % 2 == 1   { it = alloc Dalmation619 }
				else            { it = alloc Dog619 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList619<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff619()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 619 done\n\n")
		}
	}
	

	let names620 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal620
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names620[rand() % names620.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog620 : Animal620
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation620 : Dog620
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList620<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff620()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog620 [5] {
				if i % 2 == 1   { it = alloc Dalmation620 }
				else            { it = alloc Dog620 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList620<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff620()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 620 done\n\n")
		}
	}
	

	let names621 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal621
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names621[rand() % names621.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog621 : Animal621
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation621 : Dog621
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList621<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff621()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog621 [5] {
				if i % 2 == 1   { it = alloc Dalmation621 }
				else            { it = alloc Dog621 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList621<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff621()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 621 done\n\n")
		}
	}
	

	let names622 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal622
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names622[rand() % names622.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog622 : Animal622
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation622 : Dog622
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList622<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff622()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog622 [5] {
				if i % 2 == 1   { it = alloc Dalmation622 }
				else            { it = alloc Dog622 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList622<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff622()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 622 done\n\n")
		}
	}
	

	let names623 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal623
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names623[rand() % names623.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog623 : Animal623
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation623 : Dog623
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList623<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff623()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog623 [5] {
				if i % 2 == 1   { it = alloc Dalmation623 }
				else            { it = alloc Dog623 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList623<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff623()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 623 done\n\n")
		}
	}
	

	let names624 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal624
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names624[rand() % names624.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog624 : Animal624
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation624 : Dog624
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList624<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff624()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog624 [5] {
				if i % 2 == 1   { it = alloc Dalmation624 }
				else            { it = alloc Dog624 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList624<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff624()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 624 done\n\n")
		}
	}
	

	let names625 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal625
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names625[rand() % names625.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog625 : Animal625
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation625 : Dog625
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList625<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff625()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog625 [5] {
				if i % 2 == 1   { it = alloc Dalmation625 }
				else            { it = alloc Dog625 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList625<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff625()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 625 done\n\n")
		}
	}
	

	let names626 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal626
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names626[rand() % names626.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog626 : Animal626
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation626 : Dog626
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList626<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff626()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog626 [5] {
				if i % 2 == 1   { it = alloc Dalmation626 }
				else            { it = alloc Dog626 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList626<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff626()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 626 done\n\n")
		}
	}
	

	let names627 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal627
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names627[rand() % names627.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog627 : Animal627
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation627 : Dog627
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList627<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff627()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog627 [5] {
				if i % 2 == 1   { it = alloc Dalmation627 }
				else            { it = alloc Dog627 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList627<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff627()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 627 done\n\n")
		}
	}
	

	let names628 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal628
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names628[rand() % names628.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog628 : Animal628
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation628 : Dog628
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList628<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff628()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog628 [5] {
				if i % 2 == 1   { it = alloc Dalmation628 }
				else            { it = alloc Dog628 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList628<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff628()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 628 done\n\n")
		}
	}
	

	let names629 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal629
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names629[rand() % names629.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog629 : Animal629
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation629 : Dog629
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList629<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff629()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog629 [5] {
				if i % 2 == 1   { it = alloc Dalmation629 }
				else            { it = alloc Dog629 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList629<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff629()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 629 done\n\n")
		}
	}
	

	let names630 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal630
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names630[rand() % names630.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog630 : Animal630
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation630 : Dog630
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList630<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff630()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog630 [5] {
				if i % 2 == 1   { it = alloc Dalmation630 }
				else            { it = alloc Dog630 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList630<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff630()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 630 done\n\n")
		}
	}
	

	let names631 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal631
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names631[rand() % names631.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog631 : Animal631
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation631 : Dog631
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList631<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff631()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog631 [5] {
				if i % 2 == 1   { it = alloc Dalmation631 }
				else            { it = alloc Dog631 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList631<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff631()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 631 done\n\n")
		}
	}
	

	let names632 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal632
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names632[rand() % names632.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog632 : Animal632
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation632 : Dog632
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList632<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff632()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog632 [5] {
				if i % 2 == 1   { it = alloc Dalmation632 }
				else            { it = alloc Dog632 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList632<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff632()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 632 done\n\n")
		}
	}
	

	let names633 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal633
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names633[rand() % names633.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog633 : Animal633
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation633 : Dog633
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList633<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff633()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog633 [5] {
				if i % 2 == 1   { it = alloc Dalmation633 }
				else            { it = alloc Dog633 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList633<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff633()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 633 done\n\n")
		}
	}
	

	let names634 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal634
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names634[rand() % names634.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog634 : Animal634
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation634 : Dog634
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList634<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff634()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog634 [5] {
				if i % 2 == 1   { it = alloc Dalmation634 }
				else            { it = alloc Dog634 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList634<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff634()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 634 done\n\n")
		}
	}
	

	let names635 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal635
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names635[rand() % names635.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog635 : Animal635
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation635 : Dog635
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList635<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff635()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog635 [5] {
				if i % 2 == 1   { it = alloc Dalmation635 }
				else            { it = alloc Dog635 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList635<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff635()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 635 done\n\n")
		}
	}
	

	let names636 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal636
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names636[rand() % names636.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog636 : Animal636
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation636 : Dog636
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList636<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff636()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog636 [5] {
				if i % 2 == 1   { it = alloc Dalmation636 }
				else            { it = alloc Dog636 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList636<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff636()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 636 done\n\n")
		}
	}
	

	let names637 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal637
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names637[rand() % names637.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog637 : Animal637
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation637 : Dog637
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList637<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff637()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog637 [5] {
				if i % 2 == 1   { it = alloc Dalmation637 }
				else            { it = alloc Dog637 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList637<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff637()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 637 done\n\n")
		}
	}
	

	let names638 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal638
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names638[rand() % names638.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog638 : Animal638
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation638 : Dog638
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList638<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff638()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog638 [5] {
				if i % 2 == 1   { it = alloc Dalmation638 }
				else            { it = alloc Dog638 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList638<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff638()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 638 done\n\n")
		}
	}
	

	let names639 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal639
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names639[rand() % names639.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog639 : Animal639
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation639 : Dog639
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList639<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff639()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog639 [5] {
				if i % 2 == 1   { it = alloc Dalmation639 }
				else            { it = alloc Dog639 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList639<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff639()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 639 done\n\n")
		}
	}
	

	let names640 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal640
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names640[rand() % names640.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog640 : Animal640
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation640 : Dog640
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList640<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff640()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog640 [5] {
				if i % 2 == 1   { it = alloc Dalmation640 }
				else            { it = alloc Dog640 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList640<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff640()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 640 done\n\n")
		}
	}
	

	let names641 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal641
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names641[rand() % names641.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog641 : Animal641
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation641 : Dog641
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList641<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff641()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog641 [5] {
				if i % 2 == 1   { it = alloc Dalmation641 }
				else            { it = alloc Dog641 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList641<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff641()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 641 done\n\n")
		}
	}
	

	let names642 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal642
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names642[rand() % names642.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog642 : Animal642
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation642 : Dog642
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList642<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff642()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog642 [5] {
				if i % 2 == 1   { it = alloc Dalmation642 }
				else            { it = alloc Dog642 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList642<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff642()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 642 done\n\n")
		}
	}
	

	let names643 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal643
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names643[rand() % names643.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog643 : Animal643
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation643 : Dog643
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList643<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff643()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog643 [5] {
				if i % 2 == 1   { it = alloc Dalmation643 }
				else            { it = alloc Dog643 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList643<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff643()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 643 done\n\n")
		}
	}
	

	let names644 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal644
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names644[rand() % names644.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog644 : Animal644
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation644 : Dog644
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList644<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff644()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog644 [5] {
				if i % 2 == 1   { it = alloc Dalmation644 }
				else            { it = alloc Dog644 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList644<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff644()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 644 done\n\n")
		}
	}
	

	let names645 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal645
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names645[rand() % names645.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog645 : Animal645
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation645 : Dog645
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList645<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff645()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog645 [5] {
				if i % 2 == 1   { it = alloc Dalmation645 }
				else            { it = alloc Dog645 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList645<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff645()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 645 done\n\n")
		}
	}
	

	let names646 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal646
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names646[rand() % names646.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog646 : Animal646
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation646 : Dog646
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList646<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff646()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog646 [5] {
				if i % 2 == 1   { it = alloc Dalmation646 }
				else            { it = alloc Dog646 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList646<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff646()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 646 done\n\n")
		}
	}
	

	let names647 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal647
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names647[rand() % names647.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog647 : Animal647
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation647 : Dog647
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList647<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff647()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog647 [5] {
				if i % 2 == 1   { it = alloc Dalmation647 }
				else            { it = alloc Dog647 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList647<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff647()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 647 done\n\n")
		}
	}
	

	let names648 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal648
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names648[rand() % names648.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog648 : Animal648
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation648 : Dog648
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList648<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff648()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog648 [5] {
				if i % 2 == 1   { it = alloc Dalmation648 }
				else            { it = alloc Dog648 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList648<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff648()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 648 done\n\n")
		}
	}
	

	let names649 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal649
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names649[rand() % names649.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog649 : Animal649
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation649 : Dog649
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList649<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff649()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog649 [5] {
				if i % 2 == 1   { it = alloc Dalmation649 }
				else            { it = alloc Dog649 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList649<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff649()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 649 done\n\n")
		}
	}
	

	let names650 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal650
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names650[rand() % names650.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog650 : Animal650
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation650 : Dog650
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList650<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff650()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog650 [5] {
				if i % 2 == 1   { it = alloc Dalmation650 }
				else            { it = alloc Dog650 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList650<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff650()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 650 done\n\n")
		}
	}
	

	let names651 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal651
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names651[rand() % names651.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog651 : Animal651
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation651 : Dog651
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList651<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff651()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog651 [5] {
				if i % 2 == 1   { it = alloc Dalmation651 }
				else            { it = alloc Dog651 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList651<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff651()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 651 done\n\n")
		}
	}
	

	let names652 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal652
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names652[rand() % names652.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog652 : Animal652
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation652 : Dog652
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList652<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff652()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog652 [5] {
				if i % 2 == 1   { it = alloc Dalmation652 }
				else            { it = alloc Dog652 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList652<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff652()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 652 done\n\n")
		}
	}
	

	let names653 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal653
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names653[rand() % names653.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog653 : Animal653
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation653 : Dog653
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList653<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff653()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog653 [5] {
				if i % 2 == 1   { it = alloc Dalmation653 }
				else            { it = alloc Dog653 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList653<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff653()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 653 done\n\n")
		}
	}
	

	let names654 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal654
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names654[rand() % names654.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog654 : Animal654
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation654 : Dog654
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList654<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff654()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog654 [5] {
				if i % 2 == 1   { it = alloc Dalmation654 }
				else            { it = alloc Dog654 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList654<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff654()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 654 done\n\n")
		}
	}
	

	let names655 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal655
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names655[rand() % names655.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog655 : Animal655
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation655 : Dog655
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList655<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff655()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog655 [5] {
				if i % 2 == 1   { it = alloc Dalmation655 }
				else            { it = alloc Dog655 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList655<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff655()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 655 done\n\n")
		}
	}
	

	let names656 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal656
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names656[rand() % names656.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog656 : Animal656
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation656 : Dog656
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList656<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff656()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog656 [5] {
				if i % 2 == 1   { it = alloc Dalmation656 }
				else            { it = alloc Dog656 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList656<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff656()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 656 done\n\n")
		}
	}
	

	let names657 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal657
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names657[rand() % names657.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog657 : Animal657
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation657 : Dog657
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList657<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff657()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog657 [5] {
				if i % 2 == 1   { it = alloc Dalmation657 }
				else            { it = alloc Dog657 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList657<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff657()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 657 done\n\n")
		}
	}
	

	let names658 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal658
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names658[rand() % names658.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog658 : Animal658
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation658 : Dog658
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList658<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff658()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog658 [5] {
				if i % 2 == 1   { it = alloc Dalmation658 }
				else            { it = alloc Dog658 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList658<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff658()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 658 done\n\n")
		}
	}
	

	let names659 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal659
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names659[rand() % names659.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog659 : Animal659
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation659 : Dog659
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList659<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff659()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog659 [5] {
				if i % 2 == 1   { it = alloc Dalmation659 }
				else            { it = alloc Dog659 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList659<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff659()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 659 done\n\n")
		}
	}
	

	let names660 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal660
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names660[rand() % names660.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog660 : Animal660
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation660 : Dog660
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList660<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff660()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog660 [5] {
				if i % 2 == 1   { it = alloc Dalmation660 }
				else            { it = alloc Dog660 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList660<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff660()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 660 done\n\n")
		}
	}
	

	let names661 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal661
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names661[rand() % names661.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog661 : Animal661
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation661 : Dog661
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList661<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff661()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog661 [5] {
				if i % 2 == 1   { it = alloc Dalmation661 }
				else            { it = alloc Dog661 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList661<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff661()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 661 done\n\n")
		}
	}
	

	let names662 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal662
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names662[rand() % names662.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog662 : Animal662
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation662 : Dog662
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList662<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff662()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog662 [5] {
				if i % 2 == 1   { it = alloc Dalmation662 }
				else            { it = alloc Dog662 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList662<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff662()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 662 done\n\n")
		}
	}
	

	let names663 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal663
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names663[rand() % names663.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog663 : Animal663
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation663 : Dog663
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList663<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff663()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog663 [5] {
				if i % 2 == 1   { it = alloc Dalmation663 }
				else            { it = alloc Dog663 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList663<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff663()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 663 done\n\n")
		}
	}
	

	let names664 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal664
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names664[rand() % names664.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog664 : Animal664
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation664 : Dog664
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList664<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff664()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog664 [5] {
				if i % 2 == 1   { it = alloc Dalmation664 }
				else            { it = alloc Dog664 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList664<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff664()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 664 done\n\n")
		}
	}
	

	let names665 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal665
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names665[rand() % names665.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog665 : Animal665
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation665 : Dog665
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList665<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff665()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog665 [5] {
				if i % 2 == 1   { it = alloc Dalmation665 }
				else            { it = alloc Dog665 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList665<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff665()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 665 done\n\n")
		}
	}
	

	let names666 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal666
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names666[rand() % names666.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog666 : Animal666
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation666 : Dog666
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList666<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff666()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog666 [5] {
				if i % 2 == 1   { it = alloc Dalmation666 }
				else            { it = alloc Dog666 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList666<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff666()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 666 done\n\n")
		}
	}
	

	let names667 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal667
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names667[rand() % names667.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog667 : Animal667
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation667 : Dog667
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList667<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff667()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog667 [5] {
				if i % 2 == 1   { it = alloc Dalmation667 }
				else            { it = alloc Dog667 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList667<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff667()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 667 done\n\n")
		}
	}
	

	let names668 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal668
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names668[rand() % names668.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog668 : Animal668
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation668 : Dog668
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList668<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff668()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog668 [5] {
				if i % 2 == 1   { it = alloc Dalmation668 }
				else            { it = alloc Dog668 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList668<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff668()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 668 done\n\n")
		}
	}
	

	let names669 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal669
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names669[rand() % names669.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog669 : Animal669
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation669 : Dog669
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList669<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff669()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog669 [5] {
				if i % 2 == 1   { it = alloc Dalmation669 }
				else            { it = alloc Dog669 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList669<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff669()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 669 done\n\n")
		}
	}
	

	let names670 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal670
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names670[rand() % names670.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog670 : Animal670
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation670 : Dog670
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList670<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff670()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog670 [5] {
				if i % 2 == 1   { it = alloc Dalmation670 }
				else            { it = alloc Dog670 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList670<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff670()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 670 done\n\n")
		}
	}
	

	let names671 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal671
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names671[rand() % names671.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog671 : Animal671
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation671 : Dog671
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList671<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff671()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog671 [5] {
				if i % 2 == 1   { it = alloc Dalmation671 }
				else            { it = alloc Dog671 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList671<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff671()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 671 done\n\n")
		}
	}
	

	let names672 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal672
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names672[rand() % names672.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog672 : Animal672
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation672 : Dog672
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList672<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff672()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog672 [5] {
				if i % 2 == 1   { it = alloc Dalmation672 }
				else            { it = alloc Dog672 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList672<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff672()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 672 done\n\n")
		}
	}
	

	let names673 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal673
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names673[rand() % names673.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog673 : Animal673
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation673 : Dog673
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList673<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff673()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog673 [5] {
				if i % 2 == 1   { it = alloc Dalmation673 }
				else            { it = alloc Dog673 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList673<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff673()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 673 done\n\n")
		}
	}
	

	let names674 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal674
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names674[rand() % names674.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog674 : Animal674
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation674 : Dog674
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList674<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff674()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog674 [5] {
				if i % 2 == 1   { it = alloc Dalmation674 }
				else            { it = alloc Dog674 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList674<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff674()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 674 done\n\n")
		}
	}
	

	let names675 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal675
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names675[rand() % names675.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog675 : Animal675
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation675 : Dog675
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList675<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff675()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog675 [5] {
				if i % 2 == 1   { it = alloc Dalmation675 }
				else            { it = alloc Dog675 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList675<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff675()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 675 done\n\n")
		}
	}
	

	let names676 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal676
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names676[rand() % names676.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog676 : Animal676
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation676 : Dog676
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList676<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff676()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog676 [5] {
				if i % 2 == 1   { it = alloc Dalmation676 }
				else            { it = alloc Dog676 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList676<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff676()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 676 done\n\n")
		}
	}
	

	let names677 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal677
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names677[rand() % names677.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog677 : Animal677
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation677 : Dog677
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList677<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff677()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog677 [5] {
				if i % 2 == 1   { it = alloc Dalmation677 }
				else            { it = alloc Dog677 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList677<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff677()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 677 done\n\n")
		}
	}
	

	let names678 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal678
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names678[rand() % names678.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog678 : Animal678
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation678 : Dog678
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList678<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff678()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog678 [5] {
				if i % 2 == 1   { it = alloc Dalmation678 }
				else            { it = alloc Dog678 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList678<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff678()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 678 done\n\n")
		}
	}
	

	let names679 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal679
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names679[rand() % names679.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog679 : Animal679
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation679 : Dog679
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList679<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff679()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog679 [5] {
				if i % 2 == 1   { it = alloc Dalmation679 }
				else            { it = alloc Dog679 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList679<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff679()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 679 done\n\n")
		}
	}
	

	let names680 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal680
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names680[rand() % names680.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog680 : Animal680
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation680 : Dog680
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList680<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff680()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog680 [5] {
				if i % 2 == 1   { it = alloc Dalmation680 }
				else            { it = alloc Dog680 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList680<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff680()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 680 done\n\n")
		}
	}
	

	let names681 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal681
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names681[rand() % names681.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog681 : Animal681
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation681 : Dog681
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList681<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff681()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog681 [5] {
				if i % 2 == 1   { it = alloc Dalmation681 }
				else            { it = alloc Dog681 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList681<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff681()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 681 done\n\n")
		}
	}
	

	let names682 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal682
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names682[rand() % names682.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog682 : Animal682
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation682 : Dog682
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList682<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff682()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog682 [5] {
				if i % 2 == 1   { it = alloc Dalmation682 }
				else            { it = alloc Dog682 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList682<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff682()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 682 done\n\n")
		}
	}
	

	let names683 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal683
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names683[rand() % names683.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog683 : Animal683
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation683 : Dog683
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList683<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff683()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog683 [5] {
				if i % 2 == 1   { it = alloc Dalmation683 }
				else            { it = alloc Dog683 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList683<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff683()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 683 done\n\n")
		}
	}
	

	let names684 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal684
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names684[rand() % names684.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog684 : Animal684
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation684 : Dog684
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList684<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff684()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog684 [5] {
				if i % 2 == 1   { it = alloc Dalmation684 }
				else            { it = alloc Dog684 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList684<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff684()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 684 done\n\n")
		}
	}
	

	let names685 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal685
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names685[rand() % names685.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog685 : Animal685
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation685 : Dog685
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList685<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff685()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog685 [5] {
				if i % 2 == 1   { it = alloc Dalmation685 }
				else            { it = alloc Dog685 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList685<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff685()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 685 done\n\n")
		}
	}
	

	let names686 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal686
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names686[rand() % names686.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog686 : Animal686
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation686 : Dog686
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList686<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff686()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog686 [5] {
				if i % 2 == 1   { it = alloc Dalmation686 }
				else            { it = alloc Dog686 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList686<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff686()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 686 done\n\n")
		}
	}
	

	let names687 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal687
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names687[rand() % names687.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog687 : Animal687
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation687 : Dog687
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList687<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff687()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog687 [5] {
				if i % 2 == 1   { it = alloc Dalmation687 }
				else            { it = alloc Dog687 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList687<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff687()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 687 done\n\n")
		}
	}
	

	let names688 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal688
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names688[rand() % names688.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog688 : Animal688
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation688 : Dog688
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList688<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff688()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog688 [5] {
				if i % 2 == 1   { it = alloc Dalmation688 }
				else            { it = alloc Dog688 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList688<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff688()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 688 done\n\n")
		}
	}
	

	let names689 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal689
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names689[rand() % names689.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog689 : Animal689
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation689 : Dog689
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList689<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff689()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog689 [5] {
				if i % 2 == 1   { it = alloc Dalmation689 }
				else            { it = alloc Dog689 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList689<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff689()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 689 done\n\n")
		}
	}
	

	let names690 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal690
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names690[rand() % names690.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog690 : Animal690
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation690 : Dog690
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList690<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff690()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog690 [5] {
				if i % 2 == 1   { it = alloc Dalmation690 }
				else            { it = alloc Dog690 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList690<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff690()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 690 done\n\n")
		}
	}
	

	let names691 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal691
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names691[rand() % names691.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog691 : Animal691
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation691 : Dog691
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList691<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff691()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog691 [5] {
				if i % 2 == 1   { it = alloc Dalmation691 }
				else            { it = alloc Dog691 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList691<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff691()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 691 done\n\n")
		}
	}
	

	let names692 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal692
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names692[rand() % names692.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog692 : Animal692
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation692 : Dog692
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList692<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff692()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog692 [5] {
				if i % 2 == 1   { it = alloc Dalmation692 }
				else            { it = alloc Dog692 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList692<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff692()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 692 done\n\n")
		}
	}
	

	let names693 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal693
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names693[rand() % names693.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog693 : Animal693
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation693 : Dog693
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList693<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff693()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog693 [5] {
				if i % 2 == 1   { it = alloc Dalmation693 }
				else            { it = alloc Dog693 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList693<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff693()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 693 done\n\n")
		}
	}
	

	let names694 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal694
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names694[rand() % names694.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog694 : Animal694
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation694 : Dog694
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList694<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff694()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog694 [5] {
				if i % 2 == 1   { it = alloc Dalmation694 }
				else            { it = alloc Dog694 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList694<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff694()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 694 done\n\n")
		}
	}
	

	let names695 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal695
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names695[rand() % names695.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog695 : Animal695
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation695 : Dog695
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList695<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff695()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog695 [5] {
				if i % 2 == 1   { it = alloc Dalmation695 }
				else            { it = alloc Dog695 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList695<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff695()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 695 done\n\n")
		}
	}
	

	let names696 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal696
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names696[rand() % names696.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog696 : Animal696
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation696 : Dog696
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList696<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff696()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog696 [5] {
				if i % 2 == 1   { it = alloc Dalmation696 }
				else            { it = alloc Dog696 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList696<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff696()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 696 done\n\n")
		}
	}
	

	let names697 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal697
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names697[rand() % names697.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog697 : Animal697
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation697 : Dog697
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList697<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff697()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog697 [5] {
				if i % 2 == 1   { it = alloc Dalmation697 }
				else            { it = alloc Dog697 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList697<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff697()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 697 done\n\n")
		}
	}
	

	let names698 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal698
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names698[rand() % names698.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog698 : Animal698
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation698 : Dog698
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList698<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff698()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog698 [5] {
				if i % 2 == 1   { it = alloc Dalmation698 }
				else            { it = alloc Dog698 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList698<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff698()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 698 done\n\n")
		}
	}
	

	let names699 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal699
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names699[rand() % names699.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog699 : Animal699
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation699 : Dog699
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList699<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff699()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog699 [5] {
				if i % 2 == 1   { it = alloc Dalmation699 }
				else            { it = alloc Dog699 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList699<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff699()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 699 done\n\n")
		}
	}
	

	let names700 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal700
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names700[rand() % names700.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog700 : Animal700
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation700 : Dog700
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList700<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff700()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog700 [5] {
				if i % 2 == 1   { it = alloc Dalmation700 }
				else            { it = alloc Dog700 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList700<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff700()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 700 done\n\n")
		}
	}
	

	let names701 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal701
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names701[rand() % names701.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog701 : Animal701
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation701 : Dog701
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList701<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff701()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog701 [5] {
				if i % 2 == 1   { it = alloc Dalmation701 }
				else            { it = alloc Dog701 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList701<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff701()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 701 done\n\n")
		}
	}
	

	let names702 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal702
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names702[rand() % names702.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog702 : Animal702
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation702 : Dog702
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList702<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff702()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog702 [5] {
				if i % 2 == 1   { it = alloc Dalmation702 }
				else            { it = alloc Dog702 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList702<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff702()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 702 done\n\n")
		}
	}
	

	let names703 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal703
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names703[rand() % names703.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog703 : Animal703
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation703 : Dog703
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList703<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff703()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog703 [5] {
				if i % 2 == 1   { it = alloc Dalmation703 }
				else            { it = alloc Dog703 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList703<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff703()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 703 done\n\n")
		}
	}
	

	let names704 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal704
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names704[rand() % names704.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog704 : Animal704
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation704 : Dog704
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList704<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff704()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog704 [5] {
				if i % 2 == 1   { it = alloc Dalmation704 }
				else            { it = alloc Dog704 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList704<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff704()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 704 done\n\n")
		}
	}
	

	let names705 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal705
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names705[rand() % names705.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog705 : Animal705
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation705 : Dog705
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList705<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff705()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog705 [5] {
				if i % 2 == 1   { it = alloc Dalmation705 }
				else            { it = alloc Dog705 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList705<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff705()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 705 done\n\n")
		}
	}
	

	let names706 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal706
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names706[rand() % names706.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog706 : Animal706
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation706 : Dog706
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList706<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff706()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog706 [5] {
				if i % 2 == 1   { it = alloc Dalmation706 }
				else            { it = alloc Dog706 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList706<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff706()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 706 done\n\n")
		}
	}
	

	let names707 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal707
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names707[rand() % names707.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog707 : Animal707
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation707 : Dog707
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList707<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff707()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog707 [5] {
				if i % 2 == 1   { it = alloc Dalmation707 }
				else            { it = alloc Dog707 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList707<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff707()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 707 done\n\n")
		}
	}
	

	let names708 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal708
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names708[rand() % names708.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog708 : Animal708
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation708 : Dog708
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList708<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff708()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog708 [5] {
				if i % 2 == 1   { it = alloc Dalmation708 }
				else            { it = alloc Dog708 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList708<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff708()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 708 done\n\n")
		}
	}
	

	let names709 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal709
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names709[rand() % names709.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog709 : Animal709
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation709 : Dog709
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList709<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff709()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog709 [5] {
				if i % 2 == 1   { it = alloc Dalmation709 }
				else            { it = alloc Dog709 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList709<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff709()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 709 done\n\n")
		}
	}
	

	let names710 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal710
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names710[rand() % names710.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog710 : Animal710
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation710 : Dog710
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList710<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff710()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog710 [5] {
				if i % 2 == 1   { it = alloc Dalmation710 }
				else            { it = alloc Dog710 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList710<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff710()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 710 done\n\n")
		}
	}
	

	let names711 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal711
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names711[rand() % names711.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog711 : Animal711
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation711 : Dog711
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList711<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff711()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog711 [5] {
				if i % 2 == 1   { it = alloc Dalmation711 }
				else            { it = alloc Dog711 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList711<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff711()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 711 done\n\n")
		}
	}
	

	let names712 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal712
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names712[rand() % names712.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog712 : Animal712
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation712 : Dog712
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList712<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff712()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog712 [5] {
				if i % 2 == 1   { it = alloc Dalmation712 }
				else            { it = alloc Dog712 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList712<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff712()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 712 done\n\n")
		}
	}
	

	let names713 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal713
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names713[rand() % names713.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog713 : Animal713
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation713 : Dog713
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList713<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff713()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog713 [5] {
				if i % 2 == 1   { it = alloc Dalmation713 }
				else            { it = alloc Dog713 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList713<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff713()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 713 done\n\n")
		}
	}
	

	let names714 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal714
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names714[rand() % names714.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog714 : Animal714
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation714 : Dog714
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList714<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff714()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog714 [5] {
				if i % 2 == 1   { it = alloc Dalmation714 }
				else            { it = alloc Dog714 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList714<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff714()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 714 done\n\n")
		}
	}
	

	let names715 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal715
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names715[rand() % names715.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog715 : Animal715
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation715 : Dog715
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList715<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff715()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog715 [5] {
				if i % 2 == 1   { it = alloc Dalmation715 }
				else            { it = alloc Dog715 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList715<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff715()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 715 done\n\n")
		}
	}
	

	let names716 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal716
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names716[rand() % names716.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog716 : Animal716
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation716 : Dog716
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList716<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff716()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog716 [5] {
				if i % 2 == 1   { it = alloc Dalmation716 }
				else            { it = alloc Dog716 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList716<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff716()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 716 done\n\n")
		}
	}
	

	let names717 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal717
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names717[rand() % names717.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog717 : Animal717
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation717 : Dog717
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList717<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff717()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog717 [5] {
				if i % 2 == 1   { it = alloc Dalmation717 }
				else            { it = alloc Dog717 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList717<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff717()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 717 done\n\n")
		}
	}
	

	let names718 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal718
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names718[rand() % names718.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog718 : Animal718
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation718 : Dog718
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList718<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff718()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog718 [5] {
				if i % 2 == 1   { it = alloc Dalmation718 }
				else            { it = alloc Dog718 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList718<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff718()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 718 done\n\n")
		}
	}
	

	let names719 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal719
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names719[rand() % names719.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog719 : Animal719
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation719 : Dog719
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList719<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff719()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog719 [5] {
				if i % 2 == 1   { it = alloc Dalmation719 }
				else            { it = alloc Dog719 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList719<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff719()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 719 done\n\n")
		}
	}
	

	let names720 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal720
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names720[rand() % names720.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog720 : Animal720
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation720 : Dog720
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList720<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff720()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog720 [5] {
				if i % 2 == 1   { it = alloc Dalmation720 }
				else            { it = alloc Dog720 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList720<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff720()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 720 done\n\n")
		}
	}
	

	let names721 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal721
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names721[rand() % names721.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog721 : Animal721
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation721 : Dog721
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList721<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff721()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog721 [5] {
				if i % 2 == 1   { it = alloc Dalmation721 }
				else            { it = alloc Dog721 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList721<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff721()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 721 done\n\n")
		}
	}
	

	let names722 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal722
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names722[rand() % names722.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog722 : Animal722
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation722 : Dog722
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList722<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff722()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog722 [5] {
				if i % 2 == 1   { it = alloc Dalmation722 }
				else            { it = alloc Dog722 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList722<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff722()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 722 done\n\n")
		}
	}
	

	let names723 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal723
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names723[rand() % names723.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog723 : Animal723
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation723 : Dog723
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList723<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff723()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog723 [5] {
				if i % 2 == 1   { it = alloc Dalmation723 }
				else            { it = alloc Dog723 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList723<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff723()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 723 done\n\n")
		}
	}
	

	let names724 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal724
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names724[rand() % names724.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog724 : Animal724
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation724 : Dog724
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList724<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff724()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog724 [5] {
				if i % 2 == 1   { it = alloc Dalmation724 }
				else            { it = alloc Dog724 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList724<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff724()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 724 done\n\n")
		}
	}
	

	let names725 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal725
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names725[rand() % names725.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog725 : Animal725
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation725 : Dog725
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList725<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff725()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog725 [5] {
				if i % 2 == 1   { it = alloc Dalmation725 }
				else            { it = alloc Dog725 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList725<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff725()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 725 done\n\n")
		}
	}
	

	let names726 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal726
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names726[rand() % names726.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog726 : Animal726
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation726 : Dog726
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList726<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff726()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog726 [5] {
				if i % 2 == 1   { it = alloc Dalmation726 }
				else            { it = alloc Dog726 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList726<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff726()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 726 done\n\n")
		}
	}
	

	let names727 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal727
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names727[rand() % names727.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog727 : Animal727
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation727 : Dog727
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList727<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff727()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog727 [5] {
				if i % 2 == 1   { it = alloc Dalmation727 }
				else            { it = alloc Dog727 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList727<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff727()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 727 done\n\n")
		}
	}
	

	let names728 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal728
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names728[rand() % names728.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog728 : Animal728
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation728 : Dog728
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList728<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff728()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog728 [5] {
				if i % 2 == 1   { it = alloc Dalmation728 }
				else            { it = alloc Dog728 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList728<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff728()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 728 done\n\n")
		}
	}
	

	let names729 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal729
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names729[rand() % names729.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog729 : Animal729
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation729 : Dog729
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList729<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff729()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog729 [5] {
				if i % 2 == 1   { it = alloc Dalmation729 }
				else            { it = alloc Dog729 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList729<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff729()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 729 done\n\n")
		}
	}
	

	let names730 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal730
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names730[rand() % names730.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog730 : Animal730
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation730 : Dog730
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList730<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff730()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog730 [5] {
				if i % 2 == 1   { it = alloc Dalmation730 }
				else            { it = alloc Dog730 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList730<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff730()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 730 done\n\n")
		}
	}
	

	let names731 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal731
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names731[rand() % names731.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog731 : Animal731
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation731 : Dog731
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList731<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff731()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog731 [5] {
				if i % 2 == 1   { it = alloc Dalmation731 }
				else            { it = alloc Dog731 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList731<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff731()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 731 done\n\n")
		}
	}
	

	let names732 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal732
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names732[rand() % names732.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog732 : Animal732
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation732 : Dog732
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList732<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff732()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog732 [5] {
				if i % 2 == 1   { it = alloc Dalmation732 }
				else            { it = alloc Dog732 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList732<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff732()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 732 done\n\n")
		}
	}
	

	let names733 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal733
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names733[rand() % names733.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog733 : Animal733
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation733 : Dog733
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList733<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff733()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog733 [5] {
				if i % 2 == 1   { it = alloc Dalmation733 }
				else            { it = alloc Dog733 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList733<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff733()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 733 done\n\n")
		}
	}
	

	let names734 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal734
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names734[rand() % names734.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog734 : Animal734
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation734 : Dog734
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList734<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff734()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog734 [5] {
				if i % 2 == 1   { it = alloc Dalmation734 }
				else            { it = alloc Dog734 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList734<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff734()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 734 done\n\n")
		}
	}
	

	let names735 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal735
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names735[rand() % names735.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog735 : Animal735
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation735 : Dog735
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList735<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff735()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog735 [5] {
				if i % 2 == 1   { it = alloc Dalmation735 }
				else            { it = alloc Dog735 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList735<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff735()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 735 done\n\n")
		}
	}
	

	let names736 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal736
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names736[rand() % names736.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog736 : Animal736
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation736 : Dog736
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList736<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff736()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog736 [5] {
				if i % 2 == 1   { it = alloc Dalmation736 }
				else            { it = alloc Dog736 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList736<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff736()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 736 done\n\n")
		}
	}
	

	let names737 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal737
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names737[rand() % names737.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog737 : Animal737
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation737 : Dog737
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList737<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff737()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog737 [5] {
				if i % 2 == 1   { it = alloc Dalmation737 }
				else            { it = alloc Dog737 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList737<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff737()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 737 done\n\n")
		}
	}
	

	let names738 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal738
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names738[rand() % names738.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog738 : Animal738
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation738 : Dog738
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList738<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff738()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog738 [5] {
				if i % 2 == 1   { it = alloc Dalmation738 }
				else            { it = alloc Dog738 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList738<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff738()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 738 done\n\n")
		}
	}
	

	let names739 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal739
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names739[rand() % names739.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog739 : Animal739
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation739 : Dog739
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList739<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff739()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog739 [5] {
				if i % 2 == 1   { it = alloc Dalmation739 }
				else            { it = alloc Dog739 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList739<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff739()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 739 done\n\n")
		}
	}
	

	let names740 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal740
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names740[rand() % names740.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog740 : Animal740
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation740 : Dog740
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList740<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff740()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog740 [5] {
				if i % 2 == 1   { it = alloc Dalmation740 }
				else            { it = alloc Dog740 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList740<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff740()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 740 done\n\n")
		}
	}
	

	let names741 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal741
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names741[rand() % names741.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog741 : Animal741
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation741 : Dog741
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList741<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff741()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog741 [5] {
				if i % 2 == 1   { it = alloc Dalmation741 }
				else            { it = alloc Dog741 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList741<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff741()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 741 done\n\n")
		}
	}
	

	let names742 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal742
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names742[rand() % names742.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog742 : Animal742
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation742 : Dog742
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList742<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff742()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog742 [5] {
				if i % 2 == 1   { it = alloc Dalmation742 }
				else            { it = alloc Dog742 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList742<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff742()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 742 done\n\n")
		}
	}
	

	let names743 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal743
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names743[rand() % names743.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog743 : Animal743
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation743 : Dog743
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList743<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff743()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog743 [5] {
				if i % 2 == 1   { it = alloc Dalmation743 }
				else            { it = alloc Dog743 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList743<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff743()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 743 done\n\n")
		}
	}
	

	let names744 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal744
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names744[rand() % names744.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog744 : Animal744
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation744 : Dog744
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList744<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff744()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog744 [5] {
				if i % 2 == 1   { it = alloc Dalmation744 }
				else            { it = alloc Dog744 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList744<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff744()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 744 done\n\n")
		}
	}
	

	let names745 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal745
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names745[rand() % names745.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog745 : Animal745
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation745 : Dog745
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList745<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff745()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog745 [5] {
				if i % 2 == 1   { it = alloc Dalmation745 }
				else            { it = alloc Dog745 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList745<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff745()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 745 done\n\n")
		}
	}
	

	let names746 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal746
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names746[rand() % names746.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog746 : Animal746
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation746 : Dog746
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList746<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff746()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog746 [5] {
				if i % 2 == 1   { it = alloc Dalmation746 }
				else            { it = alloc Dog746 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList746<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff746()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 746 done\n\n")
		}
	}
	

	let names747 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal747
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names747[rand() % names747.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog747 : Animal747
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation747 : Dog747
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList747<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff747()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog747 [5] {
				if i % 2 == 1   { it = alloc Dalmation747 }
				else            { it = alloc Dog747 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList747<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff747()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 747 done\n\n")
		}
	}
	

	let names748 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal748
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names748[rand() % names748.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog748 : Animal748
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation748 : Dog748
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList748<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff748()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog748 [5] {
				if i % 2 == 1   { it = alloc Dalmation748 }
				else            { it = alloc Dog748 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList748<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff748()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 748 done\n\n")
		}
	}
	

	let names749 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal749
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names749[rand() % names749.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog749 : Animal749
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation749 : Dog749
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList749<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff749()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog749 [5] {
				if i % 2 == 1   { it = alloc Dalmation749 }
				else            { it = alloc Dog749 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList749<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff749()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 749 done\n\n")
		}
	}
	

	let names750 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal750
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names750[rand() % names750.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog750 : Animal750
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation750 : Dog750
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList750<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff750()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog750 [5] {
				if i % 2 == 1   { it = alloc Dalmation750 }
				else            { it = alloc Dog750 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList750<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff750()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 750 done\n\n")
		}
	}
	

	let names751 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal751
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names751[rand() % names751.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog751 : Animal751
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation751 : Dog751
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList751<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff751()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog751 [5] {
				if i % 2 == 1   { it = alloc Dalmation751 }
				else            { it = alloc Dog751 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList751<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff751()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 751 done\n\n")
		}
	}
	

	let names752 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal752
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names752[rand() % names752.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog752 : Animal752
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation752 : Dog752
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList752<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff752()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog752 [5] {
				if i % 2 == 1   { it = alloc Dalmation752 }
				else            { it = alloc Dog752 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList752<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff752()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 752 done\n\n")
		}
	}
	

	let names753 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal753
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names753[rand() % names753.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog753 : Animal753
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation753 : Dog753
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList753<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff753()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog753 [5] {
				if i % 2 == 1   { it = alloc Dalmation753 }
				else            { it = alloc Dog753 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList753<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff753()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 753 done\n\n")
		}
	}
	

	let names754 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal754
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names754[rand() % names754.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog754 : Animal754
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation754 : Dog754
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList754<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff754()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog754 [5] {
				if i % 2 == 1   { it = alloc Dalmation754 }
				else            { it = alloc Dog754 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList754<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff754()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 754 done\n\n")
		}
	}
	

	let names755 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal755
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names755[rand() % names755.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog755 : Animal755
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation755 : Dog755
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList755<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff755()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog755 [5] {
				if i % 2 == 1   { it = alloc Dalmation755 }
				else            { it = alloc Dog755 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList755<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff755()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 755 done\n\n")
		}
	}
	

	let names756 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal756
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names756[rand() % names756.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog756 : Animal756
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation756 : Dog756
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList756<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff756()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog756 [5] {
				if i % 2 == 1   { it = alloc Dalmation756 }
				else            { it = alloc Dog756 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList756<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff756()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 756 done\n\n")
		}
	}
	

	let names757 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal757
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names757[rand() % names757.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog757 : Animal757
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation757 : Dog757
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList757<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff757()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog757 [5] {
				if i % 2 == 1   { it = alloc Dalmation757 }
				else            { it = alloc Dog757 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList757<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff757()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 757 done\n\n")
		}
	}
	

	let names758 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal758
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names758[rand() % names758.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog758 : Animal758
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation758 : Dog758
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList758<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff758()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog758 [5] {
				if i % 2 == 1   { it = alloc Dalmation758 }
				else            { it = alloc Dog758 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList758<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff758()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 758 done\n\n")
		}
	}
	

	let names759 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal759
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names759[rand() % names759.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog759 : Animal759
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation759 : Dog759
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList759<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff759()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog759 [5] {
				if i % 2 == 1   { it = alloc Dalmation759 }
				else            { it = alloc Dog759 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList759<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff759()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 759 done\n\n")
		}
	}
	

	let names760 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal760
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names760[rand() % names760.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog760 : Animal760
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation760 : Dog760
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList760<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff760()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog760 [5] {
				if i % 2 == 1   { it = alloc Dalmation760 }
				else            { it = alloc Dog760 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList760<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff760()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 760 done\n\n")
		}
	}
	

	let names761 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal761
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names761[rand() % names761.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog761 : Animal761
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation761 : Dog761
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList761<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff761()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog761 [5] {
				if i % 2 == 1   { it = alloc Dalmation761 }
				else            { it = alloc Dog761 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList761<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff761()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 761 done\n\n")
		}
	}
	

	let names762 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal762
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names762[rand() % names762.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog762 : Animal762
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation762 : Dog762
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList762<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff762()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog762 [5] {
				if i % 2 == 1   { it = alloc Dalmation762 }
				else            { it = alloc Dog762 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList762<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff762()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 762 done\n\n")
		}
	}
	

	let names763 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal763
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names763[rand() % names763.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog763 : Animal763
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation763 : Dog763
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList763<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff763()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog763 [5] {
				if i % 2 == 1   { it = alloc Dalmation763 }
				else            { it = alloc Dog763 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList763<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff763()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 763 done\n\n")
		}
	}
	

	let names764 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal764
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names764[rand() % names764.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog764 : Animal764
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation764 : Dog764
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList764<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff764()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog764 [5] {
				if i % 2 == 1   { it = alloc Dalmation764 }
				else            { it = alloc Dog764 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList764<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff764()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 764 done\n\n")
		}
	}
	

	let names765 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal765
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names765[rand() % names765.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog765 : Animal765
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation765 : Dog765
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList765<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff765()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog765 [5] {
				if i % 2 == 1   { it = alloc Dalmation765 }
				else            { it = alloc Dog765 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList765<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff765()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 765 done\n\n")
		}
	}
	

	let names766 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal766
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names766[rand() % names766.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog766 : Animal766
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation766 : Dog766
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList766<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff766()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog766 [5] {
				if i % 2 == 1   { it = alloc Dalmation766 }
				else            { it = alloc Dog766 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList766<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff766()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 766 done\n\n")
		}
	}
	

	let names767 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal767
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names767[rand() % names767.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog767 : Animal767
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation767 : Dog767
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList767<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff767()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog767 [5] {
				if i % 2 == 1   { it = alloc Dalmation767 }
				else            { it = alloc Dog767 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList767<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff767()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 767 done\n\n")
		}
	}
	

	let names768 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal768
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names768[rand() % names768.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog768 : Animal768
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation768 : Dog768
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList768<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff768()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog768 [5] {
				if i % 2 == 1   { it = alloc Dalmation768 }
				else            { it = alloc Dog768 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList768<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff768()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 768 done\n\n")
		}
	}
	

	let names769 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal769
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names769[rand() % names769.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog769 : Animal769
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation769 : Dog769
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList769<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff769()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog769 [5] {
				if i % 2 == 1   { it = alloc Dalmation769 }
				else            { it = alloc Dog769 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList769<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff769()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 769 done\n\n")
		}
	}
	

	let names770 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal770
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names770[rand() % names770.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog770 : Animal770
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation770 : Dog770
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList770<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff770()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog770 [5] {
				if i % 2 == 1   { it = alloc Dalmation770 }
				else            { it = alloc Dog770 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList770<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff770()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 770 done\n\n")
		}
	}
	

	let names771 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal771
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names771[rand() % names771.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog771 : Animal771
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation771 : Dog771
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList771<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff771()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog771 [5] {
				if i % 2 == 1   { it = alloc Dalmation771 }
				else            { it = alloc Dog771 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList771<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff771()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 771 done\n\n")
		}
	}
	

	let names772 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal772
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names772[rand() % names772.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog772 : Animal772
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation772 : Dog772
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList772<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff772()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog772 [5] {
				if i % 2 == 1   { it = alloc Dalmation772 }
				else            { it = alloc Dog772 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList772<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff772()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 772 done\n\n")
		}
	}
	

	let names773 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal773
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names773[rand() % names773.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog773 : Animal773
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation773 : Dog773
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList773<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff773()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog773 [5] {
				if i % 2 == 1   { it = alloc Dalmation773 }
				else            { it = alloc Dog773 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList773<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff773()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 773 done\n\n")
		}
	}
	

	let names774 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal774
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names774[rand() % names774.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog774 : Animal774
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation774 : Dog774
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList774<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff774()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog774 [5] {
				if i % 2 == 1   { it = alloc Dalmation774 }
				else            { it = alloc Dog774 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList774<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff774()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 774 done\n\n")
		}
	}
	

	let names775 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal775
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names775[rand() % names775.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog775 : Animal775
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation775 : Dog775
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList775<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff775()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog775 [5] {
				if i % 2 == 1   { it = alloc Dalmation775 }
				else            { it = alloc Dog775 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList775<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff775()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 775 done\n\n")
		}
	}
	

	let names776 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal776
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names776[rand() % names776.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog776 : Animal776
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation776 : Dog776
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList776<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff776()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog776 [5] {
				if i % 2 == 1   { it = alloc Dalmation776 }
				else            { it = alloc Dog776 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList776<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff776()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 776 done\n\n")
		}
	}
	

	let names777 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal777
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names777[rand() % names777.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog777 : Animal777
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation777 : Dog777
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList777<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff777()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog777 [5] {
				if i % 2 == 1   { it = alloc Dalmation777 }
				else            { it = alloc Dog777 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList777<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff777()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 777 done\n\n")
		}
	}
	

	let names778 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal778
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names778[rand() % names778.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog778 : Animal778
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation778 : Dog778
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList778<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff778()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog778 [5] {
				if i % 2 == 1   { it = alloc Dalmation778 }
				else            { it = alloc Dog778 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList778<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff778()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 778 done\n\n")
		}
	}
	

	let names779 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal779
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names779[rand() % names779.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog779 : Animal779
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation779 : Dog779
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList779<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff779()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog779 [5] {
				if i % 2 == 1   { it = alloc Dalmation779 }
				else            { it = alloc Dog779 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList779<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff779()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 779 done\n\n")
		}
	}
	

	let names780 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal780
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names780[rand() % names780.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog780 : Animal780
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation780 : Dog780
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList780<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff780()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog780 [5] {
				if i % 2 == 1   { it = alloc Dalmation780 }
				else            { it = alloc Dog780 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList780<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff780()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 780 done\n\n")
		}
	}
	

	let names781 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal781
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names781[rand() % names781.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog781 : Animal781
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation781 : Dog781
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList781<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff781()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog781 [5] {
				if i % 2 == 1   { it = alloc Dalmation781 }
				else            { it = alloc Dog781 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList781<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff781()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 781 done\n\n")
		}
	}
	

	let names782 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal782
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names782[rand() % names782.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog782 : Animal782
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation782 : Dog782
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList782<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff782()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog782 [5] {
				if i % 2 == 1   { it = alloc Dalmation782 }
				else            { it = alloc Dog782 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList782<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff782()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 782 done\n\n")
		}
	}
	

	let names783 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal783
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names783[rand() % names783.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog783 : Animal783
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation783 : Dog783
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList783<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff783()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog783 [5] {
				if i % 2 == 1   { it = alloc Dalmation783 }
				else            { it = alloc Dog783 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList783<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff783()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 783 done\n\n")
		}
	}
	

	let names784 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal784
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names784[rand() % names784.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog784 : Animal784
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation784 : Dog784
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList784<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff784()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog784 [5] {
				if i % 2 == 1   { it = alloc Dalmation784 }
				else            { it = alloc Dog784 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList784<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff784()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 784 done\n\n")
		}
	}
	

	let names785 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal785
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names785[rand() % names785.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog785 : Animal785
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation785 : Dog785
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList785<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff785()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog785 [5] {
				if i % 2 == 1   { it = alloc Dalmation785 }
				else            { it = alloc Dog785 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList785<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff785()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 785 done\n\n")
		}
	}
	

	let names786 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal786
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names786[rand() % names786.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog786 : Animal786
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation786 : Dog786
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList786<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff786()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog786 [5] {
				if i % 2 == 1   { it = alloc Dalmation786 }
				else            { it = alloc Dog786 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList786<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff786()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 786 done\n\n")
		}
	}
	

	let names787 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal787
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names787[rand() % names787.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog787 : Animal787
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation787 : Dog787
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList787<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff787()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog787 [5] {
				if i % 2 == 1   { it = alloc Dalmation787 }
				else            { it = alloc Dog787 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList787<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff787()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 787 done\n\n")
		}
	}
	

	let names788 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal788
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names788[rand() % names788.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog788 : Animal788
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation788 : Dog788
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList788<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff788()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog788 [5] {
				if i % 2 == 1   { it = alloc Dalmation788 }
				else            { it = alloc Dog788 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList788<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff788()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 788 done\n\n")
		}
	}
	

	let names789 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal789
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names789[rand() % names789.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog789 : Animal789
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation789 : Dog789
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList789<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff789()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog789 [5] {
				if i % 2 == 1   { it = alloc Dalmation789 }
				else            { it = alloc Dog789 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList789<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff789()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 789 done\n\n")
		}
	}
	

	let names790 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal790
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names790[rand() % names790.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog790 : Animal790
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation790 : Dog790
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList790<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff790()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog790 [5] {
				if i % 2 == 1   { it = alloc Dalmation790 }
				else            { it = alloc Dog790 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList790<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff790()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 790 done\n\n")
		}
	}
	

	let names791 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal791
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names791[rand() % names791.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog791 : Animal791
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation791 : Dog791
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList791<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff791()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog791 [5] {
				if i % 2 == 1   { it = alloc Dalmation791 }
				else            { it = alloc Dog791 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList791<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff791()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 791 done\n\n")
		}
	}
	

	let names792 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal792
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names792[rand() % names792.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog792 : Animal792
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation792 : Dog792
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList792<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff792()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog792 [5] {
				if i % 2 == 1   { it = alloc Dalmation792 }
				else            { it = alloc Dog792 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList792<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff792()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 792 done\n\n")
		}
	}
	

	let names793 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal793
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names793[rand() % names793.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog793 : Animal793
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation793 : Dog793
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList793<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff793()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog793 [5] {
				if i % 2 == 1   { it = alloc Dalmation793 }
				else            { it = alloc Dog793 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList793<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff793()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 793 done\n\n")
		}
	}
	

	let names794 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal794
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names794[rand() % names794.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog794 : Animal794
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation794 : Dog794
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList794<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff794()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog794 [5] {
				if i % 2 == 1   { it = alloc Dalmation794 }
				else            { it = alloc Dog794 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList794<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff794()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 794 done\n\n")
		}
	}
	

	let names795 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal795
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names795[rand() % names795.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog795 : Animal795
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation795 : Dog795
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList795<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff795()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog795 [5] {
				if i % 2 == 1   { it = alloc Dalmation795 }
				else            { it = alloc Dog795 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList795<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff795()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 795 done\n\n")
		}
	}
	

	let names796 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal796
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names796[rand() % names796.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog796 : Animal796
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation796 : Dog796
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList796<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff796()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog796 [5] {
				if i % 2 == 1   { it = alloc Dalmation796 }
				else            { it = alloc Dog796 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList796<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff796()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 796 done\n\n")
		}
	}
	

	let names797 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal797
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names797[rand() % names797.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog797 : Animal797
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation797 : Dog797
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList797<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff797()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog797 [5] {
				if i % 2 == 1   { it = alloc Dalmation797 }
				else            { it = alloc Dog797 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList797<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff797()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 797 done\n\n")
		}
	}
	

	let names798 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal798
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names798[rand() % names798.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog798 : Animal798
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation798 : Dog798
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList798<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff798()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog798 [5] {
				if i % 2 == 1   { it = alloc Dalmation798 }
				else            { it = alloc Dog798 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList798<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff798()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 798 done\n\n")
		}
	}
	

	let names799 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal799
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names799[rand() % names799.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog799 : Animal799
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation799 : Dog799
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList799<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff799()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog799 [5] {
				if i % 2 == 1   { it = alloc Dalmation799 }
				else            { it = alloc Dog799 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList799<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff799()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 799 done\n\n")
		}
	}
	

	let names800 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal800
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names800[rand() % names800.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog800 : Animal800
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation800 : Dog800
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList800<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff800()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog800 [5] {
				if i % 2 == 1   { it = alloc Dalmation800 }
				else            { it = alloc Dog800 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList800<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff800()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 800 done\n\n")
		}
	}
	

	let names801 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal801
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names801[rand() % names801.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog801 : Animal801
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation801 : Dog801
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList801<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff801()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog801 [5] {
				if i % 2 == 1   { it = alloc Dalmation801 }
				else            { it = alloc Dog801 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList801<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff801()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 801 done\n\n")
		}
	}
	

	let names802 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal802
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names802[rand() % names802.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog802 : Animal802
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation802 : Dog802
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList802<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff802()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog802 [5] {
				if i % 2 == 1   { it = alloc Dalmation802 }
				else            { it = alloc Dog802 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList802<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff802()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 802 done\n\n")
		}
	}
	

	let names803 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal803
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names803[rand() % names803.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog803 : Animal803
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation803 : Dog803
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList803<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff803()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog803 [5] {
				if i % 2 == 1   { it = alloc Dalmation803 }
				else            { it = alloc Dog803 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList803<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff803()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 803 done\n\n")
		}
	}
	

	let names804 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal804
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names804[rand() % names804.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog804 : Animal804
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation804 : Dog804
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList804<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff804()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog804 [5] {
				if i % 2 == 1   { it = alloc Dalmation804 }
				else            { it = alloc Dog804 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList804<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff804()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 804 done\n\n")
		}
	}
	

	let names805 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal805
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names805[rand() % names805.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog805 : Animal805
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation805 : Dog805
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList805<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff805()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog805 [5] {
				if i % 2 == 1   { it = alloc Dalmation805 }
				else            { it = alloc Dog805 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList805<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff805()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 805 done\n\n")
		}
	}
	

	let names806 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal806
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names806[rand() % names806.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog806 : Animal806
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation806 : Dog806
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList806<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff806()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog806 [5] {
				if i % 2 == 1   { it = alloc Dalmation806 }
				else            { it = alloc Dog806 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList806<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff806()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 806 done\n\n")
		}
	}
	

	let names807 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal807
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names807[rand() % names807.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog807 : Animal807
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation807 : Dog807
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList807<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff807()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog807 [5] {
				if i % 2 == 1   { it = alloc Dalmation807 }
				else            { it = alloc Dog807 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList807<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff807()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 807 done\n\n")
		}
	}
	

	let names808 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal808
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names808[rand() % names808.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog808 : Animal808
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation808 : Dog808
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList808<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff808()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog808 [5] {
				if i % 2 == 1   { it = alloc Dalmation808 }
				else            { it = alloc Dog808 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList808<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff808()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 808 done\n\n")
		}
	}
	

	let names809 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal809
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names809[rand() % names809.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog809 : Animal809
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation809 : Dog809
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList809<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff809()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog809 [5] {
				if i % 2 == 1   { it = alloc Dalmation809 }
				else            { it = alloc Dog809 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList809<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff809()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 809 done\n\n")
		}
	}
	

	let names810 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal810
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names810[rand() % names810.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog810 : Animal810
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation810 : Dog810
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList810<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff810()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog810 [5] {
				if i % 2 == 1   { it = alloc Dalmation810 }
				else            { it = alloc Dog810 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList810<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff810()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 810 done\n\n")
		}
	}
	

	let names811 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal811
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names811[rand() % names811.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog811 : Animal811
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation811 : Dog811
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList811<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff811()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog811 [5] {
				if i % 2 == 1   { it = alloc Dalmation811 }
				else            { it = alloc Dog811 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList811<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff811()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 811 done\n\n")
		}
	}
	

	let names812 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal812
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names812[rand() % names812.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog812 : Animal812
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation812 : Dog812
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList812<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff812()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog812 [5] {
				if i % 2 == 1   { it = alloc Dalmation812 }
				else            { it = alloc Dog812 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList812<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff812()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 812 done\n\n")
		}
	}
	

	let names813 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal813
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names813[rand() % names813.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog813 : Animal813
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation813 : Dog813
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList813<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff813()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog813 [5] {
				if i % 2 == 1   { it = alloc Dalmation813 }
				else            { it = alloc Dog813 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList813<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff813()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 813 done\n\n")
		}
	}
	

	let names814 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal814
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names814[rand() % names814.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog814 : Animal814
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation814 : Dog814
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList814<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff814()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog814 [5] {
				if i % 2 == 1   { it = alloc Dalmation814 }
				else            { it = alloc Dog814 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList814<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff814()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 814 done\n\n")
		}
	}
	

	let names815 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal815
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names815[rand() % names815.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog815 : Animal815
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation815 : Dog815
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList815<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff815()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog815 [5] {
				if i % 2 == 1   { it = alloc Dalmation815 }
				else            { it = alloc Dog815 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList815<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff815()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 815 done\n\n")
		}
	}
	

	let names816 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal816
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names816[rand() % names816.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog816 : Animal816
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation816 : Dog816
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList816<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff816()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog816 [5] {
				if i % 2 == 1   { it = alloc Dalmation816 }
				else            { it = alloc Dog816 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList816<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff816()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 816 done\n\n")
		}
	}
	

	let names817 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal817
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names817[rand() % names817.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog817 : Animal817
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation817 : Dog817
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList817<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff817()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog817 [5] {
				if i % 2 == 1   { it = alloc Dalmation817 }
				else            { it = alloc Dog817 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList817<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff817()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 817 done\n\n")
		}
	}
	

	let names818 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal818
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names818[rand() % names818.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog818 : Animal818
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation818 : Dog818
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList818<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff818()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog818 [5] {
				if i % 2 == 1   { it = alloc Dalmation818 }
				else            { it = alloc Dog818 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList818<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff818()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 818 done\n\n")
		}
	}
	

	let names819 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal819
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names819[rand() % names819.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog819 : Animal819
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation819 : Dog819
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList819<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff819()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog819 [5] {
				if i % 2 == 1   { it = alloc Dalmation819 }
				else            { it = alloc Dog819 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList819<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff819()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 819 done\n\n")
		}
	}
	

	let names820 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal820
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names820[rand() % names820.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog820 : Animal820
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation820 : Dog820
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList820<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff820()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog820 [5] {
				if i % 2 == 1   { it = alloc Dalmation820 }
				else            { it = alloc Dog820 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList820<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff820()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 820 done\n\n")
		}
	}
	

	let names821 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal821
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names821[rand() % names821.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog821 : Animal821
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation821 : Dog821
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList821<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff821()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog821 [5] {
				if i % 2 == 1   { it = alloc Dalmation821 }
				else            { it = alloc Dog821 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList821<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff821()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 821 done\n\n")
		}
	}
	

	let names822 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal822
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names822[rand() % names822.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog822 : Animal822
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation822 : Dog822
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList822<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff822()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog822 [5] {
				if i % 2 == 1   { it = alloc Dalmation822 }
				else            { it = alloc Dog822 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList822<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff822()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 822 done\n\n")
		}
	}
	

	let names823 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal823
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names823[rand() % names823.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog823 : Animal823
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation823 : Dog823
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList823<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff823()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog823 [5] {
				if i % 2 == 1   { it = alloc Dalmation823 }
				else            { it = alloc Dog823 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList823<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff823()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 823 done\n\n")
		}
	}
	

	let names824 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal824
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names824[rand() % names824.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog824 : Animal824
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation824 : Dog824
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList824<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff824()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog824 [5] {
				if i % 2 == 1   { it = alloc Dalmation824 }
				else            { it = alloc Dog824 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList824<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff824()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 824 done\n\n")
		}
	}
	

	let names825 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal825
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names825[rand() % names825.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog825 : Animal825
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation825 : Dog825
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList825<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff825()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog825 [5] {
				if i % 2 == 1   { it = alloc Dalmation825 }
				else            { it = alloc Dog825 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList825<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff825()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 825 done\n\n")
		}
	}
	

	let names826 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal826
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names826[rand() % names826.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog826 : Animal826
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation826 : Dog826
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList826<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff826()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog826 [5] {
				if i % 2 == 1   { it = alloc Dalmation826 }
				else            { it = alloc Dog826 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList826<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff826()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 826 done\n\n")
		}
	}
	

	let names827 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal827
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names827[rand() % names827.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog827 : Animal827
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation827 : Dog827
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList827<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff827()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog827 [5] {
				if i % 2 == 1   { it = alloc Dalmation827 }
				else            { it = alloc Dog827 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList827<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff827()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 827 done\n\n")
		}
	}
	

	let names828 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal828
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names828[rand() % names828.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog828 : Animal828
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation828 : Dog828
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList828<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff828()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog828 [5] {
				if i % 2 == 1   { it = alloc Dalmation828 }
				else            { it = alloc Dog828 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList828<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff828()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 828 done\n\n")
		}
	}
	

	let names829 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal829
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names829[rand() % names829.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog829 : Animal829
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation829 : Dog829
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList829<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff829()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog829 [5] {
				if i % 2 == 1   { it = alloc Dalmation829 }
				else            { it = alloc Dog829 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList829<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff829()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 829 done\n\n")
		}
	}
	

	let names830 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal830
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names830[rand() % names830.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog830 : Animal830
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation830 : Dog830
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList830<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff830()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog830 [5] {
				if i % 2 == 1   { it = alloc Dalmation830 }
				else            { it = alloc Dog830 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList830<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff830()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 830 done\n\n")
		}
	}
	

	let names831 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal831
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names831[rand() % names831.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog831 : Animal831
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation831 : Dog831
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList831<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff831()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog831 [5] {
				if i % 2 == 1   { it = alloc Dalmation831 }
				else            { it = alloc Dog831 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList831<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff831()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 831 done\n\n")
		}
	}
	

	let names832 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal832
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names832[rand() % names832.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog832 : Animal832
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation832 : Dog832
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList832<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff832()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog832 [5] {
				if i % 2 == 1   { it = alloc Dalmation832 }
				else            { it = alloc Dog832 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList832<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff832()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 832 done\n\n")
		}
	}
	

	let names833 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal833
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names833[rand() % names833.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog833 : Animal833
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation833 : Dog833
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList833<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff833()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog833 [5] {
				if i % 2 == 1   { it = alloc Dalmation833 }
				else            { it = alloc Dog833 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList833<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff833()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 833 done\n\n")
		}
	}
	

	let names834 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal834
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names834[rand() % names834.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog834 : Animal834
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation834 : Dog834
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList834<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff834()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog834 [5] {
				if i % 2 == 1   { it = alloc Dalmation834 }
				else            { it = alloc Dog834 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList834<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff834()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 834 done\n\n")
		}
	}
	

	let names835 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal835
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names835[rand() % names835.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog835 : Animal835
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation835 : Dog835
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList835<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff835()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog835 [5] {
				if i % 2 == 1   { it = alloc Dalmation835 }
				else            { it = alloc Dog835 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList835<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff835()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 835 done\n\n")
		}
	}
	

	let names836 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal836
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names836[rand() % names836.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog836 : Animal836
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation836 : Dog836
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList836<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff836()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog836 [5] {
				if i % 2 == 1   { it = alloc Dalmation836 }
				else            { it = alloc Dog836 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList836<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff836()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 836 done\n\n")
		}
	}
	

	let names837 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal837
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names837[rand() % names837.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog837 : Animal837
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation837 : Dog837
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList837<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff837()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog837 [5] {
				if i % 2 == 1   { it = alloc Dalmation837 }
				else            { it = alloc Dog837 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList837<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff837()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 837 done\n\n")
		}
	}
	

	let names838 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal838
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names838[rand() % names838.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog838 : Animal838
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation838 : Dog838
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList838<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff838()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog838 [5] {
				if i % 2 == 1   { it = alloc Dalmation838 }
				else            { it = alloc Dog838 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList838<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff838()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 838 done\n\n")
		}
	}
	

	let names839 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal839
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names839[rand() % names839.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog839 : Animal839
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation839 : Dog839
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList839<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff839()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog839 [5] {
				if i % 2 == 1   { it = alloc Dalmation839 }
				else            { it = alloc Dog839 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList839<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff839()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 839 done\n\n")
		}
	}
	

	let names840 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal840
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names840[rand() % names840.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog840 : Animal840
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation840 : Dog840
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList840<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff840()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog840 [5] {
				if i % 2 == 1   { it = alloc Dalmation840 }
				else            { it = alloc Dog840 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList840<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff840()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 840 done\n\n")
		}
	}
	

	let names841 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal841
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names841[rand() % names841.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog841 : Animal841
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation841 : Dog841
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList841<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff841()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog841 [5] {
				if i % 2 == 1   { it = alloc Dalmation841 }
				else            { it = alloc Dog841 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList841<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff841()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 841 done\n\n")
		}
	}
	

	let names842 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal842
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names842[rand() % names842.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog842 : Animal842
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation842 : Dog842
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList842<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff842()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog842 [5] {
				if i % 2 == 1   { it = alloc Dalmation842 }
				else            { it = alloc Dog842 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList842<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff842()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 842 done\n\n")
		}
	}
	

	let names843 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal843
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names843[rand() % names843.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog843 : Animal843
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation843 : Dog843
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList843<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff843()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog843 [5] {
				if i % 2 == 1   { it = alloc Dalmation843 }
				else            { it = alloc Dog843 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList843<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff843()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 843 done\n\n")
		}
	}
	

	let names844 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal844
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names844[rand() % names844.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog844 : Animal844
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation844 : Dog844
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList844<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff844()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog844 [5] {
				if i % 2 == 1   { it = alloc Dalmation844 }
				else            { it = alloc Dog844 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList844<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff844()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 844 done\n\n")
		}
	}
	

	let names845 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal845
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names845[rand() % names845.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog845 : Animal845
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation845 : Dog845
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList845<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff845()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog845 [5] {
				if i % 2 == 1   { it = alloc Dalmation845 }
				else            { it = alloc Dog845 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList845<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff845()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 845 done\n\n")
		}
	}
	

	let names846 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal846
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names846[rand() % names846.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog846 : Animal846
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation846 : Dog846
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList846<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff846()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog846 [5] {
				if i % 2 == 1   { it = alloc Dalmation846 }
				else            { it = alloc Dog846 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList846<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff846()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 846 done\n\n")
		}
	}
	

	let names847 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal847
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names847[rand() % names847.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog847 : Animal847
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation847 : Dog847
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList847<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff847()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog847 [5] {
				if i % 2 == 1   { it = alloc Dalmation847 }
				else            { it = alloc Dog847 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList847<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff847()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 847 done\n\n")
		}
	}
	

	let names848 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal848
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names848[rand() % names848.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog848 : Animal848
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation848 : Dog848
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList848<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff848()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog848 [5] {
				if i % 2 == 1   { it = alloc Dalmation848 }
				else            { it = alloc Dog848 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList848<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff848()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 848 done\n\n")
		}
	}
	

	let names849 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal849
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names849[rand() % names849.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog849 : Animal849
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation849 : Dog849
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList849<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff849()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog849 [5] {
				if i % 2 == 1   { it = alloc Dalmation849 }
				else            { it = alloc Dog849 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList849<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff849()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 849 done\n\n")
		}
	}
	

	let names850 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal850
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names850[rand() % names850.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog850 : Animal850
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation850 : Dog850
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList850<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff850()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog850 [5] {
				if i % 2 == 1   { it = alloc Dalmation850 }
				else            { it = alloc Dog850 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList850<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff850()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 850 done\n\n")
		}
	}
	

	let names851 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal851
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names851[rand() % names851.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog851 : Animal851
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation851 : Dog851
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList851<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff851()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog851 [5] {
				if i % 2 == 1   { it = alloc Dalmation851 }
				else            { it = alloc Dog851 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList851<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff851()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 851 done\n\n")
		}
	}
	

	let names852 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal852
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names852[rand() % names852.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog852 : Animal852
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation852 : Dog852
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList852<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff852()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog852 [5] {
				if i % 2 == 1   { it = alloc Dalmation852 }
				else            { it = alloc Dog852 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList852<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff852()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 852 done\n\n")
		}
	}
	

	let names853 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal853
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names853[rand() % names853.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog853 : Animal853
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation853 : Dog853
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList853<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff853()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog853 [5] {
				if i % 2 == 1   { it = alloc Dalmation853 }
				else            { it = alloc Dog853 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList853<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff853()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 853 done\n\n")
		}
	}
	

	let names854 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal854
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names854[rand() % names854.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog854 : Animal854
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation854 : Dog854
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList854<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff854()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog854 [5] {
				if i % 2 == 1   { it = alloc Dalmation854 }
				else            { it = alloc Dog854 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList854<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff854()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 854 done\n\n")
		}
	}
	

	let names855 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal855
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names855[rand() % names855.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog855 : Animal855
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation855 : Dog855
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList855<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff855()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog855 [5] {
				if i % 2 == 1   { it = alloc Dalmation855 }
				else            { it = alloc Dog855 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList855<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff855()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 855 done\n\n")
		}
	}
	

	let names856 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal856
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names856[rand() % names856.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog856 : Animal856
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation856 : Dog856
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList856<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff856()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog856 [5] {
				if i % 2 == 1   { it = alloc Dalmation856 }
				else            { it = alloc Dog856 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList856<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff856()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 856 done\n\n")
		}
	}
	

	let names857 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal857
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names857[rand() % names857.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog857 : Animal857
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation857 : Dog857
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList857<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff857()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog857 [5] {
				if i % 2 == 1   { it = alloc Dalmation857 }
				else            { it = alloc Dog857 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList857<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff857()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 857 done\n\n")
		}
	}
	

	let names858 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal858
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names858[rand() % names858.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog858 : Animal858
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation858 : Dog858
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList858<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff858()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog858 [5] {
				if i % 2 == 1   { it = alloc Dalmation858 }
				else            { it = alloc Dog858 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList858<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff858()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 858 done\n\n")
		}
	}
	

	let names859 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal859
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names859[rand() % names859.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog859 : Animal859
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation859 : Dog859
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList859<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff859()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog859 [5] {
				if i % 2 == 1   { it = alloc Dalmation859 }
				else            { it = alloc Dog859 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList859<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff859()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 859 done\n\n")
		}
	}
	

	let names860 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal860
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names860[rand() % names860.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog860 : Animal860
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation860 : Dog860
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList860<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff860()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog860 [5] {
				if i % 2 == 1   { it = alloc Dalmation860 }
				else            { it = alloc Dog860 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList860<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff860()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 860 done\n\n")
		}
	}
	

	let names861 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal861
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names861[rand() % names861.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog861 : Animal861
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation861 : Dog861
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList861<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff861()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog861 [5] {
				if i % 2 == 1   { it = alloc Dalmation861 }
				else            { it = alloc Dog861 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList861<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff861()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 861 done\n\n")
		}
	}
	

	let names862 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal862
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names862[rand() % names862.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog862 : Animal862
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation862 : Dog862
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList862<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff862()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog862 [5] {
				if i % 2 == 1   { it = alloc Dalmation862 }
				else            { it = alloc Dog862 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList862<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff862()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 862 done\n\n")
		}
	}
	

	let names863 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal863
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names863[rand() % names863.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog863 : Animal863
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation863 : Dog863
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList863<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff863()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog863 [5] {
				if i % 2 == 1   { it = alloc Dalmation863 }
				else            { it = alloc Dog863 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList863<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff863()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 863 done\n\n")
		}
	}
	

	let names864 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal864
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names864[rand() % names864.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog864 : Animal864
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation864 : Dog864
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList864<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff864()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog864 [5] {
				if i % 2 == 1   { it = alloc Dalmation864 }
				else            { it = alloc Dog864 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList864<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff864()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 864 done\n\n")
		}
	}
	

	let names865 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal865
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names865[rand() % names865.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog865 : Animal865
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation865 : Dog865
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList865<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff865()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog865 [5] {
				if i % 2 == 1   { it = alloc Dalmation865 }
				else            { it = alloc Dog865 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList865<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff865()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 865 done\n\n")
		}
	}
	

	let names866 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal866
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names866[rand() % names866.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog866 : Animal866
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation866 : Dog866
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList866<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff866()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog866 [5] {
				if i % 2 == 1   { it = alloc Dalmation866 }
				else            { it = alloc Dog866 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList866<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff866()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 866 done\n\n")
		}
	}
	

	let names867 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal867
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names867[rand() % names867.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog867 : Animal867
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation867 : Dog867
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList867<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff867()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog867 [5] {
				if i % 2 == 1   { it = alloc Dalmation867 }
				else            { it = alloc Dog867 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList867<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff867()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 867 done\n\n")
		}
	}
	

	let names868 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal868
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names868[rand() % names868.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog868 : Animal868
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation868 : Dog868
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList868<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff868()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog868 [5] {
				if i % 2 == 1   { it = alloc Dalmation868 }
				else            { it = alloc Dog868 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList868<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff868()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 868 done\n\n")
		}
	}
	

	let names869 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal869
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names869[rand() % names869.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog869 : Animal869
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation869 : Dog869
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList869<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff869()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog869 [5] {
				if i % 2 == 1   { it = alloc Dalmation869 }
				else            { it = alloc Dog869 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList869<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff869()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 869 done\n\n")
		}
	}
	

	let names870 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal870
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names870[rand() % names870.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog870 : Animal870
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation870 : Dog870
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList870<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff870()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog870 [5] {
				if i % 2 == 1   { it = alloc Dalmation870 }
				else            { it = alloc Dog870 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList870<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff870()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 870 done\n\n")
		}
	}
	

	let names871 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal871
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names871[rand() % names871.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog871 : Animal871
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation871 : Dog871
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList871<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff871()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog871 [5] {
				if i % 2 == 1   { it = alloc Dalmation871 }
				else            { it = alloc Dog871 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList871<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff871()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 871 done\n\n")
		}
	}
	

	let names872 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal872
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names872[rand() % names872.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog872 : Animal872
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation872 : Dog872
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList872<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff872()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog872 [5] {
				if i % 2 == 1   { it = alloc Dalmation872 }
				else            { it = alloc Dog872 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList872<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff872()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 872 done\n\n")
		}
	}
	

	let names873 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal873
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names873[rand() % names873.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog873 : Animal873
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation873 : Dog873
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList873<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff873()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog873 [5] {
				if i % 2 == 1   { it = alloc Dalmation873 }
				else            { it = alloc Dog873 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList873<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff873()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 873 done\n\n")
		}
	}
	

	let names874 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal874
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names874[rand() % names874.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog874 : Animal874
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation874 : Dog874
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList874<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff874()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog874 [5] {
				if i % 2 == 1   { it = alloc Dalmation874 }
				else            { it = alloc Dog874 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList874<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff874()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 874 done\n\n")
		}
	}
	

	let names875 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal875
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names875[rand() % names875.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog875 : Animal875
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation875 : Dog875
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList875<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff875()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog875 [5] {
				if i % 2 == 1   { it = alloc Dalmation875 }
				else            { it = alloc Dog875 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList875<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff875()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 875 done\n\n")
		}
	}
	

	let names876 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal876
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names876[rand() % names876.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog876 : Animal876
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation876 : Dog876
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList876<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff876()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog876 [5] {
				if i % 2 == 1   { it = alloc Dalmation876 }
				else            { it = alloc Dog876 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList876<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff876()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 876 done\n\n")
		}
	}
	

	let names877 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal877
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names877[rand() % names877.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog877 : Animal877
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation877 : Dog877
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList877<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff877()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog877 [5] {
				if i % 2 == 1   { it = alloc Dalmation877 }
				else            { it = alloc Dog877 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList877<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff877()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 877 done\n\n")
		}
	}
	

	let names878 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal878
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names878[rand() % names878.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog878 : Animal878
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation878 : Dog878
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList878<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff878()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog878 [5] {
				if i % 2 == 1   { it = alloc Dalmation878 }
				else            { it = alloc Dog878 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList878<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff878()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 878 done\n\n")
		}
	}
	

	let names879 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal879
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names879[rand() % names879.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog879 : Animal879
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation879 : Dog879
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList879<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff879()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog879 [5] {
				if i % 2 == 1   { it = alloc Dalmation879 }
				else            { it = alloc Dog879 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList879<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff879()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 879 done\n\n")
		}
	}
	

	let names880 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal880
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names880[rand() % names880.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog880 : Animal880
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation880 : Dog880
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList880<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff880()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog880 [5] {
				if i % 2 == 1   { it = alloc Dalmation880 }
				else            { it = alloc Dog880 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList880<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff880()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 880 done\n\n")
		}
	}
	

	let names881 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal881
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names881[rand() % names881.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog881 : Animal881
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation881 : Dog881
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList881<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff881()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog881 [5] {
				if i % 2 == 1   { it = alloc Dalmation881 }
				else            { it = alloc Dog881 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList881<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff881()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 881 done\n\n")
		}
	}
	

	let names882 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal882
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names882[rand() % names882.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog882 : Animal882
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation882 : Dog882
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList882<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff882()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog882 [5] {
				if i % 2 == 1   { it = alloc Dalmation882 }
				else            { it = alloc Dog882 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList882<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff882()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 882 done\n\n")
		}
	}
	

	let names883 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal883
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names883[rand() % names883.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog883 : Animal883
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation883 : Dog883
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList883<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff883()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog883 [5] {
				if i % 2 == 1   { it = alloc Dalmation883 }
				else            { it = alloc Dog883 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList883<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff883()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 883 done\n\n")
		}
	}
	

	let names884 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal884
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names884[rand() % names884.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog884 : Animal884
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation884 : Dog884
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList884<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff884()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog884 [5] {
				if i % 2 == 1   { it = alloc Dalmation884 }
				else            { it = alloc Dog884 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList884<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff884()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 884 done\n\n")
		}
	}
	

	let names885 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal885
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names885[rand() % names885.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog885 : Animal885
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation885 : Dog885
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList885<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff885()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog885 [5] {
				if i % 2 == 1   { it = alloc Dalmation885 }
				else            { it = alloc Dog885 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList885<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff885()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 885 done\n\n")
		}
	}
	

	let names886 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal886
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names886[rand() % names886.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog886 : Animal886
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation886 : Dog886
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList886<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff886()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog886 [5] {
				if i % 2 == 1   { it = alloc Dalmation886 }
				else            { it = alloc Dog886 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList886<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff886()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 886 done\n\n")
		}
	}
	

	let names887 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal887
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names887[rand() % names887.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog887 : Animal887
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation887 : Dog887
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList887<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff887()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog887 [5] {
				if i % 2 == 1   { it = alloc Dalmation887 }
				else            { it = alloc Dog887 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList887<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff887()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 887 done\n\n")
		}
	}
	

	let names888 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal888
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names888[rand() % names888.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog888 : Animal888
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation888 : Dog888
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList888<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff888()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog888 [5] {
				if i % 2 == 1   { it = alloc Dalmation888 }
				else            { it = alloc Dog888 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList888<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff888()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 888 done\n\n")
		}
	}
	

	let names889 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal889
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names889[rand() % names889.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog889 : Animal889
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation889 : Dog889
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList889<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff889()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog889 [5] {
				if i % 2 == 1   { it = alloc Dalmation889 }
				else            { it = alloc Dog889 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList889<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff889()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 889 done\n\n")
		}
	}
	

	let names890 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal890
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names890[rand() % names890.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog890 : Animal890
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation890 : Dog890
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList890<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff890()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog890 [5] {
				if i % 2 == 1   { it = alloc Dalmation890 }
				else            { it = alloc Dog890 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList890<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff890()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 890 done\n\n")
		}
	}
	

	let names891 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal891
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names891[rand() % names891.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog891 : Animal891
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation891 : Dog891
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList891<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff891()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog891 [5] {
				if i % 2 == 1   { it = alloc Dalmation891 }
				else            { it = alloc Dog891 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList891<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff891()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 891 done\n\n")
		}
	}
	

	let names892 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal892
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names892[rand() % names892.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog892 : Animal892
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation892 : Dog892
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList892<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff892()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog892 [5] {
				if i % 2 == 1   { it = alloc Dalmation892 }
				else            { it = alloc Dog892 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList892<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff892()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 892 done\n\n")
		}
	}
	

	let names893 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal893
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names893[rand() % names893.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog893 : Animal893
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation893 : Dog893
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList893<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff893()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog893 [5] {
				if i % 2 == 1   { it = alloc Dalmation893 }
				else            { it = alloc Dog893 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList893<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff893()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 893 done\n\n")
		}
	}
	

	let names894 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal894
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names894[rand() % names894.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog894 : Animal894
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation894 : Dog894
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList894<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff894()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog894 [5] {
				if i % 2 == 1   { it = alloc Dalmation894 }
				else            { it = alloc Dog894 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList894<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff894()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 894 done\n\n")
		}
	}
	

	let names895 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal895
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names895[rand() % names895.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog895 : Animal895
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation895 : Dog895
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList895<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff895()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog895 [5] {
				if i % 2 == 1   { it = alloc Dalmation895 }
				else            { it = alloc Dog895 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList895<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff895()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 895 done\n\n")
		}
	}
	

	let names896 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal896
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names896[rand() % names896.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog896 : Animal896
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation896 : Dog896
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList896<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff896()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog896 [5] {
				if i % 2 == 1   { it = alloc Dalmation896 }
				else            { it = alloc Dog896 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList896<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff896()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 896 done\n\n")
		}
	}
	

	let names897 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal897
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names897[rand() % names897.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog897 : Animal897
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation897 : Dog897
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList897<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff897()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog897 [5] {
				if i % 2 == 1   { it = alloc Dalmation897 }
				else            { it = alloc Dog897 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList897<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff897()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 897 done\n\n")
		}
	}
	

	let names898 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal898
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names898[rand() % names898.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog898 : Animal898
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation898 : Dog898
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList898<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff898()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog898 [5] {
				if i % 2 == 1   { it = alloc Dalmation898 }
				else            { it = alloc Dog898 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList898<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff898()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 898 done\n\n")
		}
	}
	

	let names899 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal899
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names899[rand() % names899.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog899 : Animal899
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation899 : Dog899
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList899<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff899()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog899 [5] {
				if i % 2 == 1   { it = alloc Dalmation899 }
				else            { it = alloc Dog899 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList899<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff899()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 899 done\n\n")
		}
	}
	

	let names900 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal900
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names900[rand() % names900.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog900 : Animal900
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation900 : Dog900
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList900<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff900()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog900 [5] {
				if i % 2 == 1   { it = alloc Dalmation900 }
				else            { it = alloc Dog900 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList900<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff900()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 900 done\n\n")
		}
	}
	

	let names901 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal901
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names901[rand() % names901.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog901 : Animal901
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation901 : Dog901
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList901<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff901()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog901 [5] {
				if i % 2 == 1   { it = alloc Dalmation901 }
				else            { it = alloc Dog901 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList901<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff901()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 901 done\n\n")
		}
	}
	

	let names902 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal902
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names902[rand() % names902.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog902 : Animal902
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation902 : Dog902
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList902<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff902()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog902 [5] {
				if i % 2 == 1   { it = alloc Dalmation902 }
				else            { it = alloc Dog902 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList902<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff902()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 902 done\n\n")
		}
	}
	

	let names903 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal903
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names903[rand() % names903.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog903 : Animal903
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation903 : Dog903
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList903<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff903()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog903 [5] {
				if i % 2 == 1   { it = alloc Dalmation903 }
				else            { it = alloc Dog903 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList903<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff903()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 903 done\n\n")
		}
	}
	

	let names904 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal904
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names904[rand() % names904.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog904 : Animal904
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation904 : Dog904
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList904<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff904()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog904 [5] {
				if i % 2 == 1   { it = alloc Dalmation904 }
				else            { it = alloc Dog904 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList904<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff904()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 904 done\n\n")
		}
	}
	

	let names905 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal905
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names905[rand() % names905.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog905 : Animal905
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation905 : Dog905
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList905<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff905()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog905 [5] {
				if i % 2 == 1   { it = alloc Dalmation905 }
				else            { it = alloc Dog905 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList905<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff905()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 905 done\n\n")
		}
	}
	

	let names906 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal906
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names906[rand() % names906.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog906 : Animal906
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation906 : Dog906
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList906<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff906()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog906 [5] {
				if i % 2 == 1   { it = alloc Dalmation906 }
				else            { it = alloc Dog906 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList906<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff906()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 906 done\n\n")
		}
	}
	

	let names907 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal907
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names907[rand() % names907.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog907 : Animal907
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation907 : Dog907
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList907<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff907()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog907 [5] {
				if i % 2 == 1   { it = alloc Dalmation907 }
				else            { it = alloc Dog907 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList907<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff907()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 907 done\n\n")
		}
	}
	

	let names908 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal908
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names908[rand() % names908.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog908 : Animal908
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation908 : Dog908
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList908<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff908()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog908 [5] {
				if i % 2 == 1   { it = alloc Dalmation908 }
				else            { it = alloc Dog908 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList908<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff908()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 908 done\n\n")
		}
	}
	

	let names909 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal909
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names909[rand() % names909.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog909 : Animal909
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation909 : Dog909
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList909<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff909()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog909 [5] {
				if i % 2 == 1   { it = alloc Dalmation909 }
				else            { it = alloc Dog909 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList909<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff909()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 909 done\n\n")
		}
	}
	

	let names910 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal910
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names910[rand() % names910.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog910 : Animal910
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation910 : Dog910
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList910<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff910()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog910 [5] {
				if i % 2 == 1   { it = alloc Dalmation910 }
				else            { it = alloc Dog910 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList910<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff910()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 910 done\n\n")
		}
	}
	

	let names911 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal911
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names911[rand() % names911.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog911 : Animal911
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation911 : Dog911
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList911<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff911()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog911 [5] {
				if i % 2 == 1   { it = alloc Dalmation911 }
				else            { it = alloc Dog911 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList911<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff911()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 911 done\n\n")
		}
	}
	

	let names912 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal912
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names912[rand() % names912.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog912 : Animal912
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation912 : Dog912
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList912<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff912()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog912 [5] {
				if i % 2 == 1   { it = alloc Dalmation912 }
				else            { it = alloc Dog912 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList912<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff912()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 912 done\n\n")
		}
	}
	

	let names913 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal913
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names913[rand() % names913.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog913 : Animal913
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation913 : Dog913
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList913<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff913()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog913 [5] {
				if i % 2 == 1   { it = alloc Dalmation913 }
				else            { it = alloc Dog913 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList913<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff913()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 913 done\n\n")
		}
	}
	

	let names914 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal914
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names914[rand() % names914.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog914 : Animal914
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation914 : Dog914
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList914<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff914()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog914 [5] {
				if i % 2 == 1   { it = alloc Dalmation914 }
				else            { it = alloc Dog914 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList914<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff914()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 914 done\n\n")
		}
	}
	

	let names915 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal915
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names915[rand() % names915.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog915 : Animal915
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation915 : Dog915
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList915<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff915()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog915 [5] {
				if i % 2 == 1   { it = alloc Dalmation915 }
				else            { it = alloc Dog915 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList915<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff915()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 915 done\n\n")
		}
	}
	

	let names916 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal916
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names916[rand() % names916.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog916 : Animal916
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation916 : Dog916
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList916<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff916()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog916 [5] {
				if i % 2 == 1   { it = alloc Dalmation916 }
				else            { it = alloc Dog916 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList916<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff916()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 916 done\n\n")
		}
	}
	

	let names917 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal917
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names917[rand() % names917.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog917 : Animal917
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation917 : Dog917
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList917<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff917()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog917 [5] {
				if i % 2 == 1   { it = alloc Dalmation917 }
				else            { it = alloc Dog917 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList917<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff917()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 917 done\n\n")
		}
	}
	

	let names918 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal918
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names918[rand() % names918.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog918 : Animal918
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation918 : Dog918
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList918<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff918()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog918 [5] {
				if i % 2 == 1   { it = alloc Dalmation918 }
				else            { it = alloc Dog918 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList918<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff918()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 918 done\n\n")
		}
	}
	

	let names919 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal919
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names919[rand() % names919.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog919 : Animal919
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation919 : Dog919
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList919<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff919()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog919 [5] {
				if i % 2 == 1   { it = alloc Dalmation919 }
				else            { it = alloc Dog919 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList919<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff919()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 919 done\n\n")
		}
	}
	

	let names920 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal920
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names920[rand() % names920.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog920 : Animal920
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation920 : Dog920
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList920<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff920()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog920 [5] {
				if i % 2 == 1   { it = alloc Dalmation920 }
				else            { it = alloc Dog920 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList920<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff920()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 920 done\n\n")
		}
	}
	

	let names921 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal921
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names921[rand() % names921.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog921 : Animal921
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation921 : Dog921
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList921<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff921()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog921 [5] {
				if i % 2 == 1   { it = alloc Dalmation921 }
				else            { it = alloc Dog921 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList921<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff921()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 921 done\n\n")
		}
	}
	

	let names922 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal922
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names922[rand() % names922.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog922 : Animal922
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation922 : Dog922
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList922<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff922()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog922 [5] {
				if i % 2 == 1   { it = alloc Dalmation922 }
				else            { it = alloc Dog922 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList922<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff922()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 922 done\n\n")
		}
	}
	

	let names923 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal923
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names923[rand() % names923.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog923 : Animal923
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation923 : Dog923
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList923<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff923()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog923 [5] {
				if i % 2 == 1   { it = alloc Dalmation923 }
				else            { it = alloc Dog923 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList923<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff923()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 923 done\n\n")
		}
	}
	

	let names924 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal924
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names924[rand() % names924.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog924 : Animal924
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation924 : Dog924
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList924<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff924()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog924 [5] {
				if i % 2 == 1   { it = alloc Dalmation924 }
				else            { it = alloc Dog924 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList924<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff924()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 924 done\n\n")
		}
	}
	

	let names925 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal925
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names925[rand() % names925.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog925 : Animal925
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation925 : Dog925
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList925<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff925()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog925 [5] {
				if i % 2 == 1   { it = alloc Dalmation925 }
				else            { it = alloc Dog925 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList925<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff925()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 925 done\n\n")
		}
	}
	

	let names926 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal926
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names926[rand() % names926.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog926 : Animal926
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation926 : Dog926
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList926<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff926()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog926 [5] {
				if i % 2 == 1   { it = alloc Dalmation926 }
				else            { it = alloc Dog926 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList926<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff926()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 926 done\n\n")
		}
	}
	

	let names927 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal927
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names927[rand() % names927.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog927 : Animal927
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation927 : Dog927
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList927<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff927()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog927 [5] {
				if i % 2 == 1   { it = alloc Dalmation927 }
				else            { it = alloc Dog927 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList927<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff927()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 927 done\n\n")
		}
	}
	

	let names928 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal928
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names928[rand() % names928.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog928 : Animal928
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation928 : Dog928
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList928<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff928()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog928 [5] {
				if i % 2 == 1   { it = alloc Dalmation928 }
				else            { it = alloc Dog928 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList928<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff928()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 928 done\n\n")
		}
	}
	

	let names929 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal929
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names929[rand() % names929.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog929 : Animal929
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation929 : Dog929
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList929<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff929()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog929 [5] {
				if i % 2 == 1   { it = alloc Dalmation929 }
				else            { it = alloc Dog929 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList929<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff929()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 929 done\n\n")
		}
	}
	

	let names930 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal930
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names930[rand() % names930.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog930 : Animal930
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation930 : Dog930
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList930<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff930()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog930 [5] {
				if i % 2 == 1   { it = alloc Dalmation930 }
				else            { it = alloc Dog930 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList930<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff930()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 930 done\n\n")
		}
	}
	

	let names931 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal931
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names931[rand() % names931.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog931 : Animal931
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation931 : Dog931
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList931<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff931()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog931 [5] {
				if i % 2 == 1   { it = alloc Dalmation931 }
				else            { it = alloc Dog931 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList931<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff931()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 931 done\n\n")
		}
	}
	

	let names932 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal932
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names932[rand() % names932.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog932 : Animal932
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation932 : Dog932
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList932<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff932()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog932 [5] {
				if i % 2 == 1   { it = alloc Dalmation932 }
				else            { it = alloc Dog932 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList932<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff932()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 932 done\n\n")
		}
	}
	

	let names933 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal933
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names933[rand() % names933.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog933 : Animal933
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation933 : Dog933
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList933<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff933()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog933 [5] {
				if i % 2 == 1   { it = alloc Dalmation933 }
				else            { it = alloc Dog933 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList933<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff933()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 933 done\n\n")
		}
	}
	

	let names934 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal934
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names934[rand() % names934.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog934 : Animal934
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation934 : Dog934
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList934<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff934()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog934 [5] {
				if i % 2 == 1   { it = alloc Dalmation934 }
				else            { it = alloc Dog934 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList934<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff934()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 934 done\n\n")
		}
	}
	

	let names935 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal935
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names935[rand() % names935.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog935 : Animal935
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation935 : Dog935
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList935<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff935()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog935 [5] {
				if i % 2 == 1   { it = alloc Dalmation935 }
				else            { it = alloc Dog935 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList935<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff935()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 935 done\n\n")
		}
	}
	

	let names936 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal936
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names936[rand() % names936.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog936 : Animal936
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation936 : Dog936
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList936<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff936()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog936 [5] {
				if i % 2 == 1   { it = alloc Dalmation936 }
				else            { it = alloc Dog936 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList936<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff936()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 936 done\n\n")
		}
	}
	

	let names937 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal937
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names937[rand() % names937.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog937 : Animal937
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation937 : Dog937
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList937<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff937()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog937 [5] {
				if i % 2 == 1   { it = alloc Dalmation937 }
				else            { it = alloc Dog937 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList937<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff937()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 937 done\n\n")
		}
	}
	

	let names938 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal938
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names938[rand() % names938.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog938 : Animal938
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation938 : Dog938
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList938<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff938()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog938 [5] {
				if i % 2 == 1   { it = alloc Dalmation938 }
				else            { it = alloc Dog938 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList938<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff938()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 938 done\n\n")
		}
	}
	

	let names939 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal939
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names939[rand() % names939.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog939 : Animal939
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation939 : Dog939
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList939<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff939()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog939 [5] {
				if i % 2 == 1   { it = alloc Dalmation939 }
				else            { it = alloc Dog939 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList939<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff939()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 939 done\n\n")
		}
	}
	

	let names940 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal940
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names940[rand() % names940.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog940 : Animal940
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation940 : Dog940
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList940<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff940()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog940 [5] {
				if i % 2 == 1   { it = alloc Dalmation940 }
				else            { it = alloc Dog940 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList940<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff940()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 940 done\n\n")
		}
	}
	

	let names941 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal941
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names941[rand() % names941.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog941 : Animal941
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation941 : Dog941
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList941<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff941()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog941 [5] {
				if i % 2 == 1   { it = alloc Dalmation941 }
				else            { it = alloc Dog941 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList941<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff941()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 941 done\n\n")
		}
	}
	

	let names942 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal942
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names942[rand() % names942.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog942 : Animal942
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation942 : Dog942
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList942<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff942()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog942 [5] {
				if i % 2 == 1   { it = alloc Dalmation942 }
				else            { it = alloc Dog942 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList942<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff942()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 942 done\n\n")
		}
	}
	

	let names943 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal943
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names943[rand() % names943.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog943 : Animal943
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation943 : Dog943
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList943<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff943()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog943 [5] {
				if i % 2 == 1   { it = alloc Dalmation943 }
				else            { it = alloc Dog943 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList943<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff943()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 943 done\n\n")
		}
	}
	

	let names944 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal944
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names944[rand() % names944.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog944 : Animal944
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation944 : Dog944
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList944<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff944()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog944 [5] {
				if i % 2 == 1   { it = alloc Dalmation944 }
				else            { it = alloc Dog944 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList944<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff944()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 944 done\n\n")
		}
	}
	

	let names945 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal945
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names945[rand() % names945.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog945 : Animal945
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation945 : Dog945
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList945<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff945()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog945 [5] {
				if i % 2 == 1   { it = alloc Dalmation945 }
				else            { it = alloc Dog945 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList945<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff945()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 945 done\n\n")
		}
	}
	

	let names946 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal946
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names946[rand() % names946.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog946 : Animal946
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation946 : Dog946
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList946<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff946()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog946 [5] {
				if i % 2 == 1   { it = alloc Dalmation946 }
				else            { it = alloc Dog946 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList946<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff946()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 946 done\n\n")
		}
	}
	

	let names947 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal947
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names947[rand() % names947.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog947 : Animal947
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation947 : Dog947
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList947<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff947()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog947 [5] {
				if i % 2 == 1   { it = alloc Dalmation947 }
				else            { it = alloc Dog947 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList947<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff947()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 947 done\n\n")
		}
	}
	

	let names948 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal948
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names948[rand() % names948.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog948 : Animal948
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation948 : Dog948
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList948<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff948()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog948 [5] {
				if i % 2 == 1   { it = alloc Dalmation948 }
				else            { it = alloc Dog948 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList948<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff948()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 948 done\n\n")
		}
	}
	

	let names949 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal949
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names949[rand() % names949.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog949 : Animal949
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation949 : Dog949
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList949<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff949()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog949 [5] {
				if i % 2 == 1   { it = alloc Dalmation949 }
				else            { it = alloc Dog949 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList949<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff949()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 949 done\n\n")
		}
	}
	

	let names950 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal950
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names950[rand() % names950.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog950 : Animal950
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation950 : Dog950
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList950<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff950()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog950 [5] {
				if i % 2 == 1   { it = alloc Dalmation950 }
				else            { it = alloc Dog950 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList950<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff950()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 950 done\n\n")
		}
	}
	

	let names951 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal951
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names951[rand() % names951.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog951 : Animal951
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation951 : Dog951
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList951<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff951()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog951 [5] {
				if i % 2 == 1   { it = alloc Dalmation951 }
				else            { it = alloc Dog951 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList951<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff951()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 951 done\n\n")
		}
	}
	

	let names952 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal952
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names952[rand() % names952.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog952 : Animal952
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation952 : Dog952
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList952<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff952()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog952 [5] {
				if i % 2 == 1   { it = alloc Dalmation952 }
				else            { it = alloc Dog952 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList952<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff952()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 952 done\n\n")
		}
	}
	

	let names953 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal953
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names953[rand() % names953.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog953 : Animal953
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation953 : Dog953
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList953<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff953()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog953 [5] {
				if i % 2 == 1   { it = alloc Dalmation953 }
				else            { it = alloc Dog953 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList953<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff953()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 953 done\n\n")
		}
	}
	

	let names954 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal954
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names954[rand() % names954.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog954 : Animal954
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation954 : Dog954
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList954<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff954()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog954 [5] {
				if i % 2 == 1   { it = alloc Dalmation954 }
				else            { it = alloc Dog954 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList954<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff954()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 954 done\n\n")
		}
	}
	

	let names955 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal955
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names955[rand() % names955.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog955 : Animal955
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation955 : Dog955
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList955<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff955()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog955 [5] {
				if i % 2 == 1   { it = alloc Dalmation955 }
				else            { it = alloc Dog955 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList955<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff955()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 955 done\n\n")
		}
	}
	

	let names956 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal956
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names956[rand() % names956.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog956 : Animal956
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation956 : Dog956
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList956<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff956()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog956 [5] {
				if i % 2 == 1   { it = alloc Dalmation956 }
				else            { it = alloc Dog956 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList956<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff956()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 956 done\n\n")
		}
	}
	

	let names957 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal957
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names957[rand() % names957.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog957 : Animal957
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation957 : Dog957
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList957<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff957()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog957 [5] {
				if i % 2 == 1   { it = alloc Dalmation957 }
				else            { it = alloc Dog957 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList957<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff957()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 957 done\n\n")
		}
	}
	

	let names958 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal958
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names958[rand() % names958.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog958 : Animal958
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation958 : Dog958
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList958<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff958()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog958 [5] {
				if i % 2 == 1   { it = alloc Dalmation958 }
				else            { it = alloc Dog958 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList958<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff958()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 958 done\n\n")
		}
	}
	

	let names959 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal959
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names959[rand() % names959.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog959 : Animal959
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation959 : Dog959
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList959<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff959()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog959 [5] {
				if i % 2 == 1   { it = alloc Dalmation959 }
				else            { it = alloc Dog959 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList959<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff959()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 959 done\n\n")
		}
	}
	

	let names960 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal960
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names960[rand() % names960.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog960 : Animal960
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation960 : Dog960
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList960<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff960()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog960 [5] {
				if i % 2 == 1   { it = alloc Dalmation960 }
				else            { it = alloc Dog960 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList960<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff960()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 960 done\n\n")
		}
	}
	

	let names961 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal961
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names961[rand() % names961.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog961 : Animal961
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation961 : Dog961
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList961<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff961()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog961 [5] {
				if i % 2 == 1   { it = alloc Dalmation961 }
				else            { it = alloc Dog961 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList961<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff961()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 961 done\n\n")
		}
	}
	

	let names962 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal962
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names962[rand() % names962.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog962 : Animal962
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation962 : Dog962
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList962<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff962()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog962 [5] {
				if i % 2 == 1   { it = alloc Dalmation962 }
				else            { it = alloc Dog962 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList962<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff962()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 962 done\n\n")
		}
	}
	

	let names963 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal963
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names963[rand() % names963.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog963 : Animal963
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation963 : Dog963
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList963<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff963()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog963 [5] {
				if i % 2 == 1   { it = alloc Dalmation963 }
				else            { it = alloc Dog963 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList963<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff963()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 963 done\n\n")
		}
	}
	

	let names964 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal964
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names964[rand() % names964.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog964 : Animal964
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation964 : Dog964
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList964<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff964()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog964 [5] {
				if i % 2 == 1   { it = alloc Dalmation964 }
				else            { it = alloc Dog964 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList964<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff964()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 964 done\n\n")
		}
	}
	

	let names965 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal965
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names965[rand() % names965.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog965 : Animal965
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation965 : Dog965
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList965<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff965()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog965 [5] {
				if i % 2 == 1   { it = alloc Dalmation965 }
				else            { it = alloc Dog965 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList965<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff965()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 965 done\n\n")
		}
	}
	

	let names966 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal966
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names966[rand() % names966.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog966 : Animal966
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation966 : Dog966
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList966<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff966()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog966 [5] {
				if i % 2 == 1   { it = alloc Dalmation966 }
				else            { it = alloc Dog966 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList966<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff966()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 966 done\n\n")
		}
	}
	

	let names967 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal967
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names967[rand() % names967.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog967 : Animal967
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation967 : Dog967
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList967<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff967()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog967 [5] {
				if i % 2 == 1   { it = alloc Dalmation967 }
				else            { it = alloc Dog967 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList967<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff967()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 967 done\n\n")
		}
	}
	

	let names968 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal968
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names968[rand() % names968.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog968 : Animal968
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation968 : Dog968
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList968<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff968()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog968 [5] {
				if i % 2 == 1   { it = alloc Dalmation968 }
				else            { it = alloc Dog968 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList968<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff968()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 968 done\n\n")
		}
	}
	

	let names969 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal969
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names969[rand() % names969.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog969 : Animal969
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation969 : Dog969
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList969<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff969()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog969 [5] {
				if i % 2 == 1   { it = alloc Dalmation969 }
				else            { it = alloc Dog969 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList969<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff969()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 969 done\n\n")
		}
	}
	

	let names970 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal970
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names970[rand() % names970.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog970 : Animal970
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation970 : Dog970
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList970<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff970()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog970 [5] {
				if i % 2 == 1   { it = alloc Dalmation970 }
				else            { it = alloc Dog970 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList970<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff970()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 970 done\n\n")
		}
	}
	

	let names971 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal971
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names971[rand() % names971.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog971 : Animal971
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation971 : Dog971
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList971<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff971()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog971 [5] {
				if i % 2 == 1   { it = alloc Dalmation971 }
				else            { it = alloc Dog971 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList971<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff971()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 971 done\n\n")
		}
	}
	

	let names972 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal972
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names972[rand() % names972.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog972 : Animal972
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation972 : Dog972
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList972<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff972()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog972 [5] {
				if i % 2 == 1   { it = alloc Dalmation972 }
				else            { it = alloc Dog972 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList972<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff972()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 972 done\n\n")
		}
	}
	

	let names973 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal973
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names973[rand() % names973.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog973 : Animal973
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation973 : Dog973
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList973<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff973()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog973 [5] {
				if i % 2 == 1   { it = alloc Dalmation973 }
				else            { it = alloc Dog973 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList973<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff973()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 973 done\n\n")
		}
	}
	

	let names974 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal974
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names974[rand() % names974.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog974 : Animal974
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation974 : Dog974
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList974<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff974()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog974 [5] {
				if i % 2 == 1   { it = alloc Dalmation974 }
				else            { it = alloc Dog974 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList974<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff974()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 974 done\n\n")
		}
	}
	

	let names975 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal975
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names975[rand() % names975.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog975 : Animal975
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation975 : Dog975
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList975<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff975()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog975 [5] {
				if i % 2 == 1   { it = alloc Dalmation975 }
				else            { it = alloc Dog975 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList975<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff975()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 975 done\n\n")
		}
	}
	

	let names976 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal976
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names976[rand() % names976.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog976 : Animal976
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation976 : Dog976
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList976<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff976()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog976 [5] {
				if i % 2 == 1   { it = alloc Dalmation976 }
				else            { it = alloc Dog976 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList976<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff976()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 976 done\n\n")
		}
	}
	

	let names977 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal977
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names977[rand() % names977.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog977 : Animal977
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation977 : Dog977
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList977<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff977()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog977 [5] {
				if i % 2 == 1   { it = alloc Dalmation977 }
				else            { it = alloc Dog977 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList977<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff977()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 977 done\n\n")
		}
	}
	

	let names978 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal978
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names978[rand() % names978.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog978 : Animal978
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation978 : Dog978
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList978<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff978()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog978 [5] {
				if i % 2 == 1   { it = alloc Dalmation978 }
				else            { it = alloc Dog978 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList978<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff978()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 978 done\n\n")
		}
	}
	

	let names979 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal979
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names979[rand() % names979.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog979 : Animal979
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation979 : Dog979
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList979<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff979()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog979 [5] {
				if i % 2 == 1   { it = alloc Dalmation979 }
				else            { it = alloc Dog979 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList979<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff979()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 979 done\n\n")
		}
	}
	

	let names980 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal980
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names980[rand() % names980.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog980 : Animal980
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation980 : Dog980
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList980<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff980()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog980 [5] {
				if i % 2 == 1   { it = alloc Dalmation980 }
				else            { it = alloc Dog980 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList980<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff980()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 980 done\n\n")
		}
	}
	

	let names981 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal981
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names981[rand() % names981.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog981 : Animal981
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation981 : Dog981
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList981<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff981()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog981 [5] {
				if i % 2 == 1   { it = alloc Dalmation981 }
				else            { it = alloc Dog981 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList981<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff981()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 981 done\n\n")
		}
	}
	

	let names982 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal982
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names982[rand() % names982.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog982 : Animal982
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation982 : Dog982
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList982<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff982()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog982 [5] {
				if i % 2 == 1   { it = alloc Dalmation982 }
				else            { it = alloc Dog982 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList982<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff982()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 982 done\n\n")
		}
	}
	

	let names983 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal983
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names983[rand() % names983.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog983 : Animal983
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation983 : Dog983
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList983<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff983()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog983 [5] {
				if i % 2 == 1   { it = alloc Dalmation983 }
				else            { it = alloc Dog983 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList983<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff983()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 983 done\n\n")
		}
	}
	

	let names984 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal984
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names984[rand() % names984.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog984 : Animal984
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation984 : Dog984
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList984<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff984()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog984 [5] {
				if i % 2 == 1   { it = alloc Dalmation984 }
				else            { it = alloc Dog984 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList984<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff984()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 984 done\n\n")
		}
	}
	

	let names985 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal985
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names985[rand() % names985.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog985 : Animal985
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation985 : Dog985
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList985<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff985()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog985 [5] {
				if i % 2 == 1   { it = alloc Dalmation985 }
				else            { it = alloc Dog985 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList985<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff985()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 985 done\n\n")
		}
	}
	

	let names986 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal986
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names986[rand() % names986.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog986 : Animal986
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation986 : Dog986
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList986<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff986()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog986 [5] {
				if i % 2 == 1   { it = alloc Dalmation986 }
				else            { it = alloc Dog986 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList986<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff986()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 986 done\n\n")
		}
	}
	

	let names987 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal987
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names987[rand() % names987.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog987 : Animal987
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation987 : Dog987
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList987<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff987()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog987 [5] {
				if i % 2 == 1   { it = alloc Dalmation987 }
				else            { it = alloc Dog987 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList987<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff987()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 987 done\n\n")
		}
	}
	

	let names988 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal988
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names988[rand() % names988.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog988 : Animal988
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation988 : Dog988
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList988<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff988()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog988 [5] {
				if i % 2 == 1   { it = alloc Dalmation988 }
				else            { it = alloc Dog988 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList988<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff988()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 988 done\n\n")
		}
	}
	

	let names989 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal989
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names989[rand() % names989.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog989 : Animal989
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation989 : Dog989
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList989<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff989()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog989 [5] {
				if i % 2 == 1   { it = alloc Dalmation989 }
				else            { it = alloc Dog989 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList989<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff989()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 989 done\n\n")
		}
	}
	

	let names990 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal990
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names990[rand() % names990.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog990 : Animal990
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation990 : Dog990
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList990<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff990()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog990 [5] {
				if i % 2 == 1   { it = alloc Dalmation990 }
				else            { it = alloc Dog990 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList990<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff990()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 990 done\n\n")
		}
	}
	

	let names991 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal991
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names991[rand() % names991.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog991 : Animal991
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation991 : Dog991
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList991<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff991()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog991 [5] {
				if i % 2 == 1   { it = alloc Dalmation991 }
				else            { it = alloc Dog991 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList991<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff991()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 991 done\n\n")
		}
	}
	

	let names992 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal992
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names992[rand() % names992.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog992 : Animal992
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation992 : Dog992
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList992<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff992()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog992 [5] {
				if i % 2 == 1   { it = alloc Dalmation992 }
				else            { it = alloc Dog992 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList992<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff992()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 992 done\n\n")
		}
	}
	

	let names993 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal993
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names993[rand() % names993.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog993 : Animal993
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation993 : Dog993
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList993<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff993()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog993 [5] {
				if i % 2 == 1   { it = alloc Dalmation993 }
				else            { it = alloc Dog993 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList993<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff993()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 993 done\n\n")
		}
	}
	

	let names994 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal994
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names994[rand() % names994.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog994 : Animal994
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation994 : Dog994
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList994<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff994()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog994 [5] {
				if i % 2 == 1   { it = alloc Dalmation994 }
				else            { it = alloc Dog994 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList994<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff994()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 994 done\n\n")
		}
	}
	

	let names995 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal995
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names995[rand() % names995.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog995 : Animal995
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation995 : Dog995
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList995<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff995()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog995 [5] {
				if i % 2 == 1   { it = alloc Dalmation995 }
				else            { it = alloc Dog995 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList995<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff995()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 995 done\n\n")
		}
	}
	

	let names996 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal996
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names996[rand() % names996.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog996 : Animal996
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation996 : Dog996
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList996<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff996()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog996 [5] {
				if i % 2 == 1   { it = alloc Dalmation996 }
				else            { it = alloc Dog996 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList996<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff996()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 996 done\n\n")
		}
	}
	

	let names997 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal997
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names997[rand() % names997.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog997 : Animal997
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation997 : Dog997
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList997<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff997()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog997 [5] {
				if i % 2 == 1   { it = alloc Dalmation997 }
				else            { it = alloc Dog997 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList997<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff997()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 997 done\n\n")
		}
	}
	

	let names998 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal998
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names998[rand() % names998.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog998 : Animal998
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation998 : Dog998
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList998<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff998()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog998 [5] {
				if i % 2 == 1   { it = alloc Dalmation998 }
				else            { it = alloc Dog998 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList998<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff998()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 998 done\n\n")
		}
	}
	

	let names999 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal999
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names999[rand() % names999.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog999 : Animal999
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation999 : Dog999
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList999<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff999()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog999 [5] {
				if i % 2 == 1   { it = alloc Dalmation999 }
				else            { it = alloc Dog999 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList999<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff999()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 999 done\n\n")
		}
	}
	

	let names1000 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1000
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1000[rand() % names1000.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1000 : Animal1000
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1000 : Dog1000
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1000<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1000()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1000 [5] {
				if i % 2 == 1   { it = alloc Dalmation1000 }
				else            { it = alloc Dog1000 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1000<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1000()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1000 done\n\n")
		}
	}
	

	let names1001 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1001
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1001[rand() % names1001.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1001 : Animal1001
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1001 : Dog1001
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1001<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1001()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1001 [5] {
				if i % 2 == 1   { it = alloc Dalmation1001 }
				else            { it = alloc Dog1001 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1001<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1001()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1001 done\n\n")
		}
	}
	

	let names1002 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1002
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1002[rand() % names1002.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1002 : Animal1002
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1002 : Dog1002
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1002<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1002()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1002 [5] {
				if i % 2 == 1   { it = alloc Dalmation1002 }
				else            { it = alloc Dog1002 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1002<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1002()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1002 done\n\n")
		}
	}
	

	let names1003 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1003
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1003[rand() % names1003.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1003 : Animal1003
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1003 : Dog1003
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1003<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1003()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1003 [5] {
				if i % 2 == 1   { it = alloc Dalmation1003 }
				else            { it = alloc Dog1003 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1003<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1003()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1003 done\n\n")
		}
	}
	

	let names1004 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1004
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1004[rand() % names1004.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1004 : Animal1004
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1004 : Dog1004
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1004<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1004()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1004 [5] {
				if i % 2 == 1   { it = alloc Dalmation1004 }
				else            { it = alloc Dog1004 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1004<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1004()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1004 done\n\n")
		}
	}
	

	let names1005 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1005
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1005[rand() % names1005.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1005 : Animal1005
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1005 : Dog1005
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1005<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1005()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1005 [5] {
				if i % 2 == 1   { it = alloc Dalmation1005 }
				else            { it = alloc Dog1005 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1005<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1005()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1005 done\n\n")
		}
	}
	

	let names1006 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1006
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1006[rand() % names1006.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1006 : Animal1006
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1006 : Dog1006
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1006<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1006()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1006 [5] {
				if i % 2 == 1   { it = alloc Dalmation1006 }
				else            { it = alloc Dog1006 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1006<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1006()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1006 done\n\n")
		}
	}
	

	let names1007 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1007
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1007[rand() % names1007.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1007 : Animal1007
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1007 : Dog1007
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1007<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1007()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1007 [5] {
				if i % 2 == 1   { it = alloc Dalmation1007 }
				else            { it = alloc Dog1007 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1007<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1007()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1007 done\n\n")
		}
	}
	

	let names1008 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1008
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1008[rand() % names1008.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1008 : Animal1008
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1008 : Dog1008
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1008<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1008()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1008 [5] {
				if i % 2 == 1   { it = alloc Dalmation1008 }
				else            { it = alloc Dog1008 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1008<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1008()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1008 done\n\n")
		}
	}
	

	let names1009 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1009
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1009[rand() % names1009.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1009 : Animal1009
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1009 : Dog1009
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1009<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1009()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1009 [5] {
				if i % 2 == 1   { it = alloc Dalmation1009 }
				else            { it = alloc Dog1009 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1009<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1009()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1009 done\n\n")
		}
	}
	

	let names1010 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1010
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1010[rand() % names1010.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1010 : Animal1010
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1010 : Dog1010
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1010<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1010()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1010 [5] {
				if i % 2 == 1   { it = alloc Dalmation1010 }
				else            { it = alloc Dog1010 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1010<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1010()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1010 done\n\n")
		}
	}
	

	let names1011 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1011
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1011[rand() % names1011.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1011 : Animal1011
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1011 : Dog1011
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1011<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1011()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1011 [5] {
				if i % 2 == 1   { it = alloc Dalmation1011 }
				else            { it = alloc Dog1011 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1011<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1011()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1011 done\n\n")
		}
	}
	

	let names1012 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1012
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1012[rand() % names1012.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1012 : Animal1012
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1012 : Dog1012
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1012<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1012()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1012 [5] {
				if i % 2 == 1   { it = alloc Dalmation1012 }
				else            { it = alloc Dog1012 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1012<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1012()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1012 done\n\n")
		}
	}
	

	let names1013 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1013
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1013[rand() % names1013.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1013 : Animal1013
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1013 : Dog1013
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1013<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1013()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1013 [5] {
				if i % 2 == 1   { it = alloc Dalmation1013 }
				else            { it = alloc Dog1013 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1013<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1013()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1013 done\n\n")
		}
	}
	

	let names1014 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1014
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1014[rand() % names1014.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1014 : Animal1014
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1014 : Dog1014
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1014<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1014()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1014 [5] {
				if i % 2 == 1   { it = alloc Dalmation1014 }
				else            { it = alloc Dog1014 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1014<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1014()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1014 done\n\n")
		}
	}
	

	let names1015 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1015
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1015[rand() % names1015.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1015 : Animal1015
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1015 : Dog1015
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1015<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1015()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1015 [5] {
				if i % 2 == 1   { it = alloc Dalmation1015 }
				else            { it = alloc Dog1015 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1015<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1015()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1015 done\n\n")
		}
	}
	

	let names1016 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1016
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1016[rand() % names1016.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1016 : Animal1016
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1016 : Dog1016
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1016<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1016()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1016 [5] {
				if i % 2 == 1   { it = alloc Dalmation1016 }
				else            { it = alloc Dog1016 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1016<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1016()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1016 done\n\n")
		}
	}
	

	let names1017 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1017
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1017[rand() % names1017.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1017 : Animal1017
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1017 : Dog1017
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1017<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1017()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1017 [5] {
				if i % 2 == 1   { it = alloc Dalmation1017 }
				else            { it = alloc Dog1017 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1017<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1017()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1017 done\n\n")
		}
	}
	

	let names1018 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1018
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1018[rand() % names1018.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1018 : Animal1018
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1018 : Dog1018
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1018<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1018()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1018 [5] {
				if i % 2 == 1   { it = alloc Dalmation1018 }
				else            { it = alloc Dog1018 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1018<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1018()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1018 done\n\n")
		}
	}
	

	let names1019 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1019
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1019[rand() % names1019.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1019 : Animal1019
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1019 : Dog1019
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1019<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1019()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1019 [5] {
				if i % 2 == 1   { it = alloc Dalmation1019 }
				else            { it = alloc Dog1019 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1019<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1019()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1019 done\n\n")
		}
	}
	

	let names1020 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1020
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1020[rand() % names1020.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1020 : Animal1020
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1020 : Dog1020
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1020<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1020()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1020 [5] {
				if i % 2 == 1   { it = alloc Dalmation1020 }
				else            { it = alloc Dog1020 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1020<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1020()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1020 done\n\n")
		}
	}
	

	let names1021 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1021
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1021[rand() % names1021.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1021 : Animal1021
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1021 : Dog1021
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1021<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1021()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1021 [5] {
				if i % 2 == 1   { it = alloc Dalmation1021 }
				else            { it = alloc Dog1021 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1021<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1021()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1021 done\n\n")
		}
	}
	

	let names1022 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1022
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1022[rand() % names1022.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1022 : Animal1022
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1022 : Dog1022
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1022<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1022()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1022 [5] {
				if i % 2 == 1   { it = alloc Dalmation1022 }
				else            { it = alloc Dog1022 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1022<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1022()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1022 done\n\n")
		}
	}
	

	let names1023 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1023
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1023[rand() % names1023.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1023 : Animal1023
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1023 : Dog1023
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1023<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1023()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1023 [5] {
				if i % 2 == 1   { it = alloc Dalmation1023 }
				else            { it = alloc Dog1023 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1023<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1023()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1023 done\n\n")
		}
	}
	

	let names1024 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1024
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1024[rand() % names1024.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1024 : Animal1024
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1024 : Dog1024
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1024<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1024()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1024 [5] {
				if i % 2 == 1   { it = alloc Dalmation1024 }
				else            { it = alloc Dog1024 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1024<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1024()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1024 done\n\n")
		}
	}
	

	let names1025 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1025
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1025[rand() % names1025.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1025 : Animal1025
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1025 : Dog1025
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1025<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1025()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1025 [5] {
				if i % 2 == 1   { it = alloc Dalmation1025 }
				else            { it = alloc Dog1025 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1025<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1025()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1025 done\n\n")
		}
	}
	

	let names1026 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1026
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1026[rand() % names1026.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1026 : Animal1026
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1026 : Dog1026
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1026<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1026()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1026 [5] {
				if i % 2 == 1   { it = alloc Dalmation1026 }
				else            { it = alloc Dog1026 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1026<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1026()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1026 done\n\n")
		}
	}
	

	let names1027 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1027
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1027[rand() % names1027.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1027 : Animal1027
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1027 : Dog1027
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1027<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1027()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1027 [5] {
				if i % 2 == 1   { it = alloc Dalmation1027 }
				else            { it = alloc Dog1027 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1027<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1027()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1027 done\n\n")
		}
	}
	

	let names1028 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1028
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1028[rand() % names1028.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1028 : Animal1028
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1028 : Dog1028
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1028<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1028()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1028 [5] {
				if i % 2 == 1   { it = alloc Dalmation1028 }
				else            { it = alloc Dog1028 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1028<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1028()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1028 done\n\n")
		}
	}
	

	let names1029 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1029
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1029[rand() % names1029.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1029 : Animal1029
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1029 : Dog1029
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1029<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1029()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1029 [5] {
				if i % 2 == 1   { it = alloc Dalmation1029 }
				else            { it = alloc Dog1029 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1029<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1029()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1029 done\n\n")
		}
	}
	

	let names1030 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1030
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1030[rand() % names1030.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1030 : Animal1030
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1030 : Dog1030
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1030<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1030()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1030 [5] {
				if i % 2 == 1   { it = alloc Dalmation1030 }
				else            { it = alloc Dog1030 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1030<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1030()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1030 done\n\n")
		}
	}
	

	let names1031 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1031
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1031[rand() % names1031.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1031 : Animal1031
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1031 : Dog1031
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1031<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1031()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1031 [5] {
				if i % 2 == 1   { it = alloc Dalmation1031 }
				else            { it = alloc Dog1031 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1031<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1031()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1031 done\n\n")
		}
	}
	

	let names1032 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1032
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1032[rand() % names1032.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1032 : Animal1032
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1032 : Dog1032
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1032<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1032()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1032 [5] {
				if i % 2 == 1   { it = alloc Dalmation1032 }
				else            { it = alloc Dog1032 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1032<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1032()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1032 done\n\n")
		}
	}
	

	let names1033 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1033
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1033[rand() % names1033.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1033 : Animal1033
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1033 : Dog1033
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1033<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1033()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1033 [5] {
				if i % 2 == 1   { it = alloc Dalmation1033 }
				else            { it = alloc Dog1033 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1033<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1033()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1033 done\n\n")
		}
	}
	

	let names1034 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1034
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1034[rand() % names1034.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1034 : Animal1034
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1034 : Dog1034
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1034<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1034()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1034 [5] {
				if i % 2 == 1   { it = alloc Dalmation1034 }
				else            { it = alloc Dog1034 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1034<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1034()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1034 done\n\n")
		}
	}
	

	let names1035 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1035
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1035[rand() % names1035.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1035 : Animal1035
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1035 : Dog1035
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1035<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1035()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1035 [5] {
				if i % 2 == 1   { it = alloc Dalmation1035 }
				else            { it = alloc Dog1035 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1035<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1035()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1035 done\n\n")
		}
	}
	

	let names1036 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1036
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1036[rand() % names1036.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1036 : Animal1036
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1036 : Dog1036
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1036<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1036()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1036 [5] {
				if i % 2 == 1   { it = alloc Dalmation1036 }
				else            { it = alloc Dog1036 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1036<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1036()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1036 done\n\n")
		}
	}
	

	let names1037 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1037
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1037[rand() % names1037.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1037 : Animal1037
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1037 : Dog1037
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1037<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1037()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1037 [5] {
				if i % 2 == 1   { it = alloc Dalmation1037 }
				else            { it = alloc Dog1037 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1037<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1037()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1037 done\n\n")
		}
	}
	

	let names1038 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1038
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1038[rand() % names1038.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1038 : Animal1038
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1038 : Dog1038
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1038<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1038()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1038 [5] {
				if i % 2 == 1   { it = alloc Dalmation1038 }
				else            { it = alloc Dog1038 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1038<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1038()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1038 done\n\n")
		}
	}
	

	let names1039 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1039
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1039[rand() % names1039.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1039 : Animal1039
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1039 : Dog1039
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1039<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1039()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1039 [5] {
				if i % 2 == 1   { it = alloc Dalmation1039 }
				else            { it = alloc Dog1039 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1039<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1039()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1039 done\n\n")
		}
	}
	

	let names1040 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1040
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1040[rand() % names1040.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1040 : Animal1040
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1040 : Dog1040
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1040<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1040()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1040 [5] {
				if i % 2 == 1   { it = alloc Dalmation1040 }
				else            { it = alloc Dog1040 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1040<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1040()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1040 done\n\n")
		}
	}
	

	let names1041 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1041
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1041[rand() % names1041.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1041 : Animal1041
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1041 : Dog1041
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1041<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1041()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1041 [5] {
				if i % 2 == 1   { it = alloc Dalmation1041 }
				else            { it = alloc Dog1041 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1041<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1041()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1041 done\n\n")
		}
	}
	

	let names1042 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1042
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1042[rand() % names1042.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1042 : Animal1042
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1042 : Dog1042
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1042<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1042()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1042 [5] {
				if i % 2 == 1   { it = alloc Dalmation1042 }
				else            { it = alloc Dog1042 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1042<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1042()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1042 done\n\n")
		}
	}
	

	let names1043 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1043
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1043[rand() % names1043.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1043 : Animal1043
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1043 : Dog1043
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1043<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1043()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1043 [5] {
				if i % 2 == 1   { it = alloc Dalmation1043 }
				else            { it = alloc Dog1043 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1043<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1043()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1043 done\n\n")
		}
	}
	

	let names1044 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1044
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1044[rand() % names1044.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1044 : Animal1044
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1044 : Dog1044
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1044<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1044()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1044 [5] {
				if i % 2 == 1   { it = alloc Dalmation1044 }
				else            { it = alloc Dog1044 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1044<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1044()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1044 done\n\n")
		}
	}
	

	let names1045 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1045
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1045[rand() % names1045.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1045 : Animal1045
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1045 : Dog1045
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1045<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1045()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1045 [5] {
				if i % 2 == 1   { it = alloc Dalmation1045 }
				else            { it = alloc Dog1045 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1045<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1045()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1045 done\n\n")
		}
	}
	

	let names1046 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1046
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1046[rand() % names1046.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1046 : Animal1046
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1046 : Dog1046
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1046<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1046()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1046 [5] {
				if i % 2 == 1   { it = alloc Dalmation1046 }
				else            { it = alloc Dog1046 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1046<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1046()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1046 done\n\n")
		}
	}
	

	let names1047 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1047
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1047[rand() % names1047.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1047 : Animal1047
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1047 : Dog1047
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1047<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1047()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1047 [5] {
				if i % 2 == 1   { it = alloc Dalmation1047 }
				else            { it = alloc Dog1047 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1047<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1047()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1047 done\n\n")
		}
	}
	

	let names1048 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1048
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1048[rand() % names1048.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1048 : Animal1048
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1048 : Dog1048
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1048<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1048()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1048 [5] {
				if i % 2 == 1   { it = alloc Dalmation1048 }
				else            { it = alloc Dog1048 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1048<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1048()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1048 done\n\n")
		}
	}
	

	let names1049 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1049
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1049[rand() % names1049.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1049 : Animal1049
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1049 : Dog1049
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1049<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1049()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1049 [5] {
				if i % 2 == 1   { it = alloc Dalmation1049 }
				else            { it = alloc Dog1049 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1049<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1049()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1049 done\n\n")
		}
	}
	

	let names1050 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1050
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1050[rand() % names1050.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1050 : Animal1050
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1050 : Dog1050
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1050<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1050()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1050 [5] {
				if i % 2 == 1   { it = alloc Dalmation1050 }
				else            { it = alloc Dog1050 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1050<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1050()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1050 done\n\n")
		}
	}
	

	let names1051 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1051
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1051[rand() % names1051.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1051 : Animal1051
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1051 : Dog1051
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1051<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1051()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1051 [5] {
				if i % 2 == 1   { it = alloc Dalmation1051 }
				else            { it = alloc Dog1051 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1051<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1051()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1051 done\n\n")
		}
	}
	

	let names1052 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1052
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1052[rand() % names1052.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1052 : Animal1052
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1052 : Dog1052
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1052<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1052()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1052 [5] {
				if i % 2 == 1   { it = alloc Dalmation1052 }
				else            { it = alloc Dog1052 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1052<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1052()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1052 done\n\n")
		}
	}
	

	let names1053 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1053
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1053[rand() % names1053.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1053 : Animal1053
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1053 : Dog1053
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1053<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1053()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1053 [5] {
				if i % 2 == 1   { it = alloc Dalmation1053 }
				else            { it = alloc Dog1053 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1053<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1053()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1053 done\n\n")
		}
	}
	

	let names1054 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1054
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1054[rand() % names1054.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1054 : Animal1054
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1054 : Dog1054
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1054<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1054()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1054 [5] {
				if i % 2 == 1   { it = alloc Dalmation1054 }
				else            { it = alloc Dog1054 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1054<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1054()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1054 done\n\n")
		}
	}
	

	let names1055 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1055
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1055[rand() % names1055.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1055 : Animal1055
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1055 : Dog1055
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1055<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1055()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1055 [5] {
				if i % 2 == 1   { it = alloc Dalmation1055 }
				else            { it = alloc Dog1055 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1055<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1055()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1055 done\n\n")
		}
	}
	

	let names1056 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1056
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1056[rand() % names1056.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1056 : Animal1056
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1056 : Dog1056
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1056<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1056()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1056 [5] {
				if i % 2 == 1   { it = alloc Dalmation1056 }
				else            { it = alloc Dog1056 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1056<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1056()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1056 done\n\n")
		}
	}
	

	let names1057 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1057
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1057[rand() % names1057.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1057 : Animal1057
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1057 : Dog1057
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1057<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1057()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1057 [5] {
				if i % 2 == 1   { it = alloc Dalmation1057 }
				else            { it = alloc Dog1057 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1057<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1057()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1057 done\n\n")
		}
	}
	

	let names1058 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1058
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1058[rand() % names1058.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1058 : Animal1058
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1058 : Dog1058
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1058<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1058()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1058 [5] {
				if i % 2 == 1   { it = alloc Dalmation1058 }
				else            { it = alloc Dog1058 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1058<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1058()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1058 done\n\n")
		}
	}
	

	let names1059 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1059
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1059[rand() % names1059.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1059 : Animal1059
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1059 : Dog1059
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1059<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1059()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1059 [5] {
				if i % 2 == 1   { it = alloc Dalmation1059 }
				else            { it = alloc Dog1059 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1059<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1059()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1059 done\n\n")
		}
	}
	

	let names1060 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1060
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1060[rand() % names1060.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1060 : Animal1060
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1060 : Dog1060
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1060<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1060()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1060 [5] {
				if i % 2 == 1   { it = alloc Dalmation1060 }
				else            { it = alloc Dog1060 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1060<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1060()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1060 done\n\n")
		}
	}
	

	let names1061 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1061
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1061[rand() % names1061.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1061 : Animal1061
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1061 : Dog1061
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1061<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1061()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1061 [5] {
				if i % 2 == 1   { it = alloc Dalmation1061 }
				else            { it = alloc Dog1061 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1061<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1061()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1061 done\n\n")
		}
	}
	

	let names1062 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1062
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1062[rand() % names1062.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1062 : Animal1062
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1062 : Dog1062
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1062<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1062()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1062 [5] {
				if i % 2 == 1   { it = alloc Dalmation1062 }
				else            { it = alloc Dog1062 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1062<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1062()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1062 done\n\n")
		}
	}
	

	let names1063 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1063
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1063[rand() % names1063.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1063 : Animal1063
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1063 : Dog1063
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1063<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1063()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1063 [5] {
				if i % 2 == 1   { it = alloc Dalmation1063 }
				else            { it = alloc Dog1063 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1063<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1063()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1063 done\n\n")
		}
	}
	

	let names1064 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1064
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1064[rand() % names1064.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1064 : Animal1064
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1064 : Dog1064
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1064<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1064()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1064 [5] {
				if i % 2 == 1   { it = alloc Dalmation1064 }
				else            { it = alloc Dog1064 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1064<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1064()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1064 done\n\n")
		}
	}
	

	let names1065 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1065
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1065[rand() % names1065.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1065 : Animal1065
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1065 : Dog1065
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1065<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1065()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1065 [5] {
				if i % 2 == 1   { it = alloc Dalmation1065 }
				else            { it = alloc Dog1065 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1065<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1065()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1065 done\n\n")
		}
	}
	

	let names1066 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1066
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1066[rand() % names1066.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1066 : Animal1066
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1066 : Dog1066
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1066<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1066()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1066 [5] {
				if i % 2 == 1   { it = alloc Dalmation1066 }
				else            { it = alloc Dog1066 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1066<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1066()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1066 done\n\n")
		}
	}
	

	let names1067 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1067
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1067[rand() % names1067.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1067 : Animal1067
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1067 : Dog1067
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1067<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1067()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1067 [5] {
				if i % 2 == 1   { it = alloc Dalmation1067 }
				else            { it = alloc Dog1067 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1067<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1067()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1067 done\n\n")
		}
	}
	

	let names1068 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1068
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1068[rand() % names1068.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1068 : Animal1068
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1068 : Dog1068
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1068<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1068()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1068 [5] {
				if i % 2 == 1   { it = alloc Dalmation1068 }
				else            { it = alloc Dog1068 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1068<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1068()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1068 done\n\n")
		}
	}
	

	let names1069 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1069
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1069[rand() % names1069.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1069 : Animal1069
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1069 : Dog1069
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1069<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1069()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1069 [5] {
				if i % 2 == 1   { it = alloc Dalmation1069 }
				else            { it = alloc Dog1069 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1069<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1069()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1069 done\n\n")
		}
	}
	

	let names1070 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1070
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1070[rand() % names1070.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1070 : Animal1070
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1070 : Dog1070
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1070<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1070()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1070 [5] {
				if i % 2 == 1   { it = alloc Dalmation1070 }
				else            { it = alloc Dog1070 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1070<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1070()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1070 done\n\n")
		}
	}
	

	let names1071 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1071
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1071[rand() % names1071.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1071 : Animal1071
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1071 : Dog1071
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1071<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1071()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1071 [5] {
				if i % 2 == 1   { it = alloc Dalmation1071 }
				else            { it = alloc Dog1071 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1071<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1071()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1071 done\n\n")
		}
	}
	

	let names1072 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1072
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1072[rand() % names1072.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1072 : Animal1072
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1072 : Dog1072
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1072<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1072()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1072 [5] {
				if i % 2 == 1   { it = alloc Dalmation1072 }
				else            { it = alloc Dog1072 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1072<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1072()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1072 done\n\n")
		}
	}
	

	let names1073 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1073
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1073[rand() % names1073.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1073 : Animal1073
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1073 : Dog1073
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1073<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1073()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1073 [5] {
				if i % 2 == 1   { it = alloc Dalmation1073 }
				else            { it = alloc Dog1073 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1073<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1073()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1073 done\n\n")
		}
	}
	

	let names1074 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1074
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1074[rand() % names1074.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1074 : Animal1074
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1074 : Dog1074
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1074<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1074()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1074 [5] {
				if i % 2 == 1   { it = alloc Dalmation1074 }
				else            { it = alloc Dog1074 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1074<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1074()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1074 done\n\n")
		}
	}
	

	let names1075 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1075
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1075[rand() % names1075.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1075 : Animal1075
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1075 : Dog1075
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1075<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1075()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1075 [5] {
				if i % 2 == 1   { it = alloc Dalmation1075 }
				else            { it = alloc Dog1075 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1075<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1075()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1075 done\n\n")
		}
	}
	

	let names1076 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1076
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1076[rand() % names1076.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1076 : Animal1076
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1076 : Dog1076
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1076<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1076()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1076 [5] {
				if i % 2 == 1   { it = alloc Dalmation1076 }
				else            { it = alloc Dog1076 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1076<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1076()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1076 done\n\n")
		}
	}
	

	let names1077 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1077
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1077[rand() % names1077.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1077 : Animal1077
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1077 : Dog1077
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1077<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1077()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1077 [5] {
				if i % 2 == 1   { it = alloc Dalmation1077 }
				else            { it = alloc Dog1077 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1077<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1077()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1077 done\n\n")
		}
	}
	

	let names1078 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1078
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1078[rand() % names1078.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1078 : Animal1078
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1078 : Dog1078
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1078<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1078()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1078 [5] {
				if i % 2 == 1   { it = alloc Dalmation1078 }
				else            { it = alloc Dog1078 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1078<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1078()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1078 done\n\n")
		}
	}
	

	let names1079 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1079
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1079[rand() % names1079.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1079 : Animal1079
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1079 : Dog1079
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1079<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1079()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1079 [5] {
				if i % 2 == 1   { it = alloc Dalmation1079 }
				else            { it = alloc Dog1079 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1079<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1079()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1079 done\n\n")
		}
	}
	

	let names1080 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1080
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1080[rand() % names1080.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1080 : Animal1080
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1080 : Dog1080
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1080<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1080()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1080 [5] {
				if i % 2 == 1   { it = alloc Dalmation1080 }
				else            { it = alloc Dog1080 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1080<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1080()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1080 done\n\n")
		}
	}
	

	let names1081 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1081
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1081[rand() % names1081.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1081 : Animal1081
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1081 : Dog1081
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1081<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1081()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1081 [5] {
				if i % 2 == 1   { it = alloc Dalmation1081 }
				else            { it = alloc Dog1081 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1081<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1081()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1081 done\n\n")
		}
	}
	

	let names1082 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1082
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1082[rand() % names1082.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1082 : Animal1082
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1082 : Dog1082
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1082<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1082()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1082 [5] {
				if i % 2 == 1   { it = alloc Dalmation1082 }
				else            { it = alloc Dog1082 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1082<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1082()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1082 done\n\n")
		}
	}
	

	let names1083 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1083
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1083[rand() % names1083.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1083 : Animal1083
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1083 : Dog1083
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1083<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1083()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1083 [5] {
				if i % 2 == 1   { it = alloc Dalmation1083 }
				else            { it = alloc Dog1083 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1083<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1083()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1083 done\n\n")
		}
	}
	

	let names1084 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1084
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1084[rand() % names1084.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1084 : Animal1084
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1084 : Dog1084
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1084<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1084()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1084 [5] {
				if i % 2 == 1   { it = alloc Dalmation1084 }
				else            { it = alloc Dog1084 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1084<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1084()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1084 done\n\n")
		}
	}
	

	let names1085 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1085
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1085[rand() % names1085.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1085 : Animal1085
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1085 : Dog1085
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1085<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1085()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1085 [5] {
				if i % 2 == 1   { it = alloc Dalmation1085 }
				else            { it = alloc Dog1085 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1085<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1085()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1085 done\n\n")
		}
	}
	

	let names1086 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1086
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1086[rand() % names1086.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1086 : Animal1086
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1086 : Dog1086
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1086<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1086()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1086 [5] {
				if i % 2 == 1   { it = alloc Dalmation1086 }
				else            { it = alloc Dog1086 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1086<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1086()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1086 done\n\n")
		}
	}
	

	let names1087 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1087
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1087[rand() % names1087.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1087 : Animal1087
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1087 : Dog1087
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1087<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1087()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1087 [5] {
				if i % 2 == 1   { it = alloc Dalmation1087 }
				else            { it = alloc Dog1087 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1087<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1087()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1087 done\n\n")
		}
	}
	

	let names1088 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1088
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1088[rand() % names1088.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1088 : Animal1088
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1088 : Dog1088
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1088<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1088()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1088 [5] {
				if i % 2 == 1   { it = alloc Dalmation1088 }
				else            { it = alloc Dog1088 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1088<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1088()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1088 done\n\n")
		}
	}
	

	let names1089 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1089
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1089[rand() % names1089.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1089 : Animal1089
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1089 : Dog1089
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1089<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1089()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1089 [5] {
				if i % 2 == 1   { it = alloc Dalmation1089 }
				else            { it = alloc Dog1089 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1089<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1089()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1089 done\n\n")
		}
	}
	

	let names1090 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1090
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1090[rand() % names1090.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1090 : Animal1090
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1090 : Dog1090
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1090<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1090()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1090 [5] {
				if i % 2 == 1   { it = alloc Dalmation1090 }
				else            { it = alloc Dog1090 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1090<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1090()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1090 done\n\n")
		}
	}
	

	let names1091 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1091
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1091[rand() % names1091.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1091 : Animal1091
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1091 : Dog1091
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1091<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1091()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1091 [5] {
				if i % 2 == 1   { it = alloc Dalmation1091 }
				else            { it = alloc Dog1091 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1091<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1091()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1091 done\n\n")
		}
	}
	

	let names1092 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1092
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1092[rand() % names1092.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1092 : Animal1092
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1092 : Dog1092
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1092<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1092()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1092 [5] {
				if i % 2 == 1   { it = alloc Dalmation1092 }
				else            { it = alloc Dog1092 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1092<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1092()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1092 done\n\n")
		}
	}
	

	let names1093 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1093
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1093[rand() % names1093.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1093 : Animal1093
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1093 : Dog1093
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1093<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1093()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1093 [5] {
				if i % 2 == 1   { it = alloc Dalmation1093 }
				else            { it = alloc Dog1093 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1093<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1093()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1093 done\n\n")
		}
	}
	

	let names1094 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1094
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1094[rand() % names1094.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1094 : Animal1094
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1094 : Dog1094
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1094<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1094()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1094 [5] {
				if i % 2 == 1   { it = alloc Dalmation1094 }
				else            { it = alloc Dog1094 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1094<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1094()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1094 done\n\n")
		}
	}
	

	let names1095 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1095
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1095[rand() % names1095.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1095 : Animal1095
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1095 : Dog1095
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1095<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1095()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1095 [5] {
				if i % 2 == 1   { it = alloc Dalmation1095 }
				else            { it = alloc Dog1095 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1095<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1095()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1095 done\n\n")
		}
	}
	

	let names1096 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1096
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1096[rand() % names1096.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1096 : Animal1096
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1096 : Dog1096
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1096<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1096()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1096 [5] {
				if i % 2 == 1   { it = alloc Dalmation1096 }
				else            { it = alloc Dog1096 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1096<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1096()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1096 done\n\n")
		}
	}
	

	let names1097 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1097
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1097[rand() % names1097.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1097 : Animal1097
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1097 : Dog1097
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1097<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1097()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1097 [5] {
				if i % 2 == 1   { it = alloc Dalmation1097 }
				else            { it = alloc Dog1097 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1097<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1097()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1097 done\n\n")
		}
	}
	

	let names1098 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1098
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1098[rand() % names1098.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1098 : Animal1098
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1098 : Dog1098
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1098<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1098()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1098 [5] {
				if i % 2 == 1   { it = alloc Dalmation1098 }
				else            { it = alloc Dog1098 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1098<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1098()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1098 done\n\n")
		}
	}
	

	let names1099 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1099
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1099[rand() % names1099.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1099 : Animal1099
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1099 : Dog1099
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1099<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1099()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1099 [5] {
				if i % 2 == 1   { it = alloc Dalmation1099 }
				else            { it = alloc Dog1099 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1099<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1099()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1099 done\n\n")
		}
	}
	

	let names1100 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1100
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1100[rand() % names1100.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1100 : Animal1100
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1100 : Dog1100
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1100<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1100()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1100 [5] {
				if i % 2 == 1   { it = alloc Dalmation1100 }
				else            { it = alloc Dog1100 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1100<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1100()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1100 done\n\n")
		}
	}
	

	let names1101 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1101
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1101[rand() % names1101.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1101 : Animal1101
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1101 : Dog1101
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1101<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1101()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1101 [5] {
				if i % 2 == 1   { it = alloc Dalmation1101 }
				else            { it = alloc Dog1101 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1101<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1101()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1101 done\n\n")
		}
	}
	

	let names1102 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1102
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1102[rand() % names1102.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1102 : Animal1102
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1102 : Dog1102
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1102<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1102()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1102 [5] {
				if i % 2 == 1   { it = alloc Dalmation1102 }
				else            { it = alloc Dog1102 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1102<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1102()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1102 done\n\n")
		}
	}
	

	let names1103 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1103
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1103[rand() % names1103.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1103 : Animal1103
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1103 : Dog1103
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1103<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1103()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1103 [5] {
				if i % 2 == 1   { it = alloc Dalmation1103 }
				else            { it = alloc Dog1103 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1103<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1103()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1103 done\n\n")
		}
	}
	

	let names1104 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1104
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1104[rand() % names1104.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1104 : Animal1104
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1104 : Dog1104
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1104<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1104()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1104 [5] {
				if i % 2 == 1   { it = alloc Dalmation1104 }
				else            { it = alloc Dog1104 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1104<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1104()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1104 done\n\n")
		}
	}
	

	let names1105 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1105
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1105[rand() % names1105.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1105 : Animal1105
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1105 : Dog1105
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1105<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1105()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1105 [5] {
				if i % 2 == 1   { it = alloc Dalmation1105 }
				else            { it = alloc Dog1105 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1105<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1105()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1105 done\n\n")
		}
	}
	

	let names1106 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1106
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1106[rand() % names1106.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1106 : Animal1106
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1106 : Dog1106
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1106<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1106()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1106 [5] {
				if i % 2 == 1   { it = alloc Dalmation1106 }
				else            { it = alloc Dog1106 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1106<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1106()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1106 done\n\n")
		}
	}
	

	let names1107 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1107
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1107[rand() % names1107.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1107 : Animal1107
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1107 : Dog1107
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1107<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1107()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1107 [5] {
				if i % 2 == 1   { it = alloc Dalmation1107 }
				else            { it = alloc Dog1107 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1107<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1107()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1107 done\n\n")
		}
	}
	

	let names1108 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1108
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1108[rand() % names1108.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1108 : Animal1108
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1108 : Dog1108
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1108<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1108()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1108 [5] {
				if i % 2 == 1   { it = alloc Dalmation1108 }
				else            { it = alloc Dog1108 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1108<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1108()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1108 done\n\n")
		}
	}
	

	let names1109 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1109
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1109[rand() % names1109.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1109 : Animal1109
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1109 : Dog1109
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1109<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1109()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1109 [5] {
				if i % 2 == 1   { it = alloc Dalmation1109 }
				else            { it = alloc Dog1109 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1109<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1109()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1109 done\n\n")
		}
	}
	

	let names1110 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1110
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1110[rand() % names1110.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1110 : Animal1110
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1110 : Dog1110
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1110<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1110()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1110 [5] {
				if i % 2 == 1   { it = alloc Dalmation1110 }
				else            { it = alloc Dog1110 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1110<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1110()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1110 done\n\n")
		}
	}
	

	let names1111 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1111
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1111[rand() % names1111.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1111 : Animal1111
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1111 : Dog1111
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1111<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1111()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1111 [5] {
				if i % 2 == 1   { it = alloc Dalmation1111 }
				else            { it = alloc Dog1111 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1111<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1111()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1111 done\n\n")
		}
	}
	

	let names1112 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1112
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1112[rand() % names1112.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1112 : Animal1112
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1112 : Dog1112
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1112<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1112()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1112 [5] {
				if i % 2 == 1   { it = alloc Dalmation1112 }
				else            { it = alloc Dog1112 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1112<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1112()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1112 done\n\n")
		}
	}
	

	let names1113 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1113
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1113[rand() % names1113.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1113 : Animal1113
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1113 : Dog1113
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1113<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1113()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1113 [5] {
				if i % 2 == 1   { it = alloc Dalmation1113 }
				else            { it = alloc Dog1113 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1113<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1113()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1113 done\n\n")
		}
	}
	

	let names1114 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1114
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1114[rand() % names1114.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1114 : Animal1114
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1114 : Dog1114
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1114<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1114()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1114 [5] {
				if i % 2 == 1   { it = alloc Dalmation1114 }
				else            { it = alloc Dog1114 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1114<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1114()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1114 done\n\n")
		}
	}
	

	let names1115 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1115
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1115[rand() % names1115.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1115 : Animal1115
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1115 : Dog1115
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1115<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1115()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1115 [5] {
				if i % 2 == 1   { it = alloc Dalmation1115 }
				else            { it = alloc Dog1115 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1115<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1115()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1115 done\n\n")
		}
	}
	

	let names1116 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1116
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1116[rand() % names1116.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1116 : Animal1116
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1116 : Dog1116
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1116<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1116()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1116 [5] {
				if i % 2 == 1   { it = alloc Dalmation1116 }
				else            { it = alloc Dog1116 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1116<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1116()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1116 done\n\n")
		}
	}
	

	let names1117 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1117
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1117[rand() % names1117.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1117 : Animal1117
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1117 : Dog1117
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1117<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1117()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1117 [5] {
				if i % 2 == 1   { it = alloc Dalmation1117 }
				else            { it = alloc Dog1117 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1117<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1117()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1117 done\n\n")
		}
	}
	

	let names1118 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1118
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1118[rand() % names1118.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1118 : Animal1118
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1118 : Dog1118
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1118<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1118()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1118 [5] {
				if i % 2 == 1   { it = alloc Dalmation1118 }
				else            { it = alloc Dog1118 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1118<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1118()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1118 done\n\n")
		}
	}
	

	let names1119 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1119
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1119[rand() % names1119.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1119 : Animal1119
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1119 : Dog1119
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1119<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1119()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1119 [5] {
				if i % 2 == 1   { it = alloc Dalmation1119 }
				else            { it = alloc Dog1119 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1119<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1119()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1119 done\n\n")
		}
	}
	

	let names1120 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1120
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1120[rand() % names1120.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1120 : Animal1120
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1120 : Dog1120
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1120<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1120()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1120 [5] {
				if i % 2 == 1   { it = alloc Dalmation1120 }
				else            { it = alloc Dog1120 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1120<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1120()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1120 done\n\n")
		}
	}
	

	let names1121 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1121
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1121[rand() % names1121.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1121 : Animal1121
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1121 : Dog1121
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1121<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1121()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1121 [5] {
				if i % 2 == 1   { it = alloc Dalmation1121 }
				else            { it = alloc Dog1121 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1121<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1121()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1121 done\n\n")
		}
	}
	

	let names1122 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1122
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1122[rand() % names1122.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1122 : Animal1122
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1122 : Dog1122
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1122<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1122()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1122 [5] {
				if i % 2 == 1   { it = alloc Dalmation1122 }
				else            { it = alloc Dog1122 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1122<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1122()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1122 done\n\n")
		}
	}
	

	let names1123 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1123
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1123[rand() % names1123.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1123 : Animal1123
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1123 : Dog1123
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1123<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1123()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1123 [5] {
				if i % 2 == 1   { it = alloc Dalmation1123 }
				else            { it = alloc Dog1123 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1123<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1123()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1123 done\n\n")
		}
	}
	

	let names1124 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1124
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1124[rand() % names1124.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1124 : Animal1124
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1124 : Dog1124
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1124<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1124()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1124 [5] {
				if i % 2 == 1   { it = alloc Dalmation1124 }
				else            { it = alloc Dog1124 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1124<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1124()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1124 done\n\n")
		}
	}
	

	let names1125 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1125
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1125[rand() % names1125.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1125 : Animal1125
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1125 : Dog1125
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1125<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1125()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1125 [5] {
				if i % 2 == 1   { it = alloc Dalmation1125 }
				else            { it = alloc Dog1125 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1125<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1125()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1125 done\n\n")
		}
	}
	

	let names1126 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1126
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1126[rand() % names1126.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1126 : Animal1126
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1126 : Dog1126
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1126<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1126()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1126 [5] {
				if i % 2 == 1   { it = alloc Dalmation1126 }
				else            { it = alloc Dog1126 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1126<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1126()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1126 done\n\n")
		}
	}
	

	let names1127 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1127
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1127[rand() % names1127.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1127 : Animal1127
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1127 : Dog1127
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1127<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1127()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1127 [5] {
				if i % 2 == 1   { it = alloc Dalmation1127 }
				else            { it = alloc Dog1127 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1127<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1127()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1127 done\n\n")
		}
	}
	

	let names1128 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1128
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1128[rand() % names1128.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1128 : Animal1128
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1128 : Dog1128
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1128<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1128()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1128 [5] {
				if i % 2 == 1   { it = alloc Dalmation1128 }
				else            { it = alloc Dog1128 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1128<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1128()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1128 done\n\n")
		}
	}
	

	let names1129 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1129
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1129[rand() % names1129.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1129 : Animal1129
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1129 : Dog1129
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1129<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1129()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1129 [5] {
				if i % 2 == 1   { it = alloc Dalmation1129 }
				else            { it = alloc Dog1129 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1129<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1129()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1129 done\n\n")
		}
	}
	

	let names1130 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1130
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1130[rand() % names1130.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1130 : Animal1130
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1130 : Dog1130
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1130<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1130()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1130 [5] {
				if i % 2 == 1   { it = alloc Dalmation1130 }
				else            { it = alloc Dog1130 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1130<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1130()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1130 done\n\n")
		}
	}
	

	let names1131 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1131
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1131[rand() % names1131.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1131 : Animal1131
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1131 : Dog1131
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1131<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1131()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1131 [5] {
				if i % 2 == 1   { it = alloc Dalmation1131 }
				else            { it = alloc Dog1131 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1131<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1131()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1131 done\n\n")
		}
	}
	

	let names1132 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1132
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1132[rand() % names1132.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1132 : Animal1132
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1132 : Dog1132
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1132<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1132()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1132 [5] {
				if i % 2 == 1   { it = alloc Dalmation1132 }
				else            { it = alloc Dog1132 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1132<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1132()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1132 done\n\n")
		}
	}
	

	let names1133 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1133
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1133[rand() % names1133.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1133 : Animal1133
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1133 : Dog1133
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1133<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1133()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1133 [5] {
				if i % 2 == 1   { it = alloc Dalmation1133 }
				else            { it = alloc Dog1133 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1133<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1133()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1133 done\n\n")
		}
	}
	

	let names1134 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1134
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1134[rand() % names1134.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1134 : Animal1134
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1134 : Dog1134
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1134<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1134()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1134 [5] {
				if i % 2 == 1   { it = alloc Dalmation1134 }
				else            { it = alloc Dog1134 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1134<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1134()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1134 done\n\n")
		}
	}
	

	let names1135 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1135
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1135[rand() % names1135.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1135 : Animal1135
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1135 : Dog1135
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1135<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1135()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1135 [5] {
				if i % 2 == 1   { it = alloc Dalmation1135 }
				else            { it = alloc Dog1135 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1135<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1135()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1135 done\n\n")
		}
	}
	

	let names1136 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1136
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1136[rand() % names1136.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1136 : Animal1136
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1136 : Dog1136
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1136<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1136()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1136 [5] {
				if i % 2 == 1   { it = alloc Dalmation1136 }
				else            { it = alloc Dog1136 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1136<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1136()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1136 done\n\n")
		}
	}
	

	let names1137 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1137
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1137[rand() % names1137.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1137 : Animal1137
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1137 : Dog1137
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1137<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1137()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1137 [5] {
				if i % 2 == 1   { it = alloc Dalmation1137 }
				else            { it = alloc Dog1137 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1137<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1137()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1137 done\n\n")
		}
	}
	

	let names1138 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1138
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1138[rand() % names1138.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1138 : Animal1138
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1138 : Dog1138
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1138<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1138()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1138 [5] {
				if i % 2 == 1   { it = alloc Dalmation1138 }
				else            { it = alloc Dog1138 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1138<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1138()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1138 done\n\n")
		}
	}
	

	let names1139 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1139
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1139[rand() % names1139.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1139 : Animal1139
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1139 : Dog1139
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1139<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1139()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1139 [5] {
				if i % 2 == 1   { it = alloc Dalmation1139 }
				else            { it = alloc Dog1139 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1139<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1139()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1139 done\n\n")
		}
	}
	

	let names1140 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1140
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1140[rand() % names1140.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1140 : Animal1140
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1140 : Dog1140
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1140<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1140()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1140 [5] {
				if i % 2 == 1   { it = alloc Dalmation1140 }
				else            { it = alloc Dog1140 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1140<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1140()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1140 done\n\n")
		}
	}
	

	let names1141 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1141
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1141[rand() % names1141.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1141 : Animal1141
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1141 : Dog1141
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1141<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1141()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1141 [5] {
				if i % 2 == 1   { it = alloc Dalmation1141 }
				else            { it = alloc Dog1141 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1141<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1141()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1141 done\n\n")
		}
	}
	

	let names1142 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1142
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1142[rand() % names1142.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1142 : Animal1142
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1142 : Dog1142
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1142<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1142()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1142 [5] {
				if i % 2 == 1   { it = alloc Dalmation1142 }
				else            { it = alloc Dog1142 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1142<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1142()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1142 done\n\n")
		}
	}
	

	let names1143 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1143
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1143[rand() % names1143.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1143 : Animal1143
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1143 : Dog1143
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1143<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1143()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1143 [5] {
				if i % 2 == 1   { it = alloc Dalmation1143 }
				else            { it = alloc Dog1143 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1143<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1143()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1143 done\n\n")
		}
	}
	

	let names1144 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1144
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1144[rand() % names1144.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1144 : Animal1144
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1144 : Dog1144
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1144<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1144()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1144 [5] {
				if i % 2 == 1   { it = alloc Dalmation1144 }
				else            { it = alloc Dog1144 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1144<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1144()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1144 done\n\n")
		}
	}
	

	let names1145 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1145
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1145[rand() % names1145.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1145 : Animal1145
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1145 : Dog1145
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1145<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1145()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1145 [5] {
				if i % 2 == 1   { it = alloc Dalmation1145 }
				else            { it = alloc Dog1145 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1145<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1145()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1145 done\n\n")
		}
	}
	

	let names1146 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1146
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1146[rand() % names1146.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1146 : Animal1146
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1146 : Dog1146
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1146<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1146()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1146 [5] {
				if i % 2 == 1   { it = alloc Dalmation1146 }
				else            { it = alloc Dog1146 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1146<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1146()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1146 done\n\n")
		}
	}
	

	let names1147 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1147
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1147[rand() % names1147.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1147 : Animal1147
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1147 : Dog1147
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1147<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1147()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1147 [5] {
				if i % 2 == 1   { it = alloc Dalmation1147 }
				else            { it = alloc Dog1147 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1147<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1147()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1147 done\n\n")
		}
	}
	

	let names1148 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1148
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1148[rand() % names1148.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1148 : Animal1148
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1148 : Dog1148
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1148<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1148()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1148 [5] {
				if i % 2 == 1   { it = alloc Dalmation1148 }
				else            { it = alloc Dog1148 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1148<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1148()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1148 done\n\n")
		}
	}
	

	let names1149 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1149
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1149[rand() % names1149.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1149 : Animal1149
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1149 : Dog1149
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1149<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1149()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1149 [5] {
				if i % 2 == 1   { it = alloc Dalmation1149 }
				else            { it = alloc Dog1149 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1149<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1149()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1149 done\n\n")
		}
	}
	

	let names1150 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1150
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1150[rand() % names1150.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1150 : Animal1150
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1150 : Dog1150
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1150<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1150()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1150 [5] {
				if i % 2 == 1   { it = alloc Dalmation1150 }
				else            { it = alloc Dog1150 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1150<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1150()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1150 done\n\n")
		}
	}
	

	let names1151 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1151
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1151[rand() % names1151.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1151 : Animal1151
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1151 : Dog1151
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1151<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1151()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1151 [5] {
				if i % 2 == 1   { it = alloc Dalmation1151 }
				else            { it = alloc Dog1151 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1151<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1151()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1151 done\n\n")
		}
	}
	

	let names1152 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1152
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1152[rand() % names1152.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1152 : Animal1152
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1152 : Dog1152
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1152<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1152()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1152 [5] {
				if i % 2 == 1   { it = alloc Dalmation1152 }
				else            { it = alloc Dog1152 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1152<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1152()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1152 done\n\n")
		}
	}
	

	let names1153 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1153
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1153[rand() % names1153.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1153 : Animal1153
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1153 : Dog1153
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1153<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1153()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1153 [5] {
				if i % 2 == 1   { it = alloc Dalmation1153 }
				else            { it = alloc Dog1153 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1153<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1153()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1153 done\n\n")
		}
	}
	

	let names1154 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1154
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1154[rand() % names1154.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1154 : Animal1154
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1154 : Dog1154
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1154<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1154()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1154 [5] {
				if i % 2 == 1   { it = alloc Dalmation1154 }
				else            { it = alloc Dog1154 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1154<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1154()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1154 done\n\n")
		}
	}
	

	let names1155 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1155
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1155[rand() % names1155.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1155 : Animal1155
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1155 : Dog1155
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1155<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1155()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1155 [5] {
				if i % 2 == 1   { it = alloc Dalmation1155 }
				else            { it = alloc Dog1155 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1155<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1155()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1155 done\n\n")
		}
	}
	

	let names1156 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1156
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1156[rand() % names1156.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1156 : Animal1156
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1156 : Dog1156
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1156<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1156()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1156 [5] {
				if i % 2 == 1   { it = alloc Dalmation1156 }
				else            { it = alloc Dog1156 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1156<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1156()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1156 done\n\n")
		}
	}
	

	let names1157 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1157
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1157[rand() % names1157.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1157 : Animal1157
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1157 : Dog1157
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1157<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1157()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1157 [5] {
				if i % 2 == 1   { it = alloc Dalmation1157 }
				else            { it = alloc Dog1157 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1157<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1157()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1157 done\n\n")
		}
	}
	

	let names1158 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1158
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1158[rand() % names1158.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1158 : Animal1158
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1158 : Dog1158
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1158<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1158()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1158 [5] {
				if i % 2 == 1   { it = alloc Dalmation1158 }
				else            { it = alloc Dog1158 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1158<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1158()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1158 done\n\n")
		}
	}
	

	let names1159 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1159
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1159[rand() % names1159.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1159 : Animal1159
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1159 : Dog1159
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1159<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1159()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1159 [5] {
				if i % 2 == 1   { it = alloc Dalmation1159 }
				else            { it = alloc Dog1159 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1159<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1159()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1159 done\n\n")
		}
	}
	

	let names1160 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1160
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1160[rand() % names1160.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1160 : Animal1160
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1160 : Dog1160
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1160<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1160()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1160 [5] {
				if i % 2 == 1   { it = alloc Dalmation1160 }
				else            { it = alloc Dog1160 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1160<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1160()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1160 done\n\n")
		}
	}
	

	let names1161 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1161
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1161[rand() % names1161.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1161 : Animal1161
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1161 : Dog1161
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1161<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1161()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1161 [5] {
				if i % 2 == 1   { it = alloc Dalmation1161 }
				else            { it = alloc Dog1161 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1161<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1161()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1161 done\n\n")
		}
	}
	

	let names1162 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1162
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1162[rand() % names1162.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1162 : Animal1162
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1162 : Dog1162
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1162<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1162()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1162 [5] {
				if i % 2 == 1   { it = alloc Dalmation1162 }
				else            { it = alloc Dog1162 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1162<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1162()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1162 done\n\n")
		}
	}
	

	let names1163 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1163
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1163[rand() % names1163.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1163 : Animal1163
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1163 : Dog1163
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1163<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1163()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1163 [5] {
				if i % 2 == 1   { it = alloc Dalmation1163 }
				else            { it = alloc Dog1163 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1163<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1163()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1163 done\n\n")
		}
	}
	

	let names1164 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1164
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1164[rand() % names1164.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1164 : Animal1164
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1164 : Dog1164
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1164<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1164()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1164 [5] {
				if i % 2 == 1   { it = alloc Dalmation1164 }
				else            { it = alloc Dog1164 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1164<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1164()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1164 done\n\n")
		}
	}
	

	let names1165 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1165
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1165[rand() % names1165.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1165 : Animal1165
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1165 : Dog1165
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1165<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1165()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1165 [5] {
				if i % 2 == 1   { it = alloc Dalmation1165 }
				else            { it = alloc Dog1165 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1165<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1165()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1165 done\n\n")
		}
	}
	

	let names1166 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1166
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1166[rand() % names1166.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1166 : Animal1166
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1166 : Dog1166
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1166<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1166()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1166 [5] {
				if i % 2 == 1   { it = alloc Dalmation1166 }
				else            { it = alloc Dog1166 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1166<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1166()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1166 done\n\n")
		}
	}
	

	let names1167 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1167
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1167[rand() % names1167.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1167 : Animal1167
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1167 : Dog1167
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1167<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1167()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1167 [5] {
				if i % 2 == 1   { it = alloc Dalmation1167 }
				else            { it = alloc Dog1167 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1167<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1167()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1167 done\n\n")
		}
	}
	

	let names1168 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1168
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1168[rand() % names1168.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1168 : Animal1168
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1168 : Dog1168
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1168<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1168()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1168 [5] {
				if i % 2 == 1   { it = alloc Dalmation1168 }
				else            { it = alloc Dog1168 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1168<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1168()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1168 done\n\n")
		}
	}
	

	let names1169 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1169
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1169[rand() % names1169.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1169 : Animal1169
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1169 : Dog1169
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1169<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1169()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1169 [5] {
				if i % 2 == 1   { it = alloc Dalmation1169 }
				else            { it = alloc Dog1169 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1169<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1169()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1169 done\n\n")
		}
	}
	

	let names1170 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1170
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1170[rand() % names1170.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1170 : Animal1170
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1170 : Dog1170
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1170<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1170()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1170 [5] {
				if i % 2 == 1   { it = alloc Dalmation1170 }
				else            { it = alloc Dog1170 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1170<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1170()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1170 done\n\n")
		}
	}
	

	let names1171 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1171
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1171[rand() % names1171.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1171 : Animal1171
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1171 : Dog1171
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1171<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1171()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1171 [5] {
				if i % 2 == 1   { it = alloc Dalmation1171 }
				else            { it = alloc Dog1171 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1171<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1171()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1171 done\n\n")
		}
	}
	

	let names1172 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1172
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1172[rand() % names1172.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1172 : Animal1172
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1172 : Dog1172
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1172<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1172()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1172 [5] {
				if i % 2 == 1   { it = alloc Dalmation1172 }
				else            { it = alloc Dog1172 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1172<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1172()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1172 done\n\n")
		}
	}
	

	let names1173 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1173
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1173[rand() % names1173.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1173 : Animal1173
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1173 : Dog1173
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1173<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1173()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1173 [5] {
				if i % 2 == 1   { it = alloc Dalmation1173 }
				else            { it = alloc Dog1173 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1173<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1173()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1173 done\n\n")
		}
	}
	

	let names1174 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1174
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1174[rand() % names1174.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1174 : Animal1174
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1174 : Dog1174
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1174<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1174()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1174 [5] {
				if i % 2 == 1   { it = alloc Dalmation1174 }
				else            { it = alloc Dog1174 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1174<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1174()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1174 done\n\n")
		}
	}
	

	let names1175 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1175
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1175[rand() % names1175.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1175 : Animal1175
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1175 : Dog1175
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1175<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1175()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1175 [5] {
				if i % 2 == 1   { it = alloc Dalmation1175 }
				else            { it = alloc Dog1175 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1175<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1175()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1175 done\n\n")
		}
	}
	

	let names1176 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1176
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1176[rand() % names1176.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1176 : Animal1176
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1176 : Dog1176
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1176<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1176()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1176 [5] {
				if i % 2 == 1   { it = alloc Dalmation1176 }
				else            { it = alloc Dog1176 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1176<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1176()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1176 done\n\n")
		}
	}
	

	let names1177 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1177
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1177[rand() % names1177.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1177 : Animal1177
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1177 : Dog1177
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1177<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1177()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1177 [5] {
				if i % 2 == 1   { it = alloc Dalmation1177 }
				else            { it = alloc Dog1177 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1177<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1177()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1177 done\n\n")
		}
	}
	

	let names1178 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1178
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1178[rand() % names1178.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1178 : Animal1178
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1178 : Dog1178
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1178<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1178()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1178 [5] {
				if i % 2 == 1   { it = alloc Dalmation1178 }
				else            { it = alloc Dog1178 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1178<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1178()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1178 done\n\n")
		}
	}
	

	let names1179 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1179
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1179[rand() % names1179.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1179 : Animal1179
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1179 : Dog1179
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1179<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1179()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1179 [5] {
				if i % 2 == 1   { it = alloc Dalmation1179 }
				else            { it = alloc Dog1179 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1179<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1179()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1179 done\n\n")
		}
	}
	

	let names1180 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1180
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1180[rand() % names1180.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1180 : Animal1180
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1180 : Dog1180
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1180<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1180()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1180 [5] {
				if i % 2 == 1   { it = alloc Dalmation1180 }
				else            { it = alloc Dog1180 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1180<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1180()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1180 done\n\n")
		}
	}
	

	let names1181 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1181
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1181[rand() % names1181.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1181 : Animal1181
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1181 : Dog1181
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1181<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1181()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1181 [5] {
				if i % 2 == 1   { it = alloc Dalmation1181 }
				else            { it = alloc Dog1181 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1181<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1181()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1181 done\n\n")
		}
	}
	

	let names1182 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1182
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1182[rand() % names1182.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1182 : Animal1182
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1182 : Dog1182
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1182<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1182()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1182 [5] {
				if i % 2 == 1   { it = alloc Dalmation1182 }
				else            { it = alloc Dog1182 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1182<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1182()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1182 done\n\n")
		}
	}
	

	let names1183 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1183
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1183[rand() % names1183.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1183 : Animal1183
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1183 : Dog1183
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1183<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1183()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1183 [5] {
				if i % 2 == 1   { it = alloc Dalmation1183 }
				else            { it = alloc Dog1183 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1183<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1183()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1183 done\n\n")
		}
	}
	

	let names1184 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1184
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1184[rand() % names1184.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1184 : Animal1184
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1184 : Dog1184
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1184<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1184()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1184 [5] {
				if i % 2 == 1   { it = alloc Dalmation1184 }
				else            { it = alloc Dog1184 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1184<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1184()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1184 done\n\n")
		}
	}
	

	let names1185 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1185
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1185[rand() % names1185.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1185 : Animal1185
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1185 : Dog1185
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1185<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1185()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1185 [5] {
				if i % 2 == 1   { it = alloc Dalmation1185 }
				else            { it = alloc Dog1185 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1185<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1185()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1185 done\n\n")
		}
	}
	

	let names1186 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1186
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1186[rand() % names1186.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1186 : Animal1186
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1186 : Dog1186
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1186<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1186()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1186 [5] {
				if i % 2 == 1   { it = alloc Dalmation1186 }
				else            { it = alloc Dog1186 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1186<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1186()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1186 done\n\n")
		}
	}
	

	let names1187 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1187
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1187[rand() % names1187.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1187 : Animal1187
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1187 : Dog1187
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1187<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1187()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1187 [5] {
				if i % 2 == 1   { it = alloc Dalmation1187 }
				else            { it = alloc Dog1187 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1187<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1187()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1187 done\n\n")
		}
	}
	

	let names1188 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1188
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1188[rand() % names1188.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1188 : Animal1188
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1188 : Dog1188
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1188<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1188()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1188 [5] {
				if i % 2 == 1   { it = alloc Dalmation1188 }
				else            { it = alloc Dog1188 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1188<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1188()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1188 done\n\n")
		}
	}
	

	let names1189 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1189
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1189[rand() % names1189.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1189 : Animal1189
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1189 : Dog1189
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1189<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1189()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1189 [5] {
				if i % 2 == 1   { it = alloc Dalmation1189 }
				else            { it = alloc Dog1189 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1189<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1189()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1189 done\n\n")
		}
	}
	

	let names1190 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1190
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1190[rand() % names1190.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1190 : Animal1190
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1190 : Dog1190
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1190<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1190()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1190 [5] {
				if i % 2 == 1   { it = alloc Dalmation1190 }
				else            { it = alloc Dog1190 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1190<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1190()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1190 done\n\n")
		}
	}
	

	let names1191 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1191
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1191[rand() % names1191.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1191 : Animal1191
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1191 : Dog1191
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1191<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1191()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1191 [5] {
				if i % 2 == 1   { it = alloc Dalmation1191 }
				else            { it = alloc Dog1191 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1191<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1191()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1191 done\n\n")
		}
	}
	

	let names1192 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1192
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1192[rand() % names1192.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1192 : Animal1192
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1192 : Dog1192
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1192<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1192()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1192 [5] {
				if i % 2 == 1   { it = alloc Dalmation1192 }
				else            { it = alloc Dog1192 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1192<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1192()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1192 done\n\n")
		}
	}
	

	let names1193 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1193
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1193[rand() % names1193.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1193 : Animal1193
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1193 : Dog1193
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1193<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1193()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1193 [5] {
				if i % 2 == 1   { it = alloc Dalmation1193 }
				else            { it = alloc Dog1193 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1193<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1193()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1193 done\n\n")
		}
	}
	

	let names1194 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1194
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1194[rand() % names1194.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1194 : Animal1194
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1194 : Dog1194
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1194<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1194()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1194 [5] {
				if i % 2 == 1   { it = alloc Dalmation1194 }
				else            { it = alloc Dog1194 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1194<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1194()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1194 done\n\n")
		}
	}
	

	let names1195 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1195
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1195[rand() % names1195.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1195 : Animal1195
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1195 : Dog1195
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1195<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1195()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1195 [5] {
				if i % 2 == 1   { it = alloc Dalmation1195 }
				else            { it = alloc Dog1195 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1195<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1195()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1195 done\n\n")
		}
	}
	

	let names1196 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1196
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1196[rand() % names1196.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1196 : Animal1196
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1196 : Dog1196
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1196<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1196()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1196 [5] {
				if i % 2 == 1   { it = alloc Dalmation1196 }
				else            { it = alloc Dog1196 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1196<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1196()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1196 done\n\n")
		}
	}
	

	let names1197 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1197
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1197[rand() % names1197.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1197 : Animal1197
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1197 : Dog1197
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1197<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1197()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1197 [5] {
				if i % 2 == 1   { it = alloc Dalmation1197 }
				else            { it = alloc Dog1197 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1197<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1197()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1197 done\n\n")
		}
	}
	

	let names1198 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1198
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1198[rand() % names1198.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1198 : Animal1198
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1198 : Dog1198
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1198<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1198()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1198 [5] {
				if i % 2 == 1   { it = alloc Dalmation1198 }
				else            { it = alloc Dog1198 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1198<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1198()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1198 done\n\n")
		}
	}
	

	let names1199 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1199
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1199[rand() % names1199.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1199 : Animal1199
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1199 : Dog1199
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1199<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1199()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1199 [5] {
				if i % 2 == 1   { it = alloc Dalmation1199 }
				else            { it = alloc Dog1199 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1199<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1199()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1199 done\n\n")
		}
	}
	

	let names1200 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1200
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1200[rand() % names1200.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1200 : Animal1200
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1200 : Dog1200
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1200<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1200()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1200 [5] {
				if i % 2 == 1   { it = alloc Dalmation1200 }
				else            { it = alloc Dog1200 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1200<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1200()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1200 done\n\n")
		}
	}
	

	let names1201 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1201
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1201[rand() % names1201.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1201 : Animal1201
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1201 : Dog1201
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1201<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1201()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1201 [5] {
				if i % 2 == 1   { it = alloc Dalmation1201 }
				else            { it = alloc Dog1201 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1201<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1201()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1201 done\n\n")
		}
	}
	

	let names1202 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1202
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1202[rand() % names1202.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1202 : Animal1202
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1202 : Dog1202
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1202<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1202()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1202 [5] {
				if i % 2 == 1   { it = alloc Dalmation1202 }
				else            { it = alloc Dog1202 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1202<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1202()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1202 done\n\n")
		}
	}
	

	let names1203 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1203
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1203[rand() % names1203.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1203 : Animal1203
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1203 : Dog1203
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1203<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1203()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1203 [5] {
				if i % 2 == 1   { it = alloc Dalmation1203 }
				else            { it = alloc Dog1203 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1203<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1203()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1203 done\n\n")
		}
	}
	

	let names1204 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1204
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1204[rand() % names1204.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1204 : Animal1204
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1204 : Dog1204
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1204<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1204()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1204 [5] {
				if i % 2 == 1   { it = alloc Dalmation1204 }
				else            { it = alloc Dog1204 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1204<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1204()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1204 done\n\n")
		}
	}
	

	let names1205 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1205
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1205[rand() % names1205.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1205 : Animal1205
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1205 : Dog1205
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1205<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1205()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1205 [5] {
				if i % 2 == 1   { it = alloc Dalmation1205 }
				else            { it = alloc Dog1205 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1205<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1205()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1205 done\n\n")
		}
	}
	

	let names1206 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1206
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1206[rand() % names1206.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1206 : Animal1206
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1206 : Dog1206
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1206<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1206()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1206 [5] {
				if i % 2 == 1   { it = alloc Dalmation1206 }
				else            { it = alloc Dog1206 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1206<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1206()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1206 done\n\n")
		}
	}
	

	let names1207 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1207
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1207[rand() % names1207.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1207 : Animal1207
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1207 : Dog1207
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1207<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1207()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1207 [5] {
				if i % 2 == 1   { it = alloc Dalmation1207 }
				else            { it = alloc Dog1207 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1207<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1207()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1207 done\n\n")
		}
	}
	

	let names1208 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1208
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1208[rand() % names1208.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1208 : Animal1208
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1208 : Dog1208
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1208<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1208()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1208 [5] {
				if i % 2 == 1   { it = alloc Dalmation1208 }
				else            { it = alloc Dog1208 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1208<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1208()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1208 done\n\n")
		}
	}
	

	let names1209 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1209
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1209[rand() % names1209.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1209 : Animal1209
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1209 : Dog1209
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1209<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1209()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1209 [5] {
				if i % 2 == 1   { it = alloc Dalmation1209 }
				else            { it = alloc Dog1209 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1209<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1209()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1209 done\n\n")
		}
	}
	

	let names1210 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1210
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1210[rand() % names1210.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1210 : Animal1210
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1210 : Dog1210
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1210<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1210()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1210 [5] {
				if i % 2 == 1   { it = alloc Dalmation1210 }
				else            { it = alloc Dog1210 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1210<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1210()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1210 done\n\n")
		}
	}
	

	let names1211 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1211
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1211[rand() % names1211.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1211 : Animal1211
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1211 : Dog1211
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1211<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1211()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1211 [5] {
				if i % 2 == 1   { it = alloc Dalmation1211 }
				else            { it = alloc Dog1211 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1211<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1211()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1211 done\n\n")
		}
	}
	

	let names1212 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1212
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1212[rand() % names1212.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1212 : Animal1212
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1212 : Dog1212
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1212<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1212()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1212 [5] {
				if i % 2 == 1   { it = alloc Dalmation1212 }
				else            { it = alloc Dog1212 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1212<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1212()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1212 done\n\n")
		}
	}
	

	let names1213 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1213
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1213[rand() % names1213.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1213 : Animal1213
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1213 : Dog1213
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1213<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1213()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1213 [5] {
				if i % 2 == 1   { it = alloc Dalmation1213 }
				else            { it = alloc Dog1213 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1213<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1213()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1213 done\n\n")
		}
	}
	

	let names1214 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1214
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1214[rand() % names1214.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1214 : Animal1214
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1214 : Dog1214
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1214<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1214()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1214 [5] {
				if i % 2 == 1   { it = alloc Dalmation1214 }
				else            { it = alloc Dog1214 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1214<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1214()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1214 done\n\n")
		}
	}
	

	let names1215 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

	class Animal1215
	{
		init(w: f64)
		{
			// printf("make animal w = %f\n", w)
			weight = w
			name = names1215[rand() % names1215.length]
		}

		virtual fn makeNoise()
		{
			printf("some generic sound\n")
		}

		var name: str
		var weight: f64
		var cute: bool = true
	}

	class Dog1215 : Animal1215
	{
		init() : super(w: 300)
		{
			// printf("make dog (w = %f)\n", weight)
		}

		override fn makeNoise()
		{
			printf("bark bark (%f)\n", weight)
		}

		virtual fn wag()
		{
			printf("wagging tail of length %d\n", tail)
		}

		var tail: int = 37
	}

	class Dalmation1215 : Dog1215
	{
		init() : super()
		{
			printf("make dalmation\n")
		}

		override fn wag()
		{
			printf("dalmation wags %d\n", tail)
		}

		var numSpots: int
	}


	class LinkedList1215<T>
	{
		struct Node
		{
			var data: T

			var prev: &Node
			var next: &Node
		}

		var head: &Node
		var tail: &Node

		var count: int

		init()
		{
		}

		mut fn insert(thing: T)
		{
			var nn = alloc mut Node (data: thing, prev: null, next: null)

			if head == null { head = nn; tail = nn }
			else
			{
				var ot = tail as mut
				tail = nn

				nn.prev = ot
				ot.next = nn
			}

			count += 1
		}

		static fn hello() -> T { printf("hi\n"); return 10 }
	}




	fn stuff1215()
	{
		do {
			// don't question.
			srand(284811)

			// fn test() -> f64 { printf("hi\n"); return 31.51 }

			let dogs = alloc &Dog1215 [5] {
				if i % 2 == 1   { it = alloc Dalmation1215 }
				else            { it = alloc Dog1215 }
			}

			for dog, i in dogs {
				printf("%d: %s - ", i, dog.name)
				dog.wag()
			}
		}


		do {
			var list: LinkedList1215<T: int>

			list.insert(10)
			list.insert(20)
			list.insert(30)
			list.insert(40)

			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}
	}

	fn genericstuff1215()
	{
		do {
			fn gincr<A>(x: A) -> A => x + 1
			fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

			fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
			{
				var i = 0
				var ret: [F]
				while i < arr.length
				{
					ret.append(fa(arr[i], f))
					i += 1
				}

				return ret
			}

			printf("set 4:")
			let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
			for it in new { printf(" %d", it) }

			printf("\n")
		}


		do {

			fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
			{
				var i = 0
				var ret: [R]
				while i < arr.length
				{
					ret.append(f(arr[i].0, arr[i].1))
					i += 1
				}

				return ret
			}


			fn add2<A, B>(x: A, y: B) -> A => x + y


			printf("set 5:")
			let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
			for it in new { printf(" %d", it) }

			printf("\nset 1215 done\n\n")
		}
	}
	
@entry fn main() -> i32 {
	stuff0()
	genericstuff0()
	stuff1()
	genericstuff1()
	stuff2()
	genericstuff2()
	stuff3()
	genericstuff3()
	stuff4()
	genericstuff4()
	stuff5()
	genericstuff5()
	stuff6()
	genericstuff6()
	stuff7()
	genericstuff7()
	stuff8()
	genericstuff8()
	stuff9()
	genericstuff9()
	stuff10()
	genericstuff10()
	stuff11()
	genericstuff11()
	stuff12()
	genericstuff12()
	stuff13()
	genericstuff13()
	stuff14()
	genericstuff14()
	stuff15()
	genericstuff15()
	stuff16()
	genericstuff16()
	stuff17()
	genericstuff17()
	stuff18()
	genericstuff18()
	stuff19()
	genericstuff19()
	stuff20()
	genericstuff20()
	stuff21()
	genericstuff21()
	stuff22()
	genericstuff22()
	stuff23()
	genericstuff23()
	stuff24()
	genericstuff24()
	stuff25()
	genericstuff25()
	stuff26()
	genericstuff26()
	stuff27()
	genericstuff27()
	stuff28()
	genericstuff28()
	stuff29()
	genericstuff29()
	stuff30()
	genericstuff30()
	stuff31()
	genericstuff31()
	stuff32()
	genericstuff32()
	stuff33()
	genericstuff33()
	stuff34()
	genericstuff34()
	stuff35()
	genericstuff35()
	stuff36()
	genericstuff36()
	stuff37()
	genericstuff37()
	stuff38()
	genericstuff38()
	stuff39()
	genericstuff39()
	stuff40()
	genericstuff40()
	stuff41()
	genericstuff41()
	stuff42()
	genericstuff42()
	stuff43()
	genericstuff43()
	stuff44()
	genericstuff44()
	stuff45()
	genericstuff45()
	stuff46()
	genericstuff46()
	stuff47()
	genericstuff47()
	stuff48()
	genericstuff48()
	stuff49()
	genericstuff49()
	stuff50()
	genericstuff50()
	stuff51()
	genericstuff51()
	stuff52()
	genericstuff52()
	stuff53()
	genericstuff53()
	stuff54()
	genericstuff54()
	stuff55()
	genericstuff55()
	stuff56()
	genericstuff56()
	stuff57()
	genericstuff57()
	stuff58()
	genericstuff58()
	stuff59()
	genericstuff59()
	stuff60()
	genericstuff60()
	stuff61()
	genericstuff61()
	stuff62()
	genericstuff62()
	stuff63()
	genericstuff63()
	stuff64()
	genericstuff64()
	stuff65()
	genericstuff65()
	stuff66()
	genericstuff66()
	stuff67()
	genericstuff67()
	stuff68()
	genericstuff68()
	stuff69()
	genericstuff69()
	stuff70()
	genericstuff70()
	stuff71()
	genericstuff71()
	stuff72()
	genericstuff72()
	stuff73()
	genericstuff73()
	stuff74()
	genericstuff74()
	stuff75()
	genericstuff75()
	stuff76()
	genericstuff76()
	stuff77()
	genericstuff77()
	stuff78()
	genericstuff78()
	stuff79()
	genericstuff79()
	stuff80()
	genericstuff80()
	stuff81()
	genericstuff81()
	stuff82()
	genericstuff82()
	stuff83()
	genericstuff83()
	stuff84()
	genericstuff84()
	stuff85()
	genericstuff85()
	stuff86()
	genericstuff86()
	stuff87()
	genericstuff87()
	stuff88()
	genericstuff88()
	stuff89()
	genericstuff89()
	stuff90()
	genericstuff90()
	stuff91()
	genericstuff91()
	stuff92()
	genericstuff92()
	stuff93()
	genericstuff93()
	stuff94()
	genericstuff94()
	stuff95()
	genericstuff95()
	stuff96()
	genericstuff96()
	stuff97()
	genericstuff97()
	stuff98()
	genericstuff98()
	stuff99()
	genericstuff99()
	stuff100()
	genericstuff100()
	stuff101()
	genericstuff101()
	stuff102()
	genericstuff102()
	stuff103()
	genericstuff103()
	stuff104()
	genericstuff104()
	stuff105()
	genericstuff105()
	stuff106()
	genericstuff106()
	stuff107()
	genericstuff107()
	stuff108()
	genericstuff108()
	stuff109()
	genericstuff109()
	stuff110()
	genericstuff110()
	stuff111()
	genericstuff111()
	stuff112()
	genericstuff112()
	stuff113()
	genericstuff113()
	stuff114()
	genericstuff114()
	stuff115()
	genericstuff115()
	stuff116()
	genericstuff116()
	stuff117()
	genericstuff117()
	stuff118()
	genericstuff118()
	stuff119()
	genericstuff119()
	stuff120()
	genericstuff120()
	stuff121()
	genericstuff121()
	stuff122()
	genericstuff122()
	stuff123()
	genericstuff123()
	stuff124()
	genericstuff124()
	stuff125()
	genericstuff125()
	stuff126()
	genericstuff126()
	stuff127()
	genericstuff127()
	stuff128()
	genericstuff128()
	stuff129()
	genericstuff129()
	stuff130()
	genericstuff130()
	stuff131()
	genericstuff131()
	stuff132()
	genericstuff132()
	stuff133()
	genericstuff133()
	stuff134()
	genericstuff134()
	stuff135()
	genericstuff135()
	stuff136()
	genericstuff136()
	stuff137()
	genericstuff137()
	stuff138()
	genericstuff138()
	stuff139()
	genericstuff139()
	stuff140()
	genericstuff140()
	stuff141()
	genericstuff141()
	stuff142()
	genericstuff142()
	stuff143()
	genericstuff143()
	stuff144()
	genericstuff144()
	stuff145()
	genericstuff145()
	stuff146()
	genericstuff146()
	stuff147()
	genericstuff147()
	stuff148()
	genericstuff148()
	stuff149()
	genericstuff149()
	stuff150()
	genericstuff150()
	stuff151()
	genericstuff151()
	stuff152()
	genericstuff152()
	stuff153()
	genericstuff153()
	stuff154()
	genericstuff154()
	stuff155()
	genericstuff155()
	stuff156()
	genericstuff156()
	stuff157()
	genericstuff157()
	stuff158()
	genericstuff158()
	stuff159()
	genericstuff159()
	stuff160()
	genericstuff160()
	stuff161()
	genericstuff161()
	stuff162()
	genericstuff162()
	stuff163()
	genericstuff163()
	stuff164()
	genericstuff164()
	stuff165()
	genericstuff165()
	stuff166()
	genericstuff166()
	stuff167()
	genericstuff167()
	stuff168()
	genericstuff168()
	stuff169()
	genericstuff169()
	stuff170()
	genericstuff170()
	stuff171()
	genericstuff171()
	stuff172()
	genericstuff172()
	stuff173()
	genericstuff173()
	stuff174()
	genericstuff174()
	stuff175()
	genericstuff175()
	stuff176()
	genericstuff176()
	stuff177()
	genericstuff177()
	stuff178()
	genericstuff178()
	stuff179()
	genericstuff179()
	stuff180()
	genericstuff180()
	stuff181()
	genericstuff181()
	stuff182()
	genericstuff182()
	stuff183()
	genericstuff183()
	stuff184()
	genericstuff184()
	stuff185()
	genericstuff185()
	stuff186()
	genericstuff186()
	stuff187()
	genericstuff187()
	stuff188()
	genericstuff188()
	stuff189()
	genericstuff189()
	stuff190()
	genericstuff190()
	stuff191()
	genericstuff191()
	stuff192()
	genericstuff192()
	stuff193()
	genericstuff193()
	stuff194()
	genericstuff194()
	stuff195()
	genericstuff195()
	stuff196()
	genericstuff196()
	stuff197()
	genericstuff197()
	stuff198()
	genericstuff198()
	stuff199()
	genericstuff199()
	stuff200()
	genericstuff200()
	stuff201()
	genericstuff201()
	stuff202()
	genericstuff202()
	stuff203()
	genericstuff203()
	stuff204()
	genericstuff204()
	stuff205()
	genericstuff205()
	stuff206()
	genericstuff206()
	stuff207()
	genericstuff207()
	stuff208()
	genericstuff208()
	stuff209()
	genericstuff209()
	stuff210()
	genericstuff210()
	stuff211()
	genericstuff211()
	stuff212()
	genericstuff212()
	stuff213()
	genericstuff213()
	stuff214()
	genericstuff214()
	stuff215()
	genericstuff215()
	stuff216()
	genericstuff216()
	stuff217()
	genericstuff217()
	stuff218()
	genericstuff218()
	stuff219()
	genericstuff219()
	stuff220()
	genericstuff220()
	stuff221()
	genericstuff221()
	stuff222()
	genericstuff222()
	stuff223()
	genericstuff223()
	stuff224()
	genericstuff224()
	stuff225()
	genericstuff225()
	stuff226()
	genericstuff226()
	stuff227()
	genericstuff227()
	stuff228()
	genericstuff228()
	stuff229()
	genericstuff229()
	stuff230()
	genericstuff230()
	stuff231()
	genericstuff231()
	stuff232()
	genericstuff232()
	stuff233()
	genericstuff233()
	stuff234()
	genericstuff234()
	stuff235()
	genericstuff235()
	stuff236()
	genericstuff236()
	stuff237()
	genericstuff237()
	stuff238()
	genericstuff238()
	stuff239()
	genericstuff239()
	stuff240()
	genericstuff240()
	stuff241()
	genericstuff241()
	stuff242()
	genericstuff242()
	stuff243()
	genericstuff243()
	stuff244()
	genericstuff244()
	stuff245()
	genericstuff245()
	stuff246()
	genericstuff246()
	stuff247()
	genericstuff247()
	stuff248()
	genericstuff248()
	stuff249()
	genericstuff249()
	stuff250()
	genericstuff250()
	stuff251()
	genericstuff251()
	stuff252()
	genericstuff252()
	stuff253()
	genericstuff253()
	stuff254()
	genericstuff254()
	stuff255()
	genericstuff255()
	stuff256()
	genericstuff256()
	stuff257()
	genericstuff257()
	stuff258()
	genericstuff258()
	stuff259()
	genericstuff259()
	stuff260()
	genericstuff260()
	stuff261()
	genericstuff261()
	stuff262()
	genericstuff262()
	stuff263()
	genericstuff263()
	stuff264()
	genericstuff264()
	stuff265()
	genericstuff265()
	stuff266()
	genericstuff266()
	stuff267()
	genericstuff267()
	stuff268()
	genericstuff268()
	stuff269()
	genericstuff269()
	stuff270()
	genericstuff270()
	stuff271()
	genericstuff271()
	stuff272()
	genericstuff272()
	stuff273()
	genericstuff273()
	stuff274()
	genericstuff274()
	stuff275()
	genericstuff275()
	stuff276()
	genericstuff276()
	stuff277()
	genericstuff277()
	stuff278()
	genericstuff278()
	stuff279()
	genericstuff279()
	stuff280()
	genericstuff280()
	stuff281()
	genericstuff281()
	stuff282()
	genericstuff282()
	stuff283()
	genericstuff283()
	stuff284()
	genericstuff284()
	stuff285()
	genericstuff285()
	stuff286()
	genericstuff286()
	stuff287()
	genericstuff287()
	stuff288()
	genericstuff288()
	stuff289()
	genericstuff289()
	stuff290()
	genericstuff290()
	stuff291()
	genericstuff291()
	stuff292()
	genericstuff292()
	stuff293()
	genericstuff293()
	stuff294()
	genericstuff294()
	stuff295()
	genericstuff295()
	stuff296()
	genericstuff296()
	stuff297()
	genericstuff297()
	stuff298()
	genericstuff298()
	stuff299()
	genericstuff299()
	stuff300()
	genericstuff300()
	stuff301()
	genericstuff301()
	stuff302()
	genericstuff302()
	stuff303()
	genericstuff303()
	stuff304()
	genericstuff304()
	stuff305()
	genericstuff305()
	stuff306()
	genericstuff306()
	stuff307()
	genericstuff307()
	stuff308()
	genericstuff308()
	stuff309()
	genericstuff309()
	stuff310()
	genericstuff310()
	stuff311()
	genericstuff311()
	stuff312()
	genericstuff312()
	stuff313()
	genericstuff313()
	stuff314()
	genericstuff314()
	stuff315()
	genericstuff315()
	stuff316()
	genericstuff316()
	stuff317()
	genericstuff317()
	stuff318()
	genericstuff318()
	stuff319()
	genericstuff319()
	stuff320()
	genericstuff320()
	stuff321()
	genericstuff321()
	stuff322()
	genericstuff322()
	stuff323()
	genericstuff323()
	stuff324()
	genericstuff324()
	stuff325()
	genericstuff325()
	stuff326()
	genericstuff326()
	stuff327()
	genericstuff327()
	stuff328()
	genericstuff328()
	stuff329()
	genericstuff329()
	stuff330()
	genericstuff330()
	stuff331()
	genericstuff331()
	stuff332()
	genericstuff332()
	stuff333()
	genericstuff333()
	stuff334()
	genericstuff334()
	stuff335()
	genericstuff335()
	stuff336()
	genericstuff336()
	stuff337()
	genericstuff337()
	stuff338()
	genericstuff338()
	stuff339()
	genericstuff339()
	stuff340()
	genericstuff340()
	stuff341()
	genericstuff341()
	stuff342()
	genericstuff342()
	stuff343()
	genericstuff343()
	stuff344()
	genericstuff344()
	stuff345()
	genericstuff345()
	stuff346()
	genericstuff346()
	stuff347()
	genericstuff347()
	stuff348()
	genericstuff348()
	stuff349()
	genericstuff349()
	stuff350()
	genericstuff350()
	stuff351()
	genericstuff351()
	stuff352()
	genericstuff352()
	stuff353()
	genericstuff353()
	stuff354()
	genericstuff354()
	stuff355()
	genericstuff355()
	stuff356()
	genericstuff356()
	stuff357()
	genericstuff357()
	stuff358()
	genericstuff358()
	stuff359()
	genericstuff359()
	stuff360()
	genericstuff360()
	stuff361()
	genericstuff361()
	stuff362()
	genericstuff362()
	stuff363()
	genericstuff363()
	stuff364()
	genericstuff364()
	stuff365()
	genericstuff365()
	stuff366()
	genericstuff366()
	stuff367()
	genericstuff367()
	stuff368()
	genericstuff368()
	stuff369()
	genericstuff369()
	stuff370()
	genericstuff370()
	stuff371()
	genericstuff371()
	stuff372()
	genericstuff372()
	stuff373()
	genericstuff373()
	stuff374()
	genericstuff374()
	stuff375()
	genericstuff375()
	stuff376()
	genericstuff376()
	stuff377()
	genericstuff377()
	stuff378()
	genericstuff378()
	stuff379()
	genericstuff379()
	stuff380()
	genericstuff380()
	stuff381()
	genericstuff381()
	stuff382()
	genericstuff382()
	stuff383()
	genericstuff383()
	stuff384()
	genericstuff384()
	stuff385()
	genericstuff385()
	stuff386()
	genericstuff386()
	stuff387()
	genericstuff387()
	stuff388()
	genericstuff388()
	stuff389()
	genericstuff389()
	stuff390()
	genericstuff390()
	stuff391()
	genericstuff391()
	stuff392()
	genericstuff392()
	stuff393()
	genericstuff393()
	stuff394()
	genericstuff394()
	stuff395()
	genericstuff395()
	stuff396()
	genericstuff396()
	stuff397()
	genericstuff397()
	stuff398()
	genericstuff398()
	stuff399()
	genericstuff399()
	stuff400()
	genericstuff400()
	stuff401()
	genericstuff401()
	stuff402()
	genericstuff402()
	stuff403()
	genericstuff403()
	stuff404()
	genericstuff404()
	stuff405()
	genericstuff405()
	stuff406()
	genericstuff406()
	stuff407()
	genericstuff407()
	stuff408()
	genericstuff408()
	stuff409()
	genericstuff409()
	stuff410()
	genericstuff410()
	stuff411()
	genericstuff411()
	stuff412()
	genericstuff412()
	stuff413()
	genericstuff413()
	stuff414()
	genericstuff414()
	stuff415()
	genericstuff415()
	stuff416()
	genericstuff416()
	stuff417()
	genericstuff417()
	stuff418()
	genericstuff418()
	stuff419()
	genericstuff419()
	stuff420()
	genericstuff420()
	stuff421()
	genericstuff421()
	stuff422()
	genericstuff422()
	stuff423()
	genericstuff423()
	stuff424()
	genericstuff424()
	stuff425()
	genericstuff425()
	stuff426()
	genericstuff426()
	stuff427()
	genericstuff427()
	stuff428()
	genericstuff428()
	stuff429()
	genericstuff429()
	stuff430()
	genericstuff430()
	stuff431()
	genericstuff431()
	stuff432()
	genericstuff432()
	stuff433()
	genericstuff433()
	stuff434()
	genericstuff434()
	stuff435()
	genericstuff435()
	stuff436()
	genericstuff436()
	stuff437()
	genericstuff437()
	stuff438()
	genericstuff438()
	stuff439()
	genericstuff439()
	stuff440()
	genericstuff440()
	stuff441()
	genericstuff441()
	stuff442()
	genericstuff442()
	stuff443()
	genericstuff443()
	stuff444()
	genericstuff444()
	stuff445()
	genericstuff445()
	stuff446()
	genericstuff446()
	stuff447()
	genericstuff447()
	stuff448()
	genericstuff448()
	stuff449()
	genericstuff449()
	stuff450()
	genericstuff450()
	stuff451()
	genericstuff451()
	stuff452()
	genericstuff452()
	stuff453()
	genericstuff453()
	stuff454()
	genericstuff454()
	stuff455()
	genericstuff455()
	stuff456()
	genericstuff456()
	stuff457()
	genericstuff457()
	stuff458()
	genericstuff458()
	stuff459()
	genericstuff459()
	stuff460()
	genericstuff460()
	stuff461()
	genericstuff461()
	stuff462()
	genericstuff462()
	stuff463()
	genericstuff463()
	stuff464()
	genericstuff464()
	stuff465()
	genericstuff465()
	stuff466()
	genericstuff466()
	stuff467()
	genericstuff467()
	stuff468()
	genericstuff468()
	stuff469()
	genericstuff469()
	stuff470()
	genericstuff470()
	stuff471()
	genericstuff471()
	stuff472()
	genericstuff472()
	stuff473()
	genericstuff473()
	stuff474()
	genericstuff474()
	stuff475()
	genericstuff475()
	stuff476()
	genericstuff476()
	stuff477()
	genericstuff477()
	stuff478()
	genericstuff478()
	stuff479()
	genericstuff479()
	stuff480()
	genericstuff480()
	stuff481()
	genericstuff481()
	stuff482()
	genericstuff482()
	stuff483()
	genericstuff483()
	stuff484()
	genericstuff484()
	stuff485()
	genericstuff485()
	stuff486()
	genericstuff486()
	stuff487()
	genericstuff487()
	stuff488()
	genericstuff488()
	stuff489()
	genericstuff489()
	stuff490()
	genericstuff490()
	stuff491()
	genericstuff491()
	stuff492()
	genericstuff492()
	stuff493()
	genericstuff493()
	stuff494()
	genericstuff494()
	stuff495()
	genericstuff495()
	stuff496()
	genericstuff496()
	stuff497()
	genericstuff497()
	stuff498()
	genericstuff498()
	stuff499()
	genericstuff499()
	stuff500()
	genericstuff500()
	stuff501()
	genericstuff501()
	stuff502()
	genericstuff502()
	stuff503()
	genericstuff503()
	stuff504()
	genericstuff504()
	stuff505()
	genericstuff505()
	stuff506()
	genericstuff506()
	stuff507()
	genericstuff507()
	stuff508()
	genericstuff508()
	stuff509()
	genericstuff509()
	stuff510()
	genericstuff510()
	stuff511()
	genericstuff511()
	stuff512()
	genericstuff512()
	stuff513()
	genericstuff513()
	stuff514()
	genericstuff514()
	stuff515()
	genericstuff515()
	stuff516()
	genericstuff516()
	stuff517()
	genericstuff517()
	stuff518()
	genericstuff518()
	stuff519()
	genericstuff519()
	stuff520()
	genericstuff520()
	stuff521()
	genericstuff521()
	stuff522()
	genericstuff522()
	stuff523()
	genericstuff523()
	stuff524()
	genericstuff524()
	stuff525()
	genericstuff525()
	stuff526()
	genericstuff526()
	stuff527()
	genericstuff527()
	stuff528()
	genericstuff528()
	stuff529()
	genericstuff529()
	stuff530()
	genericstuff530()
	stuff531()
	genericstuff531()
	stuff532()
	genericstuff532()
	stuff533()
	genericstuff533()
	stuff534()
	genericstuff534()
	stuff535()
	genericstuff535()
	stuff536()
	genericstuff536()
	stuff537()
	genericstuff537()
	stuff538()
	genericstuff538()
	stuff539()
	genericstuff539()
	stuff540()
	genericstuff540()
	stuff541()
	genericstuff541()
	stuff542()
	genericstuff542()
	stuff543()
	genericstuff543()
	stuff544()
	genericstuff544()
	stuff545()
	genericstuff545()
	stuff546()
	genericstuff546()
	stuff547()
	genericstuff547()
	stuff548()
	genericstuff548()
	stuff549()
	genericstuff549()
	stuff550()
	genericstuff550()
	stuff551()
	genericstuff551()
	stuff552()
	genericstuff552()
	stuff553()
	genericstuff553()
	stuff554()
	genericstuff554()
	stuff555()
	genericstuff555()
	stuff556()
	genericstuff556()
	stuff557()
	genericstuff557()
	stuff558()
	genericstuff558()
	stuff559()
	genericstuff559()
	stuff560()
	genericstuff560()
	stuff561()
	genericstuff561()
	stuff562()
	genericstuff562()
	stuff563()
	genericstuff563()
	stuff564()
	genericstuff564()
	stuff565()
	genericstuff565()
	stuff566()
	genericstuff566()
	stuff567()
	genericstuff567()
	stuff568()
	genericstuff568()
	stuff569()
	genericstuff569()
	stuff570()
	genericstuff570()
	stuff571()
	genericstuff571()
	stuff572()
	genericstuff572()
	stuff573()
	genericstuff573()
	stuff574()
	genericstuff574()
	stuff575()
	genericstuff575()
	stuff576()
	genericstuff576()
	stuff577()
	genericstuff577()
	stuff578()
	genericstuff578()
	stuff579()
	genericstuff579()
	stuff580()
	genericstuff580()
	stuff581()
	genericstuff581()
	stuff582()
	genericstuff582()
	stuff583()
	genericstuff583()
	stuff584()
	genericstuff584()
	stuff585()
	genericstuff585()
	stuff586()
	genericstuff586()
	stuff587()
	genericstuff587()
	stuff588()
	genericstuff588()
	stuff589()
	genericstuff589()
	stuff590()
	genericstuff590()
	stuff591()
	genericstuff591()
	stuff592()
	genericstuff592()
	stuff593()
	genericstuff593()
	stuff594()
	genericstuff594()
	stuff595()
	genericstuff595()
	stuff596()
	genericstuff596()
	stuff597()
	genericstuff597()
	stuff598()
	genericstuff598()
	stuff599()
	genericstuff599()
	stuff600()
	genericstuff600()
	stuff601()
	genericstuff601()
	stuff602()
	genericstuff602()
	stuff603()
	genericstuff603()
	stuff604()
	genericstuff604()
	stuff605()
	genericstuff605()
	stuff606()
	genericstuff606()
	stuff607()
	genericstuff607()
	stuff608()
	genericstuff608()
	stuff609()
	genericstuff609()
	stuff610()
	genericstuff610()
	stuff611()
	genericstuff611()
	stuff612()
	genericstuff612()
	stuff613()
	genericstuff613()
	stuff614()
	genericstuff614()
	stuff615()
	genericstuff615()
	stuff616()
	genericstuff616()
	stuff617()
	genericstuff617()
	stuff618()
	genericstuff618()
	stuff619()
	genericstuff619()
	stuff620()
	genericstuff620()
	stuff621()
	genericstuff621()
	stuff622()
	genericstuff622()
	stuff623()
	genericstuff623()
	stuff624()
	genericstuff624()
	stuff625()
	genericstuff625()
	stuff626()
	genericstuff626()
	stuff627()
	genericstuff627()
	stuff628()
	genericstuff628()
	stuff629()
	genericstuff629()
	stuff630()
	genericstuff630()
	stuff631()
	genericstuff631()
	stuff632()
	genericstuff632()
	stuff633()
	genericstuff633()
	stuff634()
	genericstuff634()
	stuff635()
	genericstuff635()
	stuff636()
	genericstuff636()
	stuff637()
	genericstuff637()
	stuff638()
	genericstuff638()
	stuff639()
	genericstuff639()
	stuff640()
	genericstuff640()
	stuff641()
	genericstuff641()
	stuff642()
	genericstuff642()
	stuff643()
	genericstuff643()
	stuff644()
	genericstuff644()
	stuff645()
	genericstuff645()
	stuff646()
	genericstuff646()
	stuff647()
	genericstuff647()
	stuff648()
	genericstuff648()
	stuff649()
	genericstuff649()
	stuff650()
	genericstuff650()
	stuff651()
	genericstuff651()
	stuff652()
	genericstuff652()
	stuff653()
	genericstuff653()
	stuff654()
	genericstuff654()
	stuff655()
	genericstuff655()
	stuff656()
	genericstuff656()
	stuff657()
	genericstuff657()
	stuff658()
	genericstuff658()
	stuff659()
	genericstuff659()
	stuff660()
	genericstuff660()
	stuff661()
	genericstuff661()
	stuff662()
	genericstuff662()
	stuff663()
	genericstuff663()
	stuff664()
	genericstuff664()
	stuff665()
	genericstuff665()
	stuff666()
	genericstuff666()
	stuff667()
	genericstuff667()
	stuff668()
	genericstuff668()
	stuff669()
	genericstuff669()
	stuff670()
	genericstuff670()
	stuff671()
	genericstuff671()
	stuff672()
	genericstuff672()
	stuff673()
	genericstuff673()
	stuff674()
	genericstuff674()
	stuff675()
	genericstuff675()
	stuff676()
	genericstuff676()
	stuff677()
	genericstuff677()
	stuff678()
	genericstuff678()
	stuff679()
	genericstuff679()
	stuff680()
	genericstuff680()
	stuff681()
	genericstuff681()
	stuff682()
	genericstuff682()
	stuff683()
	genericstuff683()
	stuff684()
	genericstuff684()
	stuff685()
	genericstuff685()
	stuff686()
	genericstuff686()
	stuff687()
	genericstuff687()
	stuff688()
	genericstuff688()
	stuff689()
	genericstuff689()
	stuff690()
	genericstuff690()
	stuff691()
	genericstuff691()
	stuff692()
	genericstuff692()
	stuff693()
	genericstuff693()
	stuff694()
	genericstuff694()
	stuff695()
	genericstuff695()
	stuff696()
	genericstuff696()
	stuff697()
	genericstuff697()
	stuff698()
	genericstuff698()
	stuff699()
	genericstuff699()
	stuff700()
	genericstuff700()
	stuff701()
	genericstuff701()
	stuff702()
	genericstuff702()
	stuff703()
	genericstuff703()
	stuff704()
	genericstuff704()
	stuff705()
	genericstuff705()
	stuff706()
	genericstuff706()
	stuff707()
	genericstuff707()
	stuff708()
	genericstuff708()
	stuff709()
	genericstuff709()
	stuff710()
	genericstuff710()
	stuff711()
	genericstuff711()
	stuff712()
	genericstuff712()
	stuff713()
	genericstuff713()
	stuff714()
	genericstuff714()
	stuff715()
	genericstuff715()
	stuff716()
	genericstuff716()
	stuff717()
	genericstuff717()
	stuff718()
	genericstuff718()
	stuff719()
	genericstuff719()
	stuff720()
	genericstuff720()
	stuff721()
	genericstuff721()
	stuff722()
	genericstuff722()
	stuff723()
	genericstuff723()
	stuff724()
	genericstuff724()
	stuff725()
	genericstuff725()
	stuff726()
	genericstuff726()
	stuff727()
	genericstuff727()
	stuff728()
	genericstuff728()
	stuff729()
	genericstuff729()
	stuff730()
	genericstuff730()
	stuff731()
	genericstuff731()
	stuff732()
	genericstuff732()
	stuff733()
	genericstuff733()
	stuff734()
	genericstuff734()
	stuff735()
	genericstuff735()
	stuff736()
	genericstuff736()
	stuff737()
	genericstuff737()
	stuff738()
	genericstuff738()
	stuff739()
	genericstuff739()
	stuff740()
	genericstuff740()
	stuff741()
	genericstuff741()
	stuff742()
	genericstuff742()
	stuff743()
	genericstuff743()
	stuff744()
	genericstuff744()
	stuff745()
	genericstuff745()
	stuff746()
	genericstuff746()
	stuff747()
	genericstuff747()
	stuff748()
	genericstuff748()
	stuff749()
	genericstuff749()
	stuff750()
	genericstuff750()
	stuff751()
	genericstuff751()
	stuff752()
	genericstuff752()
	stuff753()
	genericstuff753()
	stuff754()
	genericstuff754()
	stuff755()
	genericstuff755()
	stuff756()
	genericstuff756()
	stuff757()
	genericstuff757()
	stuff758()
	genericstuff758()
	stuff759()
	genericstuff759()
	stuff760()
	genericstuff760()
	stuff761()
	genericstuff761()
	stuff762()
	genericstuff762()
	stuff763()
	genericstuff763()
	stuff764()
	genericstuff764()
	stuff765()
	genericstuff765()
	stuff766()
	genericstuff766()
	stuff767()
	genericstuff767()
	stuff768()
	genericstuff768()
	stuff769()
	genericstuff769()
	stuff770()
	genericstuff770()
	stuff771()
	genericstuff771()
	stuff772()
	genericstuff772()
	stuff773()
	genericstuff773()
	stuff774()
	genericstuff774()
	stuff775()
	genericstuff775()
	stuff776()
	genericstuff776()
	stuff777()
	genericstuff777()
	stuff778()
	genericstuff778()
	stuff779()
	genericstuff779()
	stuff780()
	genericstuff780()
	stuff781()
	genericstuff781()
	stuff782()
	genericstuff782()
	stuff783()
	genericstuff783()
	stuff784()
	genericstuff784()
	stuff785()
	genericstuff785()
	stuff786()
	genericstuff786()
	stuff787()
	genericstuff787()
	stuff788()
	genericstuff788()
	stuff789()
	genericstuff789()
	stuff790()
	genericstuff790()
	stuff791()
	genericstuff791()
	stuff792()
	genericstuff792()
	stuff793()
	genericstuff793()
	stuff794()
	genericstuff794()
	stuff795()
	genericstuff795()
	stuff796()
	genericstuff796()
	stuff797()
	genericstuff797()
	stuff798()
	genericstuff798()
	stuff799()
	genericstuff799()
	stuff800()
	genericstuff800()
	stuff801()
	genericstuff801()
	stuff802()
	genericstuff802()
	stuff803()
	genericstuff803()
	stuff804()
	genericstuff804()
	stuff805()
	genericstuff805()
	stuff806()
	genericstuff806()
	stuff807()
	genericstuff807()
	stuff808()
	genericstuff808()
	stuff809()
	genericstuff809()
	stuff810()
	genericstuff810()
	stuff811()
	genericstuff811()
	stuff812()
	genericstuff812()
	stuff813()
	genericstuff813()
	stuff814()
	genericstuff814()
	stuff815()
	genericstuff815()
	stuff816()
	genericstuff816()
	stuff817()
	genericstuff817()
	stuff818()
	genericstuff818()
	stuff819()
	genericstuff819()
	stuff820()
	genericstuff820()
	stuff821()
	genericstuff821()
	stuff822()
	genericstuff822()
	stuff823()
	genericstuff823()
	stuff824()
	genericstuff824()
	stuff825()
	genericstuff825()
	stuff826()
	genericstuff826()
	stuff827()
	genericstuff827()
	stuff828()
	genericstuff828()
	stuff829()
	genericstuff829()
	stuff830()
	genericstuff830()
	stuff831()
	genericstuff831()
	stuff832()
	genericstuff832()
	stuff833()
	genericstuff833()
	stuff834()
	genericstuff834()
	stuff835()
	genericstuff835()
	stuff836()
	genericstuff836()
	stuff837()
	genericstuff837()
	stuff838()
	genericstuff838()
	stuff839()
	genericstuff839()
	stuff840()
	genericstuff840()
	stuff841()
	genericstuff841()
	stuff842()
	genericstuff842()
	stuff843()
	genericstuff843()
	stuff844()
	genericstuff844()
	stuff845()
	genericstuff845()
	stuff846()
	genericstuff846()
	stuff847()
	genericstuff847()
	stuff848()
	genericstuff848()
	stuff849()
	genericstuff849()
	stuff850()
	genericstuff850()
	stuff851()
	genericstuff851()
	stuff852()
	genericstuff852()
	stuff853()
	genericstuff853()
	stuff854()
	genericstuff854()
	stuff855()
	genericstuff855()
	stuff856()
	genericstuff856()
	stuff857()
	genericstuff857()
	stuff858()
	genericstuff858()
	stuff859()
	genericstuff859()
	stuff860()
	genericstuff860()
	stuff861()
	genericstuff861()
	stuff862()
	genericstuff862()
	stuff863()
	genericstuff863()
	stuff864()
	genericstuff864()
	stuff865()
	genericstuff865()
	stuff866()
	genericstuff866()
	stuff867()
	genericstuff867()
	stuff868()
	genericstuff868()
	stuff869()
	genericstuff869()
	stuff870()
	genericstuff870()
	stuff871()
	genericstuff871()
	stuff872()
	genericstuff872()
	stuff873()
	genericstuff873()
	stuff874()
	genericstuff874()
	stuff875()
	genericstuff875()
	stuff876()
	genericstuff876()
	stuff877()
	genericstuff877()
	stuff878()
	genericstuff878()
	stuff879()
	genericstuff879()
	stuff880()
	genericstuff880()
	stuff881()
	genericstuff881()
	stuff882()
	genericstuff882()
	stuff883()
	genericstuff883()
	stuff884()
	genericstuff884()
	stuff885()
	genericstuff885()
	stuff886()
	genericstuff886()
	stuff887()
	genericstuff887()
	stuff888()
	genericstuff888()
	stuff889()
	genericstuff889()
	stuff890()
	genericstuff890()
	stuff891()
	genericstuff891()
	stuff892()
	genericstuff892()
	stuff893()
	genericstuff893()
	stuff894()
	genericstuff894()
	stuff895()
	genericstuff895()
	stuff896()
	genericstuff896()
	stuff897()
	genericstuff897()
	stuff898()
	genericstuff898()
	stuff899()
	genericstuff899()
	stuff900()
	genericstuff900()
	stuff901()
	genericstuff901()
	stuff902()
	genericstuff902()
	stuff903()
	genericstuff903()
	stuff904()
	genericstuff904()
	stuff905()
	genericstuff905()
	stuff906()
	genericstuff906()
	stuff907()
	genericstuff907()
	stuff908()
	genericstuff908()
	stuff909()
	genericstuff909()
	stuff910()
	genericstuff910()
	stuff911()
	genericstuff911()
	stuff912()
	genericstuff912()
	stuff913()
	genericstuff913()
	stuff914()
	genericstuff914()
	stuff915()
	genericstuff915()
	stuff916()
	genericstuff916()
	stuff917()
	genericstuff917()
	stuff918()
	genericstuff918()
	stuff919()
	genericstuff919()
	stuff920()
	genericstuff920()
	stuff921()
	genericstuff921()
	stuff922()
	genericstuff922()
	stuff923()
	genericstuff923()
	stuff924()
	genericstuff924()
	stuff925()
	genericstuff925()
	stuff926()
	genericstuff926()
	stuff927()
	genericstuff927()
	stuff928()
	genericstuff928()
	stuff929()
	genericstuff929()
	stuff930()
	genericstuff930()
	stuff931()
	genericstuff931()
	stuff932()
	genericstuff932()
	stuff933()
	genericstuff933()
	stuff934()
	genericstuff934()
	stuff935()
	genericstuff935()
	stuff936()
	genericstuff936()
	stuff937()
	genericstuff937()
	stuff938()
	genericstuff938()
	stuff939()
	genericstuff939()
	stuff940()
	genericstuff940()
	stuff941()
	genericstuff941()
	stuff942()
	genericstuff942()
	stuff943()
	genericstuff943()
	stuff944()
	genericstuff944()
	stuff945()
	genericstuff945()
	stuff946()
	genericstuff946()
	stuff947()
	genericstuff947()
	stuff948()
	genericstuff948()
	stuff949()
	genericstuff949()
	stuff950()
	genericstuff950()
	stuff951()
	genericstuff951()
	stuff952()
	genericstuff952()
	stuff953()
	genericstuff953()
	stuff954()
	genericstuff954()
	stuff955()
	genericstuff955()
	stuff956()
	genericstuff956()
	stuff957()
	genericstuff957()
	stuff958()
	genericstuff958()
	stuff959()
	genericstuff959()
	stuff960()
	genericstuff960()
	stuff961()
	genericstuff961()
	stuff962()
	genericstuff962()
	stuff963()
	genericstuff963()
	stuff964()
	genericstuff964()
	stuff965()
	genericstuff965()
	stuff966()
	genericstuff966()
	stuff967()
	genericstuff967()
	stuff968()
	genericstuff968()
	stuff969()
	genericstuff969()
	stuff970()
	genericstuff970()
	stuff971()
	genericstuff971()
	stuff972()
	genericstuff972()
	stuff973()
	genericstuff973()
	stuff974()
	genericstuff974()
	stuff975()
	genericstuff975()
	stuff976()
	genericstuff976()
	stuff977()
	genericstuff977()
	stuff978()
	genericstuff978()
	stuff979()
	genericstuff979()
	stuff980()
	genericstuff980()
	stuff981()
	genericstuff981()
	stuff982()
	genericstuff982()
	stuff983()
	genericstuff983()
	stuff984()
	genericstuff984()
	stuff985()
	genericstuff985()
	stuff986()
	genericstuff986()
	stuff987()
	genericstuff987()
	stuff988()
	genericstuff988()
	stuff989()
	genericstuff989()
	stuff990()
	genericstuff990()
	stuff991()
	genericstuff991()
	stuff992()
	genericstuff992()
	stuff993()
	genericstuff993()
	stuff994()
	genericstuff994()
	stuff995()
	genericstuff995()
	stuff996()
	genericstuff996()
	stuff997()
	genericstuff997()
	stuff998()
	genericstuff998()
	stuff999()
	genericstuff999()
	stuff1000()
	genericstuff1000()
	stuff1001()
	genericstuff1001()
	stuff1002()
	genericstuff1002()
	stuff1003()
	genericstuff1003()
	stuff1004()
	genericstuff1004()
	stuff1005()
	genericstuff1005()
	stuff1006()
	genericstuff1006()
	stuff1007()
	genericstuff1007()
	stuff1008()
	genericstuff1008()
	stuff1009()
	genericstuff1009()
	stuff1010()
	genericstuff1010()
	stuff1011()
	genericstuff1011()
	stuff1012()
	genericstuff1012()
	stuff1013()
	genericstuff1013()
	stuff1014()
	genericstuff1014()
	stuff1015()
	genericstuff1015()
	stuff1016()
	genericstuff1016()
	stuff1017()
	genericstuff1017()
	stuff1018()
	genericstuff1018()
	stuff1019()
	genericstuff1019()
	stuff1020()
	genericstuff1020()
	stuff1021()
	genericstuff1021()
	stuff1022()
	genericstuff1022()
	stuff1023()
	genericstuff1023()
	stuff1024()
	genericstuff1024()
	stuff1025()
	genericstuff1025()
	stuff1026()
	genericstuff1026()
	stuff1027()
	genericstuff1027()
	stuff1028()
	genericstuff1028()
	stuff1029()
	genericstuff1029()
	stuff1030()
	genericstuff1030()
	stuff1031()
	genericstuff1031()
	stuff1032()
	genericstuff1032()
	stuff1033()
	genericstuff1033()
	stuff1034()
	genericstuff1034()
	stuff1035()
	genericstuff1035()
	stuff1036()
	genericstuff1036()
	stuff1037()
	genericstuff1037()
	stuff1038()
	genericstuff1038()
	stuff1039()
	genericstuff1039()
	stuff1040()
	genericstuff1040()
	stuff1041()
	genericstuff1041()
	stuff1042()
	genericstuff1042()
	stuff1043()
	genericstuff1043()
	stuff1044()
	genericstuff1044()
	stuff1045()
	genericstuff1045()
	stuff1046()
	genericstuff1046()
	stuff1047()
	genericstuff1047()
	stuff1048()
	genericstuff1048()
	stuff1049()
	genericstuff1049()
	stuff1050()
	genericstuff1050()
	stuff1051()
	genericstuff1051()
	stuff1052()
	genericstuff1052()
	stuff1053()
	genericstuff1053()
	stuff1054()
	genericstuff1054()
	stuff1055()
	genericstuff1055()
	stuff1056()
	genericstuff1056()
	stuff1057()
	genericstuff1057()
	stuff1058()
	genericstuff1058()
	stuff1059()
	genericstuff1059()
	stuff1060()
	genericstuff1060()
	stuff1061()
	genericstuff1061()
	stuff1062()
	genericstuff1062()
	stuff1063()
	genericstuff1063()
	stuff1064()
	genericstuff1064()
	stuff1065()
	genericstuff1065()
	stuff1066()
	genericstuff1066()
	stuff1067()
	genericstuff1067()
	stuff1068()
	genericstuff1068()
	stuff1069()
	genericstuff1069()
	stuff1070()
	genericstuff1070()
	stuff1071()
	genericstuff1071()
	stuff1072()
	genericstuff1072()
	stuff1073()
	genericstuff1073()
	stuff1074()
	genericstuff1074()
	stuff1075()
	genericstuff1075()
	stuff1076()
	genericstuff1076()
	stuff1077()
	genericstuff1077()
	stuff1078()
	genericstuff1078()
	stuff1079()
	genericstuff1079()
	stuff1080()
	genericstuff1080()
	stuff1081()
	genericstuff1081()
	stuff1082()
	genericstuff1082()
	stuff1083()
	genericstuff1083()
	stuff1084()
	genericstuff1084()
	stuff1085()
	genericstuff1085()
	stuff1086()
	genericstuff1086()
	stuff1087()
	genericstuff1087()
	stuff1088()
	genericstuff1088()
	stuff1089()
	genericstuff1089()
	stuff1090()
	genericstuff1090()
	stuff1091()
	genericstuff1091()
	stuff1092()
	genericstuff1092()
	stuff1093()
	genericstuff1093()
	stuff1094()
	genericstuff1094()
	stuff1095()
	genericstuff1095()
	stuff1096()
	genericstuff1096()
	stuff1097()
	genericstuff1097()
	stuff1098()
	genericstuff1098()
	stuff1099()
	genericstuff1099()
	stuff1100()
	genericstuff1100()
	stuff1101()
	genericstuff1101()
	stuff1102()
	genericstuff1102()
	stuff1103()
	genericstuff1103()
	stuff1104()
	genericstuff1104()
	stuff1105()
	genericstuff1105()
	stuff1106()
	genericstuff1106()
	stuff1107()
	genericstuff1107()
	stuff1108()
	genericstuff1108()
	stuff1109()
	genericstuff1109()
	stuff1110()
	genericstuff1110()
	stuff1111()
	genericstuff1111()
	stuff1112()
	genericstuff1112()
	stuff1113()
	genericstuff1113()
	stuff1114()
	genericstuff1114()
	stuff1115()
	genericstuff1115()
	stuff1116()
	genericstuff1116()
	stuff1117()
	genericstuff1117()
	stuff1118()
	genericstuff1118()
	stuff1119()
	genericstuff1119()
	stuff1120()
	genericstuff1120()
	stuff1121()
	genericstuff1121()
	stuff1122()
	genericstuff1122()
	stuff1123()
	genericstuff1123()
	stuff1124()
	genericstuff1124()
	stuff1125()
	genericstuff1125()
	stuff1126()
	genericstuff1126()
	stuff1127()
	genericstuff1127()
	stuff1128()
	genericstuff1128()
	stuff1129()
	genericstuff1129()
	stuff1130()
	genericstuff1130()
	stuff1131()
	genericstuff1131()
	stuff1132()
	genericstuff1132()
	stuff1133()
	genericstuff1133()
	stuff1134()
	genericstuff1134()
	stuff1135()
	genericstuff1135()
	stuff1136()
	genericstuff1136()
	stuff1137()
	genericstuff1137()
	stuff1138()
	genericstuff1138()
	stuff1139()
	genericstuff1139()
	stuff1140()
	genericstuff1140()
	stuff1141()
	genericstuff1141()
	stuff1142()
	genericstuff1142()
	stuff1143()
	genericstuff1143()
	stuff1144()
	genericstuff1144()
	stuff1145()
	genericstuff1145()
	stuff1146()
	genericstuff1146()
	stuff1147()
	genericstuff1147()
	stuff1148()
	genericstuff1148()
	stuff1149()
	genericstuff1149()
	stuff1150()
	genericstuff1150()
	stuff1151()
	genericstuff1151()
	stuff1152()
	genericstuff1152()
	stuff1153()
	genericstuff1153()
	stuff1154()
	genericstuff1154()
	stuff1155()
	genericstuff1155()
	stuff1156()
	genericstuff1156()
	stuff1157()
	genericstuff1157()
	stuff1158()
	genericstuff1158()
	stuff1159()
	genericstuff1159()
	stuff1160()
	genericstuff1160()
	stuff1161()
	genericstuff1161()
	stuff1162()
	genericstuff1162()
	stuff1163()
	genericstuff1163()
	stuff1164()
	genericstuff1164()
	stuff1165()
	genericstuff1165()
	stuff1166()
	genericstuff1166()
	stuff1167()
	genericstuff1167()
	stuff1168()
	genericstuff1168()
	stuff1169()
	genericstuff1169()
	stuff1170()
	genericstuff1170()
	stuff1171()
	genericstuff1171()
	stuff1172()
	genericstuff1172()
	stuff1173()
	genericstuff1173()
	stuff1174()
	genericstuff1174()
	stuff1175()
	genericstuff1175()
	stuff1176()
	genericstuff1176()
	stuff1177()
	genericstuff1177()
	stuff1178()
	genericstuff1178()
	stuff1179()
	genericstuff1179()
	stuff1180()
	genericstuff1180()
	stuff1181()
	genericstuff1181()
	stuff1182()
	genericstuff1182()
	stuff1183()
	genericstuff1183()
	stuff1184()
	genericstuff1184()
	stuff1185()
	genericstuff1185()
	stuff1186()
	genericstuff1186()
	stuff1187()
	genericstuff1187()
	stuff1188()
	genericstuff1188()
	stuff1189()
	genericstuff1189()
	stuff1190()
	genericstuff1190()
	stuff1191()
	genericstuff1191()
	stuff1192()
	genericstuff1192()
	stuff1193()
	genericstuff1193()
	stuff1194()
	genericstuff1194()
	stuff1195()
	genericstuff1195()
	stuff1196()
	genericstuff1196()
	stuff1197()
	genericstuff1197()
	stuff1198()
	genericstuff1198()
	stuff1199()
	genericstuff1199()
	stuff1200()
	genericstuff1200()
	stuff1201()
	genericstuff1201()
	stuff1202()
	genericstuff1202()
	stuff1203()
	genericstuff1203()
	stuff1204()
	genericstuff1204()
	stuff1205()
	genericstuff1205()
	stuff1206()
	genericstuff1206()
	stuff1207()
	genericstuff1207()
	stuff1208()
	genericstuff1208()
	stuff1209()
	genericstuff1209()
	stuff1210()
	genericstuff1210()
	stuff1211()
	genericstuff1211()
	stuff1212()
	genericstuff1212()
	stuff1213()
	genericstuff1213()
	stuff1214()
	genericstuff1214()
	stuff1215()
	genericstuff1215()
	return 0
}
