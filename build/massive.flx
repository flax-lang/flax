export massive
import "libc" as _
import "math" as _
ffi fn srand(s: i32)
ffi fn rand() -> i32

let names0 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal0
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names0[rand() % names0.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog0 : Animal0
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation0 : Dog0
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList0<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff0()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog0 [5] {
			if i % 2 == 1   { it = alloc Dalmation0 }
			else            { it = alloc Dog0 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList0<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names1 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal1
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names1[rand() % names1.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog1 : Animal1
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation1 : Dog1
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList1<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff1()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog1 [5] {
			if i % 2 == 1   { it = alloc Dalmation1 }
			else            { it = alloc Dog1 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList1<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names2 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal2
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names2[rand() % names2.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog2 : Animal2
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation2 : Dog2
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList2<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff2()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog2 [5] {
			if i % 2 == 1   { it = alloc Dalmation2 }
			else            { it = alloc Dog2 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList2<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names3 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal3
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names3[rand() % names3.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog3 : Animal3
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation3 : Dog3
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList3<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff3()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog3 [5] {
			if i % 2 == 1   { it = alloc Dalmation3 }
			else            { it = alloc Dog3 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList3<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names4 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal4
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names4[rand() % names4.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog4 : Animal4
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation4 : Dog4
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList4<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff4()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog4 [5] {
			if i % 2 == 1   { it = alloc Dalmation4 }
			else            { it = alloc Dog4 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList4<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names5 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal5
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names5[rand() % names5.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog5 : Animal5
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation5 : Dog5
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList5<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff5()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog5 [5] {
			if i % 2 == 1   { it = alloc Dalmation5 }
			else            { it = alloc Dog5 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList5<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names6 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal6
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names6[rand() % names6.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog6 : Animal6
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation6 : Dog6
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList6<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff6()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog6 [5] {
			if i % 2 == 1   { it = alloc Dalmation6 }
			else            { it = alloc Dog6 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList6<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names7 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal7
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names7[rand() % names7.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog7 : Animal7
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation7 : Dog7
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList7<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff7()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog7 [5] {
			if i % 2 == 1   { it = alloc Dalmation7 }
			else            { it = alloc Dog7 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList7<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names8 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal8
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names8[rand() % names8.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog8 : Animal8
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation8 : Dog8
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList8<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff8()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog8 [5] {
			if i % 2 == 1   { it = alloc Dalmation8 }
			else            { it = alloc Dog8 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList8<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names9 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal9
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names9[rand() % names9.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog9 : Animal9
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation9 : Dog9
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList9<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff9()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog9 [5] {
			if i % 2 == 1   { it = alloc Dalmation9 }
			else            { it = alloc Dog9 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList9<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names10 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal10
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names10[rand() % names10.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog10 : Animal10
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation10 : Dog10
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList10<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff10()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog10 [5] {
			if i % 2 == 1   { it = alloc Dalmation10 }
			else            { it = alloc Dog10 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList10<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names11 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal11
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names11[rand() % names11.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog11 : Animal11
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation11 : Dog11
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList11<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff11()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog11 [5] {
			if i % 2 == 1   { it = alloc Dalmation11 }
			else            { it = alloc Dog11 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList11<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names12 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal12
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names12[rand() % names12.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog12 : Animal12
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation12 : Dog12
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList12<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff12()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog12 [5] {
			if i % 2 == 1   { it = alloc Dalmation12 }
			else            { it = alloc Dog12 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList12<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names13 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal13
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names13[rand() % names13.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog13 : Animal13
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation13 : Dog13
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList13<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff13()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog13 [5] {
			if i % 2 == 1   { it = alloc Dalmation13 }
			else            { it = alloc Dog13 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList13<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names14 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal14
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names14[rand() % names14.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog14 : Animal14
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation14 : Dog14
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList14<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff14()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog14 [5] {
			if i % 2 == 1   { it = alloc Dalmation14 }
			else            { it = alloc Dog14 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList14<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names15 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal15
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names15[rand() % names15.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog15 : Animal15
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation15 : Dog15
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList15<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff15()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog15 [5] {
			if i % 2 == 1   { it = alloc Dalmation15 }
			else            { it = alloc Dog15 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList15<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names16 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal16
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names16[rand() % names16.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog16 : Animal16
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation16 : Dog16
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList16<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff16()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog16 [5] {
			if i % 2 == 1   { it = alloc Dalmation16 }
			else            { it = alloc Dog16 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList16<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names17 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal17
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names17[rand() % names17.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog17 : Animal17
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation17 : Dog17
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList17<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff17()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog17 [5] {
			if i % 2 == 1   { it = alloc Dalmation17 }
			else            { it = alloc Dog17 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList17<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names18 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal18
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names18[rand() % names18.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog18 : Animal18
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation18 : Dog18
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList18<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff18()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog18 [5] {
			if i % 2 == 1   { it = alloc Dalmation18 }
			else            { it = alloc Dog18 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList18<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names19 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal19
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names19[rand() % names19.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog19 : Animal19
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation19 : Dog19
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList19<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff19()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog19 [5] {
			if i % 2 == 1   { it = alloc Dalmation19 }
			else            { it = alloc Dog19 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList19<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names20 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal20
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names20[rand() % names20.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog20 : Animal20
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation20 : Dog20
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList20<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff20()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog20 [5] {
			if i % 2 == 1   { it = alloc Dalmation20 }
			else            { it = alloc Dog20 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList20<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names21 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal21
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names21[rand() % names21.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog21 : Animal21
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation21 : Dog21
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList21<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff21()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog21 [5] {
			if i % 2 == 1   { it = alloc Dalmation21 }
			else            { it = alloc Dog21 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList21<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names22 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal22
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names22[rand() % names22.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog22 : Animal22
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation22 : Dog22
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList22<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff22()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog22 [5] {
			if i % 2 == 1   { it = alloc Dalmation22 }
			else            { it = alloc Dog22 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList22<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names23 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal23
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names23[rand() % names23.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog23 : Animal23
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation23 : Dog23
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList23<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff23()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog23 [5] {
			if i % 2 == 1   { it = alloc Dalmation23 }
			else            { it = alloc Dog23 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList23<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names24 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal24
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names24[rand() % names24.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog24 : Animal24
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation24 : Dog24
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList24<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff24()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog24 [5] {
			if i % 2 == 1   { it = alloc Dalmation24 }
			else            { it = alloc Dog24 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList24<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names25 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal25
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names25[rand() % names25.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog25 : Animal25
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation25 : Dog25
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList25<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff25()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog25 [5] {
			if i % 2 == 1   { it = alloc Dalmation25 }
			else            { it = alloc Dog25 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList25<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names26 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal26
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names26[rand() % names26.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog26 : Animal26
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation26 : Dog26
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList26<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff26()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog26 [5] {
			if i % 2 == 1   { it = alloc Dalmation26 }
			else            { it = alloc Dog26 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList26<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names27 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal27
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names27[rand() % names27.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog27 : Animal27
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation27 : Dog27
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList27<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff27()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog27 [5] {
			if i % 2 == 1   { it = alloc Dalmation27 }
			else            { it = alloc Dog27 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList27<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names28 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal28
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names28[rand() % names28.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog28 : Animal28
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation28 : Dog28
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList28<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff28()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog28 [5] {
			if i % 2 == 1   { it = alloc Dalmation28 }
			else            { it = alloc Dog28 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList28<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names29 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal29
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names29[rand() % names29.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog29 : Animal29
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation29 : Dog29
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList29<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff29()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog29 [5] {
			if i % 2 == 1   { it = alloc Dalmation29 }
			else            { it = alloc Dog29 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList29<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names30 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal30
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names30[rand() % names30.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog30 : Animal30
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation30 : Dog30
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList30<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff30()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog30 [5] {
			if i % 2 == 1   { it = alloc Dalmation30 }
			else            { it = alloc Dog30 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList30<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names31 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal31
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names31[rand() % names31.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog31 : Animal31
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation31 : Dog31
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList31<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff31()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog31 [5] {
			if i % 2 == 1   { it = alloc Dalmation31 }
			else            { it = alloc Dog31 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList31<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names32 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal32
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names32[rand() % names32.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog32 : Animal32
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation32 : Dog32
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList32<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff32()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog32 [5] {
			if i % 2 == 1   { it = alloc Dalmation32 }
			else            { it = alloc Dog32 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList32<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names33 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal33
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names33[rand() % names33.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog33 : Animal33
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation33 : Dog33
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList33<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff33()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog33 [5] {
			if i % 2 == 1   { it = alloc Dalmation33 }
			else            { it = alloc Dog33 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList33<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names34 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal34
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names34[rand() % names34.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog34 : Animal34
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation34 : Dog34
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList34<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff34()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog34 [5] {
			if i % 2 == 1   { it = alloc Dalmation34 }
			else            { it = alloc Dog34 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList34<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names35 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal35
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names35[rand() % names35.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog35 : Animal35
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation35 : Dog35
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList35<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff35()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog35 [5] {
			if i % 2 == 1   { it = alloc Dalmation35 }
			else            { it = alloc Dog35 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList35<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names36 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal36
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names36[rand() % names36.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog36 : Animal36
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation36 : Dog36
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList36<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff36()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog36 [5] {
			if i % 2 == 1   { it = alloc Dalmation36 }
			else            { it = alloc Dog36 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList36<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names37 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal37
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names37[rand() % names37.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog37 : Animal37
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation37 : Dog37
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList37<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff37()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog37 [5] {
			if i % 2 == 1   { it = alloc Dalmation37 }
			else            { it = alloc Dog37 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList37<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names38 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal38
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names38[rand() % names38.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog38 : Animal38
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation38 : Dog38
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList38<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff38()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog38 [5] {
			if i % 2 == 1   { it = alloc Dalmation38 }
			else            { it = alloc Dog38 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList38<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names39 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal39
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names39[rand() % names39.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog39 : Animal39
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation39 : Dog39
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList39<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff39()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog39 [5] {
			if i % 2 == 1   { it = alloc Dalmation39 }
			else            { it = alloc Dog39 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList39<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names40 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal40
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names40[rand() % names40.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog40 : Animal40
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation40 : Dog40
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList40<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff40()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog40 [5] {
			if i % 2 == 1   { it = alloc Dalmation40 }
			else            { it = alloc Dog40 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList40<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names41 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal41
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names41[rand() % names41.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog41 : Animal41
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation41 : Dog41
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList41<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff41()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog41 [5] {
			if i % 2 == 1   { it = alloc Dalmation41 }
			else            { it = alloc Dog41 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList41<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names42 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal42
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names42[rand() % names42.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog42 : Animal42
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation42 : Dog42
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList42<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff42()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog42 [5] {
			if i % 2 == 1   { it = alloc Dalmation42 }
			else            { it = alloc Dog42 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList42<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names43 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal43
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names43[rand() % names43.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog43 : Animal43
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation43 : Dog43
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList43<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff43()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog43 [5] {
			if i % 2 == 1   { it = alloc Dalmation43 }
			else            { it = alloc Dog43 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList43<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names44 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal44
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names44[rand() % names44.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog44 : Animal44
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation44 : Dog44
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList44<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff44()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog44 [5] {
			if i % 2 == 1   { it = alloc Dalmation44 }
			else            { it = alloc Dog44 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList44<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names45 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal45
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names45[rand() % names45.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog45 : Animal45
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation45 : Dog45
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList45<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff45()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog45 [5] {
			if i % 2 == 1   { it = alloc Dalmation45 }
			else            { it = alloc Dog45 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList45<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names46 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal46
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names46[rand() % names46.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog46 : Animal46
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation46 : Dog46
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList46<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff46()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog46 [5] {
			if i % 2 == 1   { it = alloc Dalmation46 }
			else            { it = alloc Dog46 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList46<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names47 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal47
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names47[rand() % names47.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog47 : Animal47
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation47 : Dog47
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList47<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff47()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog47 [5] {
			if i % 2 == 1   { it = alloc Dalmation47 }
			else            { it = alloc Dog47 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList47<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names48 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal48
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names48[rand() % names48.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog48 : Animal48
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation48 : Dog48
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList48<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff48()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog48 [5] {
			if i % 2 == 1   { it = alloc Dalmation48 }
			else            { it = alloc Dog48 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList48<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names49 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal49
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names49[rand() % names49.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog49 : Animal49
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation49 : Dog49
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList49<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff49()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog49 [5] {
			if i % 2 == 1   { it = alloc Dalmation49 }
			else            { it = alloc Dog49 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList49<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names50 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal50
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names50[rand() % names50.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog50 : Animal50
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation50 : Dog50
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList50<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff50()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog50 [5] {
			if i % 2 == 1   { it = alloc Dalmation50 }
			else            { it = alloc Dog50 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList50<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names51 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal51
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names51[rand() % names51.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog51 : Animal51
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation51 : Dog51
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList51<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff51()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog51 [5] {
			if i % 2 == 1   { it = alloc Dalmation51 }
			else            { it = alloc Dog51 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList51<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names52 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal52
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names52[rand() % names52.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog52 : Animal52
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation52 : Dog52
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList52<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff52()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog52 [5] {
			if i % 2 == 1   { it = alloc Dalmation52 }
			else            { it = alloc Dog52 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList52<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names53 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal53
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names53[rand() % names53.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog53 : Animal53
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation53 : Dog53
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList53<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff53()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog53 [5] {
			if i % 2 == 1   { it = alloc Dalmation53 }
			else            { it = alloc Dog53 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList53<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names54 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal54
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names54[rand() % names54.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog54 : Animal54
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation54 : Dog54
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList54<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff54()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog54 [5] {
			if i % 2 == 1   { it = alloc Dalmation54 }
			else            { it = alloc Dog54 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList54<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names55 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal55
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names55[rand() % names55.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog55 : Animal55
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation55 : Dog55
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList55<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff55()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog55 [5] {
			if i % 2 == 1   { it = alloc Dalmation55 }
			else            { it = alloc Dog55 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList55<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names56 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal56
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names56[rand() % names56.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog56 : Animal56
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation56 : Dog56
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList56<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff56()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog56 [5] {
			if i % 2 == 1   { it = alloc Dalmation56 }
			else            { it = alloc Dog56 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList56<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names57 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal57
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names57[rand() % names57.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog57 : Animal57
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation57 : Dog57
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList57<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff57()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog57 [5] {
			if i % 2 == 1   { it = alloc Dalmation57 }
			else            { it = alloc Dog57 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList57<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names58 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal58
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names58[rand() % names58.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog58 : Animal58
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation58 : Dog58
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList58<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff58()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog58 [5] {
			if i % 2 == 1   { it = alloc Dalmation58 }
			else            { it = alloc Dog58 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList58<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names59 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal59
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names59[rand() % names59.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog59 : Animal59
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation59 : Dog59
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList59<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff59()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog59 [5] {
			if i % 2 == 1   { it = alloc Dalmation59 }
			else            { it = alloc Dog59 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList59<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names60 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal60
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names60[rand() % names60.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog60 : Animal60
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation60 : Dog60
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList60<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff60()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog60 [5] {
			if i % 2 == 1   { it = alloc Dalmation60 }
			else            { it = alloc Dog60 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList60<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names61 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal61
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names61[rand() % names61.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog61 : Animal61
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation61 : Dog61
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList61<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff61()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog61 [5] {
			if i % 2 == 1   { it = alloc Dalmation61 }
			else            { it = alloc Dog61 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList61<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names62 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal62
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names62[rand() % names62.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog62 : Animal62
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation62 : Dog62
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList62<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff62()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog62 [5] {
			if i % 2 == 1   { it = alloc Dalmation62 }
			else            { it = alloc Dog62 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList62<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names63 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal63
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names63[rand() % names63.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog63 : Animal63
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation63 : Dog63
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList63<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff63()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog63 [5] {
			if i % 2 == 1   { it = alloc Dalmation63 }
			else            { it = alloc Dog63 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList63<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names64 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal64
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names64[rand() % names64.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog64 : Animal64
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation64 : Dog64
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList64<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff64()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog64 [5] {
			if i % 2 == 1   { it = alloc Dalmation64 }
			else            { it = alloc Dog64 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList64<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names65 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal65
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names65[rand() % names65.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog65 : Animal65
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation65 : Dog65
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList65<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff65()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog65 [5] {
			if i % 2 == 1   { it = alloc Dalmation65 }
			else            { it = alloc Dog65 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList65<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names66 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal66
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names66[rand() % names66.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog66 : Animal66
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation66 : Dog66
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList66<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff66()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog66 [5] {
			if i % 2 == 1   { it = alloc Dalmation66 }
			else            { it = alloc Dog66 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList66<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names67 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal67
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names67[rand() % names67.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog67 : Animal67
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation67 : Dog67
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList67<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff67()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog67 [5] {
			if i % 2 == 1   { it = alloc Dalmation67 }
			else            { it = alloc Dog67 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList67<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names68 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal68
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names68[rand() % names68.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog68 : Animal68
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation68 : Dog68
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList68<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff68()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog68 [5] {
			if i % 2 == 1   { it = alloc Dalmation68 }
			else            { it = alloc Dog68 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList68<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names69 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal69
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names69[rand() % names69.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog69 : Animal69
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation69 : Dog69
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList69<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff69()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog69 [5] {
			if i % 2 == 1   { it = alloc Dalmation69 }
			else            { it = alloc Dog69 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList69<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names70 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal70
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names70[rand() % names70.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog70 : Animal70
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation70 : Dog70
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList70<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff70()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog70 [5] {
			if i % 2 == 1   { it = alloc Dalmation70 }
			else            { it = alloc Dog70 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList70<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names71 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal71
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names71[rand() % names71.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog71 : Animal71
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation71 : Dog71
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList71<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff71()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog71 [5] {
			if i % 2 == 1   { it = alloc Dalmation71 }
			else            { it = alloc Dog71 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList71<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names72 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal72
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names72[rand() % names72.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog72 : Animal72
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation72 : Dog72
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList72<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff72()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog72 [5] {
			if i % 2 == 1   { it = alloc Dalmation72 }
			else            { it = alloc Dog72 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList72<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names73 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal73
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names73[rand() % names73.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog73 : Animal73
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation73 : Dog73
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList73<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff73()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog73 [5] {
			if i % 2 == 1   { it = alloc Dalmation73 }
			else            { it = alloc Dog73 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList73<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names74 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal74
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names74[rand() % names74.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog74 : Animal74
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation74 : Dog74
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList74<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff74()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog74 [5] {
			if i % 2 == 1   { it = alloc Dalmation74 }
			else            { it = alloc Dog74 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList74<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names75 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal75
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names75[rand() % names75.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog75 : Animal75
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation75 : Dog75
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList75<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff75()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog75 [5] {
			if i % 2 == 1   { it = alloc Dalmation75 }
			else            { it = alloc Dog75 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList75<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names76 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal76
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names76[rand() % names76.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog76 : Animal76
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation76 : Dog76
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList76<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff76()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog76 [5] {
			if i % 2 == 1   { it = alloc Dalmation76 }
			else            { it = alloc Dog76 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList76<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names77 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal77
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names77[rand() % names77.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog77 : Animal77
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation77 : Dog77
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList77<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff77()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog77 [5] {
			if i % 2 == 1   { it = alloc Dalmation77 }
			else            { it = alloc Dog77 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList77<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names78 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal78
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names78[rand() % names78.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog78 : Animal78
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation78 : Dog78
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList78<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff78()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog78 [5] {
			if i % 2 == 1   { it = alloc Dalmation78 }
			else            { it = alloc Dog78 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList78<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names79 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal79
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names79[rand() % names79.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog79 : Animal79
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation79 : Dog79
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList79<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff79()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog79 [5] {
			if i % 2 == 1   { it = alloc Dalmation79 }
			else            { it = alloc Dog79 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList79<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names80 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal80
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names80[rand() % names80.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog80 : Animal80
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation80 : Dog80
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList80<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff80()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog80 [5] {
			if i % 2 == 1   { it = alloc Dalmation80 }
			else            { it = alloc Dog80 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList80<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names81 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal81
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names81[rand() % names81.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog81 : Animal81
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation81 : Dog81
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList81<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff81()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog81 [5] {
			if i % 2 == 1   { it = alloc Dalmation81 }
			else            { it = alloc Dog81 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList81<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names82 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal82
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names82[rand() % names82.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog82 : Animal82
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation82 : Dog82
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList82<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff82()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog82 [5] {
			if i % 2 == 1   { it = alloc Dalmation82 }
			else            { it = alloc Dog82 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList82<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names83 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal83
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names83[rand() % names83.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog83 : Animal83
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation83 : Dog83
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList83<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff83()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog83 [5] {
			if i % 2 == 1   { it = alloc Dalmation83 }
			else            { it = alloc Dog83 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList83<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names84 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal84
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names84[rand() % names84.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog84 : Animal84
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation84 : Dog84
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList84<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff84()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog84 [5] {
			if i % 2 == 1   { it = alloc Dalmation84 }
			else            { it = alloc Dog84 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList84<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names85 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal85
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names85[rand() % names85.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog85 : Animal85
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation85 : Dog85
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList85<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff85()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog85 [5] {
			if i % 2 == 1   { it = alloc Dalmation85 }
			else            { it = alloc Dog85 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList85<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names86 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal86
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names86[rand() % names86.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog86 : Animal86
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation86 : Dog86
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList86<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff86()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog86 [5] {
			if i % 2 == 1   { it = alloc Dalmation86 }
			else            { it = alloc Dog86 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList86<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names87 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal87
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names87[rand() % names87.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog87 : Animal87
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation87 : Dog87
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList87<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff87()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog87 [5] {
			if i % 2 == 1   { it = alloc Dalmation87 }
			else            { it = alloc Dog87 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList87<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names88 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal88
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names88[rand() % names88.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog88 : Animal88
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation88 : Dog88
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList88<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff88()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog88 [5] {
			if i % 2 == 1   { it = alloc Dalmation88 }
			else            { it = alloc Dog88 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList88<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names89 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal89
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names89[rand() % names89.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog89 : Animal89
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation89 : Dog89
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList89<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff89()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog89 [5] {
			if i % 2 == 1   { it = alloc Dalmation89 }
			else            { it = alloc Dog89 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList89<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names90 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal90
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names90[rand() % names90.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog90 : Animal90
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation90 : Dog90
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList90<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff90()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog90 [5] {
			if i % 2 == 1   { it = alloc Dalmation90 }
			else            { it = alloc Dog90 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList90<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names91 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal91
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names91[rand() % names91.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog91 : Animal91
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation91 : Dog91
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList91<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff91()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog91 [5] {
			if i % 2 == 1   { it = alloc Dalmation91 }
			else            { it = alloc Dog91 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList91<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names92 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal92
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names92[rand() % names92.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog92 : Animal92
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation92 : Dog92
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList92<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff92()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog92 [5] {
			if i % 2 == 1   { it = alloc Dalmation92 }
			else            { it = alloc Dog92 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList92<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names93 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal93
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names93[rand() % names93.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog93 : Animal93
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation93 : Dog93
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList93<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff93()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog93 [5] {
			if i % 2 == 1   { it = alloc Dalmation93 }
			else            { it = alloc Dog93 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList93<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names94 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal94
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names94[rand() % names94.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog94 : Animal94
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation94 : Dog94
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList94<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff94()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog94 [5] {
			if i % 2 == 1   { it = alloc Dalmation94 }
			else            { it = alloc Dog94 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList94<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names95 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal95
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names95[rand() % names95.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog95 : Animal95
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation95 : Dog95
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList95<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff95()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog95 [5] {
			if i % 2 == 1   { it = alloc Dalmation95 }
			else            { it = alloc Dog95 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList95<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names96 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal96
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names96[rand() % names96.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog96 : Animal96
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation96 : Dog96
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList96<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff96()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog96 [5] {
			if i % 2 == 1   { it = alloc Dalmation96 }
			else            { it = alloc Dog96 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList96<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names97 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal97
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names97[rand() % names97.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog97 : Animal97
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation97 : Dog97
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList97<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff97()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog97 [5] {
			if i % 2 == 1   { it = alloc Dalmation97 }
			else            { it = alloc Dog97 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList97<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names98 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal98
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names98[rand() % names98.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog98 : Animal98
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation98 : Dog98
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList98<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff98()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog98 [5] {
			if i % 2 == 1   { it = alloc Dalmation98 }
			else            { it = alloc Dog98 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList98<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names99 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal99
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names99[rand() % names99.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog99 : Animal99
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation99 : Dog99
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList99<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff99()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog99 [5] {
			if i % 2 == 1   { it = alloc Dalmation99 }
			else            { it = alloc Dog99 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList99<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names100 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal100
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names100[rand() % names100.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog100 : Animal100
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation100 : Dog100
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList100<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff100()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog100 [5] {
			if i % 2 == 1   { it = alloc Dalmation100 }
			else            { it = alloc Dog100 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList100<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names101 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal101
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names101[rand() % names101.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog101 : Animal101
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation101 : Dog101
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList101<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff101()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog101 [5] {
			if i % 2 == 1   { it = alloc Dalmation101 }
			else            { it = alloc Dog101 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList101<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names102 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal102
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names102[rand() % names102.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog102 : Animal102
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation102 : Dog102
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList102<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff102()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog102 [5] {
			if i % 2 == 1   { it = alloc Dalmation102 }
			else            { it = alloc Dog102 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList102<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names103 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal103
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names103[rand() % names103.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog103 : Animal103
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation103 : Dog103
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList103<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff103()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog103 [5] {
			if i % 2 == 1   { it = alloc Dalmation103 }
			else            { it = alloc Dog103 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList103<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names104 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal104
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names104[rand() % names104.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog104 : Animal104
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation104 : Dog104
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList104<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff104()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog104 [5] {
			if i % 2 == 1   { it = alloc Dalmation104 }
			else            { it = alloc Dog104 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList104<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names105 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal105
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names105[rand() % names105.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog105 : Animal105
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation105 : Dog105
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList105<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff105()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog105 [5] {
			if i % 2 == 1   { it = alloc Dalmation105 }
			else            { it = alloc Dog105 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList105<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names106 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal106
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names106[rand() % names106.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog106 : Animal106
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation106 : Dog106
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList106<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff106()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog106 [5] {
			if i % 2 == 1   { it = alloc Dalmation106 }
			else            { it = alloc Dog106 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList106<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names107 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal107
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names107[rand() % names107.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog107 : Animal107
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation107 : Dog107
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList107<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff107()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog107 [5] {
			if i % 2 == 1   { it = alloc Dalmation107 }
			else            { it = alloc Dog107 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList107<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names108 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal108
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names108[rand() % names108.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog108 : Animal108
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation108 : Dog108
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList108<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff108()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog108 [5] {
			if i % 2 == 1   { it = alloc Dalmation108 }
			else            { it = alloc Dog108 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList108<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names109 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal109
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names109[rand() % names109.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog109 : Animal109
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation109 : Dog109
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList109<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff109()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog109 [5] {
			if i % 2 == 1   { it = alloc Dalmation109 }
			else            { it = alloc Dog109 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList109<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names110 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal110
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names110[rand() % names110.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog110 : Animal110
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation110 : Dog110
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList110<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff110()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog110 [5] {
			if i % 2 == 1   { it = alloc Dalmation110 }
			else            { it = alloc Dog110 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList110<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names111 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal111
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names111[rand() % names111.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog111 : Animal111
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation111 : Dog111
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList111<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff111()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog111 [5] {
			if i % 2 == 1   { it = alloc Dalmation111 }
			else            { it = alloc Dog111 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList111<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names112 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal112
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names112[rand() % names112.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog112 : Animal112
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation112 : Dog112
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList112<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff112()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog112 [5] {
			if i % 2 == 1   { it = alloc Dalmation112 }
			else            { it = alloc Dog112 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList112<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names113 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal113
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names113[rand() % names113.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog113 : Animal113
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation113 : Dog113
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList113<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff113()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog113 [5] {
			if i % 2 == 1   { it = alloc Dalmation113 }
			else            { it = alloc Dog113 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList113<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names114 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal114
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names114[rand() % names114.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog114 : Animal114
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation114 : Dog114
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList114<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff114()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog114 [5] {
			if i % 2 == 1   { it = alloc Dalmation114 }
			else            { it = alloc Dog114 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList114<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names115 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal115
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names115[rand() % names115.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog115 : Animal115
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation115 : Dog115
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList115<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff115()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog115 [5] {
			if i % 2 == 1   { it = alloc Dalmation115 }
			else            { it = alloc Dog115 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList115<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names116 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal116
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names116[rand() % names116.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog116 : Animal116
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation116 : Dog116
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList116<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff116()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog116 [5] {
			if i % 2 == 1   { it = alloc Dalmation116 }
			else            { it = alloc Dog116 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList116<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names117 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal117
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names117[rand() % names117.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog117 : Animal117
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation117 : Dog117
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList117<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff117()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog117 [5] {
			if i % 2 == 1   { it = alloc Dalmation117 }
			else            { it = alloc Dog117 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList117<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names118 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal118
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names118[rand() % names118.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog118 : Animal118
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation118 : Dog118
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList118<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff118()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog118 [5] {
			if i % 2 == 1   { it = alloc Dalmation118 }
			else            { it = alloc Dog118 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList118<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names119 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal119
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names119[rand() % names119.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog119 : Animal119
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation119 : Dog119
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList119<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff119()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog119 [5] {
			if i % 2 == 1   { it = alloc Dalmation119 }
			else            { it = alloc Dog119 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList119<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names120 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal120
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names120[rand() % names120.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog120 : Animal120
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation120 : Dog120
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList120<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff120()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog120 [5] {
			if i % 2 == 1   { it = alloc Dalmation120 }
			else            { it = alloc Dog120 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList120<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names121 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal121
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names121[rand() % names121.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog121 : Animal121
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation121 : Dog121
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList121<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff121()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog121 [5] {
			if i % 2 == 1   { it = alloc Dalmation121 }
			else            { it = alloc Dog121 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList121<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names122 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal122
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names122[rand() % names122.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog122 : Animal122
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation122 : Dog122
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList122<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff122()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog122 [5] {
			if i % 2 == 1   { it = alloc Dalmation122 }
			else            { it = alloc Dog122 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList122<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names123 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal123
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names123[rand() % names123.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog123 : Animal123
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation123 : Dog123
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList123<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff123()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog123 [5] {
			if i % 2 == 1   { it = alloc Dalmation123 }
			else            { it = alloc Dog123 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList123<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names124 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal124
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names124[rand() % names124.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog124 : Animal124
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation124 : Dog124
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList124<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff124()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog124 [5] {
			if i % 2 == 1   { it = alloc Dalmation124 }
			else            { it = alloc Dog124 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList124<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names125 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal125
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names125[rand() % names125.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog125 : Animal125
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation125 : Dog125
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList125<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff125()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog125 [5] {
			if i % 2 == 1   { it = alloc Dalmation125 }
			else            { it = alloc Dog125 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList125<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names126 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal126
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names126[rand() % names126.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog126 : Animal126
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation126 : Dog126
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList126<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff126()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog126 [5] {
			if i % 2 == 1   { it = alloc Dalmation126 }
			else            { it = alloc Dog126 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList126<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names127 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal127
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names127[rand() % names127.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog127 : Animal127
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation127 : Dog127
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList127<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff127()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog127 [5] {
			if i % 2 == 1   { it = alloc Dalmation127 }
			else            { it = alloc Dog127 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList127<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names128 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal128
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names128[rand() % names128.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog128 : Animal128
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation128 : Dog128
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList128<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff128()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog128 [5] {
			if i % 2 == 1   { it = alloc Dalmation128 }
			else            { it = alloc Dog128 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList128<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names129 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal129
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names129[rand() % names129.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog129 : Animal129
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation129 : Dog129
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList129<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff129()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog129 [5] {
			if i % 2 == 1   { it = alloc Dalmation129 }
			else            { it = alloc Dog129 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList129<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names130 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal130
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names130[rand() % names130.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog130 : Animal130
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation130 : Dog130
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList130<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff130()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog130 [5] {
			if i % 2 == 1   { it = alloc Dalmation130 }
			else            { it = alloc Dog130 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList130<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names131 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal131
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names131[rand() % names131.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog131 : Animal131
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation131 : Dog131
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList131<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff131()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog131 [5] {
			if i % 2 == 1   { it = alloc Dalmation131 }
			else            { it = alloc Dog131 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList131<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names132 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal132
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names132[rand() % names132.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog132 : Animal132
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation132 : Dog132
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList132<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff132()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog132 [5] {
			if i % 2 == 1   { it = alloc Dalmation132 }
			else            { it = alloc Dog132 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList132<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names133 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal133
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names133[rand() % names133.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog133 : Animal133
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation133 : Dog133
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList133<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff133()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog133 [5] {
			if i % 2 == 1   { it = alloc Dalmation133 }
			else            { it = alloc Dog133 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList133<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names134 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal134
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names134[rand() % names134.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog134 : Animal134
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation134 : Dog134
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList134<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff134()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog134 [5] {
			if i % 2 == 1   { it = alloc Dalmation134 }
			else            { it = alloc Dog134 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList134<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names135 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal135
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names135[rand() % names135.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog135 : Animal135
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation135 : Dog135
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList135<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff135()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog135 [5] {
			if i % 2 == 1   { it = alloc Dalmation135 }
			else            { it = alloc Dog135 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList135<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names136 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal136
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names136[rand() % names136.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog136 : Animal136
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation136 : Dog136
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList136<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff136()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog136 [5] {
			if i % 2 == 1   { it = alloc Dalmation136 }
			else            { it = alloc Dog136 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList136<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names137 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal137
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names137[rand() % names137.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog137 : Animal137
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation137 : Dog137
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList137<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff137()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog137 [5] {
			if i % 2 == 1   { it = alloc Dalmation137 }
			else            { it = alloc Dog137 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList137<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names138 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal138
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names138[rand() % names138.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog138 : Animal138
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation138 : Dog138
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList138<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff138()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog138 [5] {
			if i % 2 == 1   { it = alloc Dalmation138 }
			else            { it = alloc Dog138 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList138<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names139 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal139
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names139[rand() % names139.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog139 : Animal139
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation139 : Dog139
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList139<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff139()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog139 [5] {
			if i % 2 == 1   { it = alloc Dalmation139 }
			else            { it = alloc Dog139 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList139<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names140 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal140
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names140[rand() % names140.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog140 : Animal140
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation140 : Dog140
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList140<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff140()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog140 [5] {
			if i % 2 == 1   { it = alloc Dalmation140 }
			else            { it = alloc Dog140 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList140<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names141 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal141
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names141[rand() % names141.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog141 : Animal141
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation141 : Dog141
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList141<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff141()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog141 [5] {
			if i % 2 == 1   { it = alloc Dalmation141 }
			else            { it = alloc Dog141 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList141<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names142 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal142
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names142[rand() % names142.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog142 : Animal142
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation142 : Dog142
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList142<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff142()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog142 [5] {
			if i % 2 == 1   { it = alloc Dalmation142 }
			else            { it = alloc Dog142 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList142<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names143 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal143
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names143[rand() % names143.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog143 : Animal143
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation143 : Dog143
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList143<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff143()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog143 [5] {
			if i % 2 == 1   { it = alloc Dalmation143 }
			else            { it = alloc Dog143 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList143<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names144 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal144
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names144[rand() % names144.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog144 : Animal144
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation144 : Dog144
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList144<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff144()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog144 [5] {
			if i % 2 == 1   { it = alloc Dalmation144 }
			else            { it = alloc Dog144 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList144<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names145 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal145
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names145[rand() % names145.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog145 : Animal145
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation145 : Dog145
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList145<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff145()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog145 [5] {
			if i % 2 == 1   { it = alloc Dalmation145 }
			else            { it = alloc Dog145 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList145<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names146 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal146
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names146[rand() % names146.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog146 : Animal146
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation146 : Dog146
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList146<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff146()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog146 [5] {
			if i % 2 == 1   { it = alloc Dalmation146 }
			else            { it = alloc Dog146 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList146<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names147 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal147
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names147[rand() % names147.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog147 : Animal147
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation147 : Dog147
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList147<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff147()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog147 [5] {
			if i % 2 == 1   { it = alloc Dalmation147 }
			else            { it = alloc Dog147 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList147<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names148 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal148
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names148[rand() % names148.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog148 : Animal148
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation148 : Dog148
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList148<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff148()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog148 [5] {
			if i % 2 == 1   { it = alloc Dalmation148 }
			else            { it = alloc Dog148 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList148<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names149 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal149
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names149[rand() % names149.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog149 : Animal149
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation149 : Dog149
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList149<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff149()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog149 [5] {
			if i % 2 == 1   { it = alloc Dalmation149 }
			else            { it = alloc Dog149 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList149<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names150 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal150
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names150[rand() % names150.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog150 : Animal150
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation150 : Dog150
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList150<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff150()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog150 [5] {
			if i % 2 == 1   { it = alloc Dalmation150 }
			else            { it = alloc Dog150 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList150<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names151 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal151
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names151[rand() % names151.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog151 : Animal151
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation151 : Dog151
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList151<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff151()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog151 [5] {
			if i % 2 == 1   { it = alloc Dalmation151 }
			else            { it = alloc Dog151 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList151<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names152 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal152
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names152[rand() % names152.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog152 : Animal152
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation152 : Dog152
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList152<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff152()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog152 [5] {
			if i % 2 == 1   { it = alloc Dalmation152 }
			else            { it = alloc Dog152 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList152<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names153 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal153
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names153[rand() % names153.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog153 : Animal153
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation153 : Dog153
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList153<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff153()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog153 [5] {
			if i % 2 == 1   { it = alloc Dalmation153 }
			else            { it = alloc Dog153 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList153<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names154 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal154
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names154[rand() % names154.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog154 : Animal154
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation154 : Dog154
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList154<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff154()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog154 [5] {
			if i % 2 == 1   { it = alloc Dalmation154 }
			else            { it = alloc Dog154 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList154<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names155 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal155
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names155[rand() % names155.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog155 : Animal155
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation155 : Dog155
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList155<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff155()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog155 [5] {
			if i % 2 == 1   { it = alloc Dalmation155 }
			else            { it = alloc Dog155 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList155<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names156 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal156
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names156[rand() % names156.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog156 : Animal156
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation156 : Dog156
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList156<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff156()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog156 [5] {
			if i % 2 == 1   { it = alloc Dalmation156 }
			else            { it = alloc Dog156 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList156<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names157 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal157
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names157[rand() % names157.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog157 : Animal157
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation157 : Dog157
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList157<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff157()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog157 [5] {
			if i % 2 == 1   { it = alloc Dalmation157 }
			else            { it = alloc Dog157 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList157<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names158 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal158
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names158[rand() % names158.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog158 : Animal158
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation158 : Dog158
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList158<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff158()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog158 [5] {
			if i % 2 == 1   { it = alloc Dalmation158 }
			else            { it = alloc Dog158 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList158<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names159 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal159
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names159[rand() % names159.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog159 : Animal159
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation159 : Dog159
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList159<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff159()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog159 [5] {
			if i % 2 == 1   { it = alloc Dalmation159 }
			else            { it = alloc Dog159 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList159<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names160 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal160
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names160[rand() % names160.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog160 : Animal160
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation160 : Dog160
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList160<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff160()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog160 [5] {
			if i % 2 == 1   { it = alloc Dalmation160 }
			else            { it = alloc Dog160 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList160<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names161 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal161
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names161[rand() % names161.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog161 : Animal161
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation161 : Dog161
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList161<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff161()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog161 [5] {
			if i % 2 == 1   { it = alloc Dalmation161 }
			else            { it = alloc Dog161 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList161<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names162 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal162
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names162[rand() % names162.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog162 : Animal162
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation162 : Dog162
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList162<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff162()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog162 [5] {
			if i % 2 == 1   { it = alloc Dalmation162 }
			else            { it = alloc Dog162 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList162<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names163 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal163
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names163[rand() % names163.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog163 : Animal163
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation163 : Dog163
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList163<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff163()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog163 [5] {
			if i % 2 == 1   { it = alloc Dalmation163 }
			else            { it = alloc Dog163 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList163<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names164 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal164
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names164[rand() % names164.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog164 : Animal164
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation164 : Dog164
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList164<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff164()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog164 [5] {
			if i % 2 == 1   { it = alloc Dalmation164 }
			else            { it = alloc Dog164 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList164<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names165 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal165
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names165[rand() % names165.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog165 : Animal165
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation165 : Dog165
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList165<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff165()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog165 [5] {
			if i % 2 == 1   { it = alloc Dalmation165 }
			else            { it = alloc Dog165 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList165<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names166 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal166
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names166[rand() % names166.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog166 : Animal166
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation166 : Dog166
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList166<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff166()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog166 [5] {
			if i % 2 == 1   { it = alloc Dalmation166 }
			else            { it = alloc Dog166 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList166<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names167 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal167
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names167[rand() % names167.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog167 : Animal167
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation167 : Dog167
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList167<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff167()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog167 [5] {
			if i % 2 == 1   { it = alloc Dalmation167 }
			else            { it = alloc Dog167 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList167<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names168 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal168
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names168[rand() % names168.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog168 : Animal168
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation168 : Dog168
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList168<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff168()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog168 [5] {
			if i % 2 == 1   { it = alloc Dalmation168 }
			else            { it = alloc Dog168 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList168<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names169 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal169
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names169[rand() % names169.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog169 : Animal169
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation169 : Dog169
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList169<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff169()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog169 [5] {
			if i % 2 == 1   { it = alloc Dalmation169 }
			else            { it = alloc Dog169 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList169<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names170 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal170
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names170[rand() % names170.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog170 : Animal170
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation170 : Dog170
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList170<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff170()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog170 [5] {
			if i % 2 == 1   { it = alloc Dalmation170 }
			else            { it = alloc Dog170 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList170<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names171 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal171
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names171[rand() % names171.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog171 : Animal171
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation171 : Dog171
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList171<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff171()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog171 [5] {
			if i % 2 == 1   { it = alloc Dalmation171 }
			else            { it = alloc Dog171 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList171<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names172 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal172
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names172[rand() % names172.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog172 : Animal172
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation172 : Dog172
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList172<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff172()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog172 [5] {
			if i % 2 == 1   { it = alloc Dalmation172 }
			else            { it = alloc Dog172 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList172<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names173 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal173
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names173[rand() % names173.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog173 : Animal173
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation173 : Dog173
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList173<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff173()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog173 [5] {
			if i % 2 == 1   { it = alloc Dalmation173 }
			else            { it = alloc Dog173 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList173<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names174 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal174
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names174[rand() % names174.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog174 : Animal174
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation174 : Dog174
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList174<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff174()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog174 [5] {
			if i % 2 == 1   { it = alloc Dalmation174 }
			else            { it = alloc Dog174 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList174<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names175 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal175
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names175[rand() % names175.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog175 : Animal175
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation175 : Dog175
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList175<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff175()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog175 [5] {
			if i % 2 == 1   { it = alloc Dalmation175 }
			else            { it = alloc Dog175 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList175<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names176 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal176
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names176[rand() % names176.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog176 : Animal176
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation176 : Dog176
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList176<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff176()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog176 [5] {
			if i % 2 == 1   { it = alloc Dalmation176 }
			else            { it = alloc Dog176 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList176<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names177 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal177
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names177[rand() % names177.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog177 : Animal177
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation177 : Dog177
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList177<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff177()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog177 [5] {
			if i % 2 == 1   { it = alloc Dalmation177 }
			else            { it = alloc Dog177 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList177<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names178 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal178
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names178[rand() % names178.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog178 : Animal178
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation178 : Dog178
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList178<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff178()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog178 [5] {
			if i % 2 == 1   { it = alloc Dalmation178 }
			else            { it = alloc Dog178 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList178<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names179 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal179
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names179[rand() % names179.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog179 : Animal179
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation179 : Dog179
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList179<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff179()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog179 [5] {
			if i % 2 == 1   { it = alloc Dalmation179 }
			else            { it = alloc Dog179 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList179<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names180 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal180
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names180[rand() % names180.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog180 : Animal180
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation180 : Dog180
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList180<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff180()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog180 [5] {
			if i % 2 == 1   { it = alloc Dalmation180 }
			else            { it = alloc Dog180 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList180<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names181 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal181
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names181[rand() % names181.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog181 : Animal181
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation181 : Dog181
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList181<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff181()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog181 [5] {
			if i % 2 == 1   { it = alloc Dalmation181 }
			else            { it = alloc Dog181 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList181<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names182 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal182
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names182[rand() % names182.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog182 : Animal182
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation182 : Dog182
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList182<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff182()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog182 [5] {
			if i % 2 == 1   { it = alloc Dalmation182 }
			else            { it = alloc Dog182 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList182<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names183 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal183
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names183[rand() % names183.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog183 : Animal183
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation183 : Dog183
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList183<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff183()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog183 [5] {
			if i % 2 == 1   { it = alloc Dalmation183 }
			else            { it = alloc Dog183 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList183<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names184 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal184
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names184[rand() % names184.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog184 : Animal184
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation184 : Dog184
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList184<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff184()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog184 [5] {
			if i % 2 == 1   { it = alloc Dalmation184 }
			else            { it = alloc Dog184 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList184<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names185 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal185
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names185[rand() % names185.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog185 : Animal185
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation185 : Dog185
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList185<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff185()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog185 [5] {
			if i % 2 == 1   { it = alloc Dalmation185 }
			else            { it = alloc Dog185 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList185<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names186 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal186
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names186[rand() % names186.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog186 : Animal186
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation186 : Dog186
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList186<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff186()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog186 [5] {
			if i % 2 == 1   { it = alloc Dalmation186 }
			else            { it = alloc Dog186 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList186<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names187 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal187
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names187[rand() % names187.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog187 : Animal187
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation187 : Dog187
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList187<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff187()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog187 [5] {
			if i % 2 == 1   { it = alloc Dalmation187 }
			else            { it = alloc Dog187 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList187<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names188 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal188
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names188[rand() % names188.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog188 : Animal188
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation188 : Dog188
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList188<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff188()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog188 [5] {
			if i % 2 == 1   { it = alloc Dalmation188 }
			else            { it = alloc Dog188 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList188<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names189 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal189
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names189[rand() % names189.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog189 : Animal189
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation189 : Dog189
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList189<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff189()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog189 [5] {
			if i % 2 == 1   { it = alloc Dalmation189 }
			else            { it = alloc Dog189 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList189<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names190 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal190
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names190[rand() % names190.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog190 : Animal190
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation190 : Dog190
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList190<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff190()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog190 [5] {
			if i % 2 == 1   { it = alloc Dalmation190 }
			else            { it = alloc Dog190 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList190<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names191 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal191
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names191[rand() % names191.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog191 : Animal191
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation191 : Dog191
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList191<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff191()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog191 [5] {
			if i % 2 == 1   { it = alloc Dalmation191 }
			else            { it = alloc Dog191 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList191<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names192 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal192
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names192[rand() % names192.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog192 : Animal192
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation192 : Dog192
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList192<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff192()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog192 [5] {
			if i % 2 == 1   { it = alloc Dalmation192 }
			else            { it = alloc Dog192 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList192<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names193 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal193
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names193[rand() % names193.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog193 : Animal193
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation193 : Dog193
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList193<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff193()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog193 [5] {
			if i % 2 == 1   { it = alloc Dalmation193 }
			else            { it = alloc Dog193 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList193<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names194 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal194
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names194[rand() % names194.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog194 : Animal194
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation194 : Dog194
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList194<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff194()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog194 [5] {
			if i % 2 == 1   { it = alloc Dalmation194 }
			else            { it = alloc Dog194 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList194<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names195 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal195
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names195[rand() % names195.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog195 : Animal195
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation195 : Dog195
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList195<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff195()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog195 [5] {
			if i % 2 == 1   { it = alloc Dalmation195 }
			else            { it = alloc Dog195 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList195<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names196 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal196
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names196[rand() % names196.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog196 : Animal196
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation196 : Dog196
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList196<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff196()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog196 [5] {
			if i % 2 == 1   { it = alloc Dalmation196 }
			else            { it = alloc Dog196 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList196<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names197 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal197
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names197[rand() % names197.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog197 : Animal197
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation197 : Dog197
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList197<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff197()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog197 [5] {
			if i % 2 == 1   { it = alloc Dalmation197 }
			else            { it = alloc Dog197 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList197<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names198 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal198
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names198[rand() % names198.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog198 : Animal198
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation198 : Dog198
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList198<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff198()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog198 [5] {
			if i % 2 == 1   { it = alloc Dalmation198 }
			else            { it = alloc Dog198 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList198<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names199 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal199
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names199[rand() % names199.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog199 : Animal199
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation199 : Dog199
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList199<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff199()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog199 [5] {
			if i % 2 == 1   { it = alloc Dalmation199 }
			else            { it = alloc Dog199 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList199<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names200 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal200
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names200[rand() % names200.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog200 : Animal200
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation200 : Dog200
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList200<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff200()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog200 [5] {
			if i % 2 == 1   { it = alloc Dalmation200 }
			else            { it = alloc Dog200 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList200<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names201 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal201
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names201[rand() % names201.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog201 : Animal201
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation201 : Dog201
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList201<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff201()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog201 [5] {
			if i % 2 == 1   { it = alloc Dalmation201 }
			else            { it = alloc Dog201 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList201<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names202 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal202
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names202[rand() % names202.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog202 : Animal202
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation202 : Dog202
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList202<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff202()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog202 [5] {
			if i % 2 == 1   { it = alloc Dalmation202 }
			else            { it = alloc Dog202 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList202<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names203 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal203
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names203[rand() % names203.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog203 : Animal203
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation203 : Dog203
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList203<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff203()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog203 [5] {
			if i % 2 == 1   { it = alloc Dalmation203 }
			else            { it = alloc Dog203 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList203<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names204 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal204
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names204[rand() % names204.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog204 : Animal204
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation204 : Dog204
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList204<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff204()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog204 [5] {
			if i % 2 == 1   { it = alloc Dalmation204 }
			else            { it = alloc Dog204 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList204<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names205 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal205
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names205[rand() % names205.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog205 : Animal205
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation205 : Dog205
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList205<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff205()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog205 [5] {
			if i % 2 == 1   { it = alloc Dalmation205 }
			else            { it = alloc Dog205 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList205<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names206 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal206
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names206[rand() % names206.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog206 : Animal206
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation206 : Dog206
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList206<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff206()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog206 [5] {
			if i % 2 == 1   { it = alloc Dalmation206 }
			else            { it = alloc Dog206 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList206<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names207 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal207
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names207[rand() % names207.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog207 : Animal207
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation207 : Dog207
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList207<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff207()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog207 [5] {
			if i % 2 == 1   { it = alloc Dalmation207 }
			else            { it = alloc Dog207 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList207<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names208 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal208
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names208[rand() % names208.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog208 : Animal208
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation208 : Dog208
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList208<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff208()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog208 [5] {
			if i % 2 == 1   { it = alloc Dalmation208 }
			else            { it = alloc Dog208 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList208<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names209 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal209
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names209[rand() % names209.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog209 : Animal209
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation209 : Dog209
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList209<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff209()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog209 [5] {
			if i % 2 == 1   { it = alloc Dalmation209 }
			else            { it = alloc Dog209 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList209<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names210 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal210
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names210[rand() % names210.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog210 : Animal210
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation210 : Dog210
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList210<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff210()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog210 [5] {
			if i % 2 == 1   { it = alloc Dalmation210 }
			else            { it = alloc Dog210 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList210<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names211 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal211
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names211[rand() % names211.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog211 : Animal211
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation211 : Dog211
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList211<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff211()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog211 [5] {
			if i % 2 == 1   { it = alloc Dalmation211 }
			else            { it = alloc Dog211 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList211<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names212 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal212
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names212[rand() % names212.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog212 : Animal212
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation212 : Dog212
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList212<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff212()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog212 [5] {
			if i % 2 == 1   { it = alloc Dalmation212 }
			else            { it = alloc Dog212 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList212<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names213 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal213
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names213[rand() % names213.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog213 : Animal213
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation213 : Dog213
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList213<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff213()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog213 [5] {
			if i % 2 == 1   { it = alloc Dalmation213 }
			else            { it = alloc Dog213 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList213<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names214 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal214
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names214[rand() % names214.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog214 : Animal214
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation214 : Dog214
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList214<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff214()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog214 [5] {
			if i % 2 == 1   { it = alloc Dalmation214 }
			else            { it = alloc Dog214 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList214<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names215 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal215
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names215[rand() % names215.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog215 : Animal215
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation215 : Dog215
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList215<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff215()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog215 [5] {
			if i % 2 == 1   { it = alloc Dalmation215 }
			else            { it = alloc Dog215 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList215<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names216 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal216
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names216[rand() % names216.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog216 : Animal216
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation216 : Dog216
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList216<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff216()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog216 [5] {
			if i % 2 == 1   { it = alloc Dalmation216 }
			else            { it = alloc Dog216 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList216<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names217 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal217
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names217[rand() % names217.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog217 : Animal217
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation217 : Dog217
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList217<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff217()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog217 [5] {
			if i % 2 == 1   { it = alloc Dalmation217 }
			else            { it = alloc Dog217 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList217<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names218 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal218
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names218[rand() % names218.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog218 : Animal218
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation218 : Dog218
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList218<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff218()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog218 [5] {
			if i % 2 == 1   { it = alloc Dalmation218 }
			else            { it = alloc Dog218 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList218<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names219 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal219
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names219[rand() % names219.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog219 : Animal219
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation219 : Dog219
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList219<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff219()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog219 [5] {
			if i % 2 == 1   { it = alloc Dalmation219 }
			else            { it = alloc Dog219 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList219<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names220 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal220
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names220[rand() % names220.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog220 : Animal220
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation220 : Dog220
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList220<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff220()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog220 [5] {
			if i % 2 == 1   { it = alloc Dalmation220 }
			else            { it = alloc Dog220 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList220<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names221 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal221
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names221[rand() % names221.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog221 : Animal221
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation221 : Dog221
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList221<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff221()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog221 [5] {
			if i % 2 == 1   { it = alloc Dalmation221 }
			else            { it = alloc Dog221 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList221<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names222 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal222
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names222[rand() % names222.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog222 : Animal222
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation222 : Dog222
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList222<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff222()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog222 [5] {
			if i % 2 == 1   { it = alloc Dalmation222 }
			else            { it = alloc Dog222 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList222<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names223 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal223
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names223[rand() % names223.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog223 : Animal223
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation223 : Dog223
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList223<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff223()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog223 [5] {
			if i % 2 == 1   { it = alloc Dalmation223 }
			else            { it = alloc Dog223 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList223<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names224 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal224
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names224[rand() % names224.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog224 : Animal224
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation224 : Dog224
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList224<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff224()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog224 [5] {
			if i % 2 == 1   { it = alloc Dalmation224 }
			else            { it = alloc Dog224 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList224<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names225 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal225
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names225[rand() % names225.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog225 : Animal225
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation225 : Dog225
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList225<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff225()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog225 [5] {
			if i % 2 == 1   { it = alloc Dalmation225 }
			else            { it = alloc Dog225 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList225<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names226 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal226
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names226[rand() % names226.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog226 : Animal226
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation226 : Dog226
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList226<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff226()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog226 [5] {
			if i % 2 == 1   { it = alloc Dalmation226 }
			else            { it = alloc Dog226 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList226<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names227 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal227
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names227[rand() % names227.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog227 : Animal227
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation227 : Dog227
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList227<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff227()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog227 [5] {
			if i % 2 == 1   { it = alloc Dalmation227 }
			else            { it = alloc Dog227 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList227<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names228 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal228
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names228[rand() % names228.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog228 : Animal228
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation228 : Dog228
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList228<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff228()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog228 [5] {
			if i % 2 == 1   { it = alloc Dalmation228 }
			else            { it = alloc Dog228 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList228<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names229 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal229
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names229[rand() % names229.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog229 : Animal229
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation229 : Dog229
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList229<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff229()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog229 [5] {
			if i % 2 == 1   { it = alloc Dalmation229 }
			else            { it = alloc Dog229 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList229<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names230 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal230
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names230[rand() % names230.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog230 : Animal230
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation230 : Dog230
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList230<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff230()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog230 [5] {
			if i % 2 == 1   { it = alloc Dalmation230 }
			else            { it = alloc Dog230 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList230<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names231 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal231
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names231[rand() % names231.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog231 : Animal231
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation231 : Dog231
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList231<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff231()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog231 [5] {
			if i % 2 == 1   { it = alloc Dalmation231 }
			else            { it = alloc Dog231 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList231<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names232 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal232
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names232[rand() % names232.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog232 : Animal232
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation232 : Dog232
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList232<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff232()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog232 [5] {
			if i % 2 == 1   { it = alloc Dalmation232 }
			else            { it = alloc Dog232 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList232<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names233 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal233
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names233[rand() % names233.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog233 : Animal233
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation233 : Dog233
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList233<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff233()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog233 [5] {
			if i % 2 == 1   { it = alloc Dalmation233 }
			else            { it = alloc Dog233 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList233<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names234 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal234
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names234[rand() % names234.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog234 : Animal234
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation234 : Dog234
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList234<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff234()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog234 [5] {
			if i % 2 == 1   { it = alloc Dalmation234 }
			else            { it = alloc Dog234 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList234<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names235 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal235
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names235[rand() % names235.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog235 : Animal235
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation235 : Dog235
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList235<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff235()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog235 [5] {
			if i % 2 == 1   { it = alloc Dalmation235 }
			else            { it = alloc Dog235 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList235<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names236 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal236
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names236[rand() % names236.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog236 : Animal236
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation236 : Dog236
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList236<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff236()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog236 [5] {
			if i % 2 == 1   { it = alloc Dalmation236 }
			else            { it = alloc Dog236 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList236<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names237 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal237
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names237[rand() % names237.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog237 : Animal237
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation237 : Dog237
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList237<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff237()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog237 [5] {
			if i % 2 == 1   { it = alloc Dalmation237 }
			else            { it = alloc Dog237 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList237<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names238 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal238
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names238[rand() % names238.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog238 : Animal238
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation238 : Dog238
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList238<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff238()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog238 [5] {
			if i % 2 == 1   { it = alloc Dalmation238 }
			else            { it = alloc Dog238 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList238<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names239 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal239
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names239[rand() % names239.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog239 : Animal239
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation239 : Dog239
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList239<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff239()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog239 [5] {
			if i % 2 == 1   { it = alloc Dalmation239 }
			else            { it = alloc Dog239 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList239<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names240 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal240
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names240[rand() % names240.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog240 : Animal240
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation240 : Dog240
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList240<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff240()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog240 [5] {
			if i % 2 == 1   { it = alloc Dalmation240 }
			else            { it = alloc Dog240 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList240<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names241 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal241
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names241[rand() % names241.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog241 : Animal241
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation241 : Dog241
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList241<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff241()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog241 [5] {
			if i % 2 == 1   { it = alloc Dalmation241 }
			else            { it = alloc Dog241 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList241<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names242 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal242
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names242[rand() % names242.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog242 : Animal242
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation242 : Dog242
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList242<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff242()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog242 [5] {
			if i % 2 == 1   { it = alloc Dalmation242 }
			else            { it = alloc Dog242 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList242<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names243 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal243
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names243[rand() % names243.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog243 : Animal243
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation243 : Dog243
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList243<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff243()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog243 [5] {
			if i % 2 == 1   { it = alloc Dalmation243 }
			else            { it = alloc Dog243 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList243<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names244 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal244
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names244[rand() % names244.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog244 : Animal244
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation244 : Dog244
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList244<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff244()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog244 [5] {
			if i % 2 == 1   { it = alloc Dalmation244 }
			else            { it = alloc Dog244 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList244<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names245 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal245
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names245[rand() % names245.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog245 : Animal245
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation245 : Dog245
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList245<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff245()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog245 [5] {
			if i % 2 == 1   { it = alloc Dalmation245 }
			else            { it = alloc Dog245 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList245<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names246 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal246
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names246[rand() % names246.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog246 : Animal246
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation246 : Dog246
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList246<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff246()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog246 [5] {
			if i % 2 == 1   { it = alloc Dalmation246 }
			else            { it = alloc Dog246 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList246<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names247 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal247
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names247[rand() % names247.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog247 : Animal247
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation247 : Dog247
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList247<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff247()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog247 [5] {
			if i % 2 == 1   { it = alloc Dalmation247 }
			else            { it = alloc Dog247 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList247<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names248 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal248
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names248[rand() % names248.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog248 : Animal248
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation248 : Dog248
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList248<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff248()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog248 [5] {
			if i % 2 == 1   { it = alloc Dalmation248 }
			else            { it = alloc Dog248 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList248<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names249 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal249
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names249[rand() % names249.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog249 : Animal249
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation249 : Dog249
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList249<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff249()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog249 [5] {
			if i % 2 == 1   { it = alloc Dalmation249 }
			else            { it = alloc Dog249 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList249<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names250 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal250
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names250[rand() % names250.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog250 : Animal250
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation250 : Dog250
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList250<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff250()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog250 [5] {
			if i % 2 == 1   { it = alloc Dalmation250 }
			else            { it = alloc Dog250 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList250<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names251 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal251
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names251[rand() % names251.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog251 : Animal251
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation251 : Dog251
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList251<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff251()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog251 [5] {
			if i % 2 == 1   { it = alloc Dalmation251 }
			else            { it = alloc Dog251 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList251<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names252 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal252
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names252[rand() % names252.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog252 : Animal252
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation252 : Dog252
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList252<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff252()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog252 [5] {
			if i % 2 == 1   { it = alloc Dalmation252 }
			else            { it = alloc Dog252 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList252<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names253 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal253
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names253[rand() % names253.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog253 : Animal253
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation253 : Dog253
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList253<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff253()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog253 [5] {
			if i % 2 == 1   { it = alloc Dalmation253 }
			else            { it = alloc Dog253 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList253<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names254 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal254
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names254[rand() % names254.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog254 : Animal254
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation254 : Dog254
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList254<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff254()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog254 [5] {
			if i % 2 == 1   { it = alloc Dalmation254 }
			else            { it = alloc Dog254 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList254<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names255 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal255
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names255[rand() % names255.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog255 : Animal255
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation255 : Dog255
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList255<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff255()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog255 [5] {
			if i % 2 == 1   { it = alloc Dalmation255 }
			else            { it = alloc Dog255 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList255<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names256 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal256
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names256[rand() % names256.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog256 : Animal256
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation256 : Dog256
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList256<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff256()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog256 [5] {
			if i % 2 == 1   { it = alloc Dalmation256 }
			else            { it = alloc Dog256 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList256<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names257 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal257
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names257[rand() % names257.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog257 : Animal257
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation257 : Dog257
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList257<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff257()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog257 [5] {
			if i % 2 == 1   { it = alloc Dalmation257 }
			else            { it = alloc Dog257 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList257<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names258 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal258
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names258[rand() % names258.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog258 : Animal258
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation258 : Dog258
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList258<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff258()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog258 [5] {
			if i % 2 == 1   { it = alloc Dalmation258 }
			else            { it = alloc Dog258 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList258<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names259 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal259
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names259[rand() % names259.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog259 : Animal259
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation259 : Dog259
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList259<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff259()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog259 [5] {
			if i % 2 == 1   { it = alloc Dalmation259 }
			else            { it = alloc Dog259 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList259<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names260 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal260
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names260[rand() % names260.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog260 : Animal260
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation260 : Dog260
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList260<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff260()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog260 [5] {
			if i % 2 == 1   { it = alloc Dalmation260 }
			else            { it = alloc Dog260 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList260<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names261 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal261
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names261[rand() % names261.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog261 : Animal261
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation261 : Dog261
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList261<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff261()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog261 [5] {
			if i % 2 == 1   { it = alloc Dalmation261 }
			else            { it = alloc Dog261 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList261<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names262 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal262
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names262[rand() % names262.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog262 : Animal262
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation262 : Dog262
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList262<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff262()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog262 [5] {
			if i % 2 == 1   { it = alloc Dalmation262 }
			else            { it = alloc Dog262 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList262<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names263 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal263
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names263[rand() % names263.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog263 : Animal263
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation263 : Dog263
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList263<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff263()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog263 [5] {
			if i % 2 == 1   { it = alloc Dalmation263 }
			else            { it = alloc Dog263 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList263<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names264 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal264
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names264[rand() % names264.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog264 : Animal264
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation264 : Dog264
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList264<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff264()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog264 [5] {
			if i % 2 == 1   { it = alloc Dalmation264 }
			else            { it = alloc Dog264 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList264<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names265 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal265
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names265[rand() % names265.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog265 : Animal265
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation265 : Dog265
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList265<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff265()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog265 [5] {
			if i % 2 == 1   { it = alloc Dalmation265 }
			else            { it = alloc Dog265 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList265<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names266 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal266
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names266[rand() % names266.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog266 : Animal266
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation266 : Dog266
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList266<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff266()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog266 [5] {
			if i % 2 == 1   { it = alloc Dalmation266 }
			else            { it = alloc Dog266 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList266<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names267 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal267
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names267[rand() % names267.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog267 : Animal267
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation267 : Dog267
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList267<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff267()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog267 [5] {
			if i % 2 == 1   { it = alloc Dalmation267 }
			else            { it = alloc Dog267 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList267<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names268 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal268
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names268[rand() % names268.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog268 : Animal268
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation268 : Dog268
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList268<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff268()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog268 [5] {
			if i % 2 == 1   { it = alloc Dalmation268 }
			else            { it = alloc Dog268 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList268<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names269 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal269
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names269[rand() % names269.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog269 : Animal269
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation269 : Dog269
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList269<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff269()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog269 [5] {
			if i % 2 == 1   { it = alloc Dalmation269 }
			else            { it = alloc Dog269 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList269<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names270 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal270
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names270[rand() % names270.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog270 : Animal270
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation270 : Dog270
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList270<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff270()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog270 [5] {
			if i % 2 == 1   { it = alloc Dalmation270 }
			else            { it = alloc Dog270 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList270<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names271 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal271
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names271[rand() % names271.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog271 : Animal271
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation271 : Dog271
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList271<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff271()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog271 [5] {
			if i % 2 == 1   { it = alloc Dalmation271 }
			else            { it = alloc Dog271 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList271<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names272 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal272
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names272[rand() % names272.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog272 : Animal272
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation272 : Dog272
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList272<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff272()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog272 [5] {
			if i % 2 == 1   { it = alloc Dalmation272 }
			else            { it = alloc Dog272 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList272<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names273 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal273
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names273[rand() % names273.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog273 : Animal273
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation273 : Dog273
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList273<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff273()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog273 [5] {
			if i % 2 == 1   { it = alloc Dalmation273 }
			else            { it = alloc Dog273 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList273<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names274 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal274
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names274[rand() % names274.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog274 : Animal274
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation274 : Dog274
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList274<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff274()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog274 [5] {
			if i % 2 == 1   { it = alloc Dalmation274 }
			else            { it = alloc Dog274 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList274<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names275 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal275
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names275[rand() % names275.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog275 : Animal275
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation275 : Dog275
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList275<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff275()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog275 [5] {
			if i % 2 == 1   { it = alloc Dalmation275 }
			else            { it = alloc Dog275 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList275<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names276 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal276
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names276[rand() % names276.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog276 : Animal276
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation276 : Dog276
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList276<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff276()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog276 [5] {
			if i % 2 == 1   { it = alloc Dalmation276 }
			else            { it = alloc Dog276 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList276<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names277 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal277
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names277[rand() % names277.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog277 : Animal277
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation277 : Dog277
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList277<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff277()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog277 [5] {
			if i % 2 == 1   { it = alloc Dalmation277 }
			else            { it = alloc Dog277 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList277<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names278 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal278
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names278[rand() % names278.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog278 : Animal278
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation278 : Dog278
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList278<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff278()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog278 [5] {
			if i % 2 == 1   { it = alloc Dalmation278 }
			else            { it = alloc Dog278 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList278<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names279 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal279
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names279[rand() % names279.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog279 : Animal279
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation279 : Dog279
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList279<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff279()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog279 [5] {
			if i % 2 == 1   { it = alloc Dalmation279 }
			else            { it = alloc Dog279 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList279<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names280 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal280
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names280[rand() % names280.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog280 : Animal280
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation280 : Dog280
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList280<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff280()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog280 [5] {
			if i % 2 == 1   { it = alloc Dalmation280 }
			else            { it = alloc Dog280 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList280<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names281 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal281
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names281[rand() % names281.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog281 : Animal281
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation281 : Dog281
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList281<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff281()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog281 [5] {
			if i % 2 == 1   { it = alloc Dalmation281 }
			else            { it = alloc Dog281 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList281<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names282 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal282
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names282[rand() % names282.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog282 : Animal282
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation282 : Dog282
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList282<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff282()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog282 [5] {
			if i % 2 == 1   { it = alloc Dalmation282 }
			else            { it = alloc Dog282 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList282<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names283 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal283
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names283[rand() % names283.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog283 : Animal283
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation283 : Dog283
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList283<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff283()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog283 [5] {
			if i % 2 == 1   { it = alloc Dalmation283 }
			else            { it = alloc Dog283 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList283<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names284 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal284
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names284[rand() % names284.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog284 : Animal284
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation284 : Dog284
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList284<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff284()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog284 [5] {
			if i % 2 == 1   { it = alloc Dalmation284 }
			else            { it = alloc Dog284 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList284<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names285 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal285
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names285[rand() % names285.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog285 : Animal285
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation285 : Dog285
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList285<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff285()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog285 [5] {
			if i % 2 == 1   { it = alloc Dalmation285 }
			else            { it = alloc Dog285 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList285<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names286 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal286
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names286[rand() % names286.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog286 : Animal286
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation286 : Dog286
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList286<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff286()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog286 [5] {
			if i % 2 == 1   { it = alloc Dalmation286 }
			else            { it = alloc Dog286 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList286<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names287 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal287
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names287[rand() % names287.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog287 : Animal287
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation287 : Dog287
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList287<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff287()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog287 [5] {
			if i % 2 == 1   { it = alloc Dalmation287 }
			else            { it = alloc Dog287 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList287<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names288 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal288
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names288[rand() % names288.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog288 : Animal288
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation288 : Dog288
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList288<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff288()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog288 [5] {
			if i % 2 == 1   { it = alloc Dalmation288 }
			else            { it = alloc Dog288 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList288<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names289 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal289
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names289[rand() % names289.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog289 : Animal289
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation289 : Dog289
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList289<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff289()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog289 [5] {
			if i % 2 == 1   { it = alloc Dalmation289 }
			else            { it = alloc Dog289 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList289<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names290 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal290
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names290[rand() % names290.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog290 : Animal290
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation290 : Dog290
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList290<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff290()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog290 [5] {
			if i % 2 == 1   { it = alloc Dalmation290 }
			else            { it = alloc Dog290 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList290<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names291 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal291
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names291[rand() % names291.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog291 : Animal291
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation291 : Dog291
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList291<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff291()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog291 [5] {
			if i % 2 == 1   { it = alloc Dalmation291 }
			else            { it = alloc Dog291 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList291<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names292 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal292
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names292[rand() % names292.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog292 : Animal292
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation292 : Dog292
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList292<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff292()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog292 [5] {
			if i % 2 == 1   { it = alloc Dalmation292 }
			else            { it = alloc Dog292 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList292<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names293 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal293
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names293[rand() % names293.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog293 : Animal293
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation293 : Dog293
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList293<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff293()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog293 [5] {
			if i % 2 == 1   { it = alloc Dalmation293 }
			else            { it = alloc Dog293 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList293<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names294 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal294
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names294[rand() % names294.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog294 : Animal294
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation294 : Dog294
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList294<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff294()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog294 [5] {
			if i % 2 == 1   { it = alloc Dalmation294 }
			else            { it = alloc Dog294 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList294<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names295 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal295
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names295[rand() % names295.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog295 : Animal295
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation295 : Dog295
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList295<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff295()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog295 [5] {
			if i % 2 == 1   { it = alloc Dalmation295 }
			else            { it = alloc Dog295 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList295<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names296 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal296
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names296[rand() % names296.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog296 : Animal296
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation296 : Dog296
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList296<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff296()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog296 [5] {
			if i % 2 == 1   { it = alloc Dalmation296 }
			else            { it = alloc Dog296 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList296<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names297 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal297
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names297[rand() % names297.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog297 : Animal297
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation297 : Dog297
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList297<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff297()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog297 [5] {
			if i % 2 == 1   { it = alloc Dalmation297 }
			else            { it = alloc Dog297 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList297<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names298 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal298
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names298[rand() % names298.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog298 : Animal298
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation298 : Dog298
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList298<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff298()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog298 [5] {
			if i % 2 == 1   { it = alloc Dalmation298 }
			else            { it = alloc Dog298 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList298<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names299 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal299
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names299[rand() % names299.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog299 : Animal299
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation299 : Dog299
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList299<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff299()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog299 [5] {
			if i % 2 == 1   { it = alloc Dalmation299 }
			else            { it = alloc Dog299 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList299<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names300 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal300
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names300[rand() % names300.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog300 : Animal300
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation300 : Dog300
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList300<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff300()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog300 [5] {
			if i % 2 == 1   { it = alloc Dalmation300 }
			else            { it = alloc Dog300 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList300<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names301 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal301
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names301[rand() % names301.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog301 : Animal301
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation301 : Dog301
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList301<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff301()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog301 [5] {
			if i % 2 == 1   { it = alloc Dalmation301 }
			else            { it = alloc Dog301 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList301<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names302 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal302
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names302[rand() % names302.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog302 : Animal302
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation302 : Dog302
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList302<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff302()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog302 [5] {
			if i % 2 == 1   { it = alloc Dalmation302 }
			else            { it = alloc Dog302 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList302<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names303 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal303
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names303[rand() % names303.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog303 : Animal303
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation303 : Dog303
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList303<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff303()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog303 [5] {
			if i % 2 == 1   { it = alloc Dalmation303 }
			else            { it = alloc Dog303 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList303<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names304 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal304
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names304[rand() % names304.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog304 : Animal304
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation304 : Dog304
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList304<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff304()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog304 [5] {
			if i % 2 == 1   { it = alloc Dalmation304 }
			else            { it = alloc Dog304 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList304<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names305 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal305
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names305[rand() % names305.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog305 : Animal305
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation305 : Dog305
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList305<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff305()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog305 [5] {
			if i % 2 == 1   { it = alloc Dalmation305 }
			else            { it = alloc Dog305 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList305<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names306 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal306
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names306[rand() % names306.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog306 : Animal306
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation306 : Dog306
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList306<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff306()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog306 [5] {
			if i % 2 == 1   { it = alloc Dalmation306 }
			else            { it = alloc Dog306 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList306<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names307 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal307
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names307[rand() % names307.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog307 : Animal307
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation307 : Dog307
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList307<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff307()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog307 [5] {
			if i % 2 == 1   { it = alloc Dalmation307 }
			else            { it = alloc Dog307 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList307<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names308 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal308
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names308[rand() % names308.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog308 : Animal308
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation308 : Dog308
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList308<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff308()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog308 [5] {
			if i % 2 == 1   { it = alloc Dalmation308 }
			else            { it = alloc Dog308 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList308<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names309 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal309
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names309[rand() % names309.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog309 : Animal309
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation309 : Dog309
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList309<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff309()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog309 [5] {
			if i % 2 == 1   { it = alloc Dalmation309 }
			else            { it = alloc Dog309 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList309<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names310 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal310
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names310[rand() % names310.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog310 : Animal310
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation310 : Dog310
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList310<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff310()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog310 [5] {
			if i % 2 == 1   { it = alloc Dalmation310 }
			else            { it = alloc Dog310 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList310<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names311 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal311
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names311[rand() % names311.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog311 : Animal311
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation311 : Dog311
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList311<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff311()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog311 [5] {
			if i % 2 == 1   { it = alloc Dalmation311 }
			else            { it = alloc Dog311 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList311<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names312 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal312
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names312[rand() % names312.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog312 : Animal312
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation312 : Dog312
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList312<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff312()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog312 [5] {
			if i % 2 == 1   { it = alloc Dalmation312 }
			else            { it = alloc Dog312 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList312<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names313 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal313
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names313[rand() % names313.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog313 : Animal313
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation313 : Dog313
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList313<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff313()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog313 [5] {
			if i % 2 == 1   { it = alloc Dalmation313 }
			else            { it = alloc Dog313 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList313<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names314 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal314
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names314[rand() % names314.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog314 : Animal314
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation314 : Dog314
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList314<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff314()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog314 [5] {
			if i % 2 == 1   { it = alloc Dalmation314 }
			else            { it = alloc Dog314 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList314<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names315 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal315
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names315[rand() % names315.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog315 : Animal315
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation315 : Dog315
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList315<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff315()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog315 [5] {
			if i % 2 == 1   { it = alloc Dalmation315 }
			else            { it = alloc Dog315 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList315<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names316 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal316
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names316[rand() % names316.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog316 : Animal316
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation316 : Dog316
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList316<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff316()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog316 [5] {
			if i % 2 == 1   { it = alloc Dalmation316 }
			else            { it = alloc Dog316 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList316<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names317 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal317
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names317[rand() % names317.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog317 : Animal317
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation317 : Dog317
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList317<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff317()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog317 [5] {
			if i % 2 == 1   { it = alloc Dalmation317 }
			else            { it = alloc Dog317 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList317<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names318 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal318
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names318[rand() % names318.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog318 : Animal318
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation318 : Dog318
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList318<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff318()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog318 [5] {
			if i % 2 == 1   { it = alloc Dalmation318 }
			else            { it = alloc Dog318 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList318<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names319 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal319
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names319[rand() % names319.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog319 : Animal319
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation319 : Dog319
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList319<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff319()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog319 [5] {
			if i % 2 == 1   { it = alloc Dalmation319 }
			else            { it = alloc Dog319 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList319<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names320 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal320
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names320[rand() % names320.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog320 : Animal320
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation320 : Dog320
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList320<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff320()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog320 [5] {
			if i % 2 == 1   { it = alloc Dalmation320 }
			else            { it = alloc Dog320 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList320<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names321 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal321
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names321[rand() % names321.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog321 : Animal321
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation321 : Dog321
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList321<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff321()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog321 [5] {
			if i % 2 == 1   { it = alloc Dalmation321 }
			else            { it = alloc Dog321 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList321<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names322 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal322
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names322[rand() % names322.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog322 : Animal322
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation322 : Dog322
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList322<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff322()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog322 [5] {
			if i % 2 == 1   { it = alloc Dalmation322 }
			else            { it = alloc Dog322 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList322<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names323 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal323
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names323[rand() % names323.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog323 : Animal323
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation323 : Dog323
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList323<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff323()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog323 [5] {
			if i % 2 == 1   { it = alloc Dalmation323 }
			else            { it = alloc Dog323 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList323<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names324 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal324
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names324[rand() % names324.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog324 : Animal324
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation324 : Dog324
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList324<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff324()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog324 [5] {
			if i % 2 == 1   { it = alloc Dalmation324 }
			else            { it = alloc Dog324 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList324<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names325 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal325
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names325[rand() % names325.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog325 : Animal325
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation325 : Dog325
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList325<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff325()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog325 [5] {
			if i % 2 == 1   { it = alloc Dalmation325 }
			else            { it = alloc Dog325 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList325<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names326 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal326
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names326[rand() % names326.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog326 : Animal326
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation326 : Dog326
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList326<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff326()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog326 [5] {
			if i % 2 == 1   { it = alloc Dalmation326 }
			else            { it = alloc Dog326 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList326<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names327 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal327
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names327[rand() % names327.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog327 : Animal327
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation327 : Dog327
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList327<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff327()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog327 [5] {
			if i % 2 == 1   { it = alloc Dalmation327 }
			else            { it = alloc Dog327 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList327<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names328 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal328
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names328[rand() % names328.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog328 : Animal328
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation328 : Dog328
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList328<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff328()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog328 [5] {
			if i % 2 == 1   { it = alloc Dalmation328 }
			else            { it = alloc Dog328 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList328<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names329 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal329
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names329[rand() % names329.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog329 : Animal329
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation329 : Dog329
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList329<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff329()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog329 [5] {
			if i % 2 == 1   { it = alloc Dalmation329 }
			else            { it = alloc Dog329 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList329<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names330 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal330
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names330[rand() % names330.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog330 : Animal330
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation330 : Dog330
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList330<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff330()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog330 [5] {
			if i % 2 == 1   { it = alloc Dalmation330 }
			else            { it = alloc Dog330 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList330<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names331 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal331
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names331[rand() % names331.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog331 : Animal331
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation331 : Dog331
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList331<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff331()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog331 [5] {
			if i % 2 == 1   { it = alloc Dalmation331 }
			else            { it = alloc Dog331 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList331<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names332 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal332
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names332[rand() % names332.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog332 : Animal332
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation332 : Dog332
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList332<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff332()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog332 [5] {
			if i % 2 == 1   { it = alloc Dalmation332 }
			else            { it = alloc Dog332 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList332<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names333 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal333
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names333[rand() % names333.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog333 : Animal333
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation333 : Dog333
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList333<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff333()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog333 [5] {
			if i % 2 == 1   { it = alloc Dalmation333 }
			else            { it = alloc Dog333 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList333<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names334 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal334
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names334[rand() % names334.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog334 : Animal334
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation334 : Dog334
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList334<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff334()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog334 [5] {
			if i % 2 == 1   { it = alloc Dalmation334 }
			else            { it = alloc Dog334 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList334<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names335 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal335
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names335[rand() % names335.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog335 : Animal335
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation335 : Dog335
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList335<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff335()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog335 [5] {
			if i % 2 == 1   { it = alloc Dalmation335 }
			else            { it = alloc Dog335 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList335<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names336 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal336
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names336[rand() % names336.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog336 : Animal336
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation336 : Dog336
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList336<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff336()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog336 [5] {
			if i % 2 == 1   { it = alloc Dalmation336 }
			else            { it = alloc Dog336 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList336<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names337 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal337
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names337[rand() % names337.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog337 : Animal337
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation337 : Dog337
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList337<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff337()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog337 [5] {
			if i % 2 == 1   { it = alloc Dalmation337 }
			else            { it = alloc Dog337 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList337<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names338 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal338
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names338[rand() % names338.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog338 : Animal338
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation338 : Dog338
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList338<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff338()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog338 [5] {
			if i % 2 == 1   { it = alloc Dalmation338 }
			else            { it = alloc Dog338 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList338<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names339 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal339
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names339[rand() % names339.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog339 : Animal339
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation339 : Dog339
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList339<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff339()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog339 [5] {
			if i % 2 == 1   { it = alloc Dalmation339 }
			else            { it = alloc Dog339 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList339<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names340 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal340
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names340[rand() % names340.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog340 : Animal340
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation340 : Dog340
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList340<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff340()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog340 [5] {
			if i % 2 == 1   { it = alloc Dalmation340 }
			else            { it = alloc Dog340 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList340<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names341 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal341
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names341[rand() % names341.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog341 : Animal341
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation341 : Dog341
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList341<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff341()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog341 [5] {
			if i % 2 == 1   { it = alloc Dalmation341 }
			else            { it = alloc Dog341 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList341<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names342 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal342
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names342[rand() % names342.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog342 : Animal342
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation342 : Dog342
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList342<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff342()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog342 [5] {
			if i % 2 == 1   { it = alloc Dalmation342 }
			else            { it = alloc Dog342 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList342<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names343 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal343
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names343[rand() % names343.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog343 : Animal343
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation343 : Dog343
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList343<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff343()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog343 [5] {
			if i % 2 == 1   { it = alloc Dalmation343 }
			else            { it = alloc Dog343 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList343<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names344 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal344
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names344[rand() % names344.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog344 : Animal344
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation344 : Dog344
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList344<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff344()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog344 [5] {
			if i % 2 == 1   { it = alloc Dalmation344 }
			else            { it = alloc Dog344 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList344<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names345 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal345
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names345[rand() % names345.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog345 : Animal345
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation345 : Dog345
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList345<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff345()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog345 [5] {
			if i % 2 == 1   { it = alloc Dalmation345 }
			else            { it = alloc Dog345 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList345<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names346 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal346
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names346[rand() % names346.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog346 : Animal346
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation346 : Dog346
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList346<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff346()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog346 [5] {
			if i % 2 == 1   { it = alloc Dalmation346 }
			else            { it = alloc Dog346 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList346<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names347 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal347
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names347[rand() % names347.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog347 : Animal347
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation347 : Dog347
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList347<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff347()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog347 [5] {
			if i % 2 == 1   { it = alloc Dalmation347 }
			else            { it = alloc Dog347 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList347<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names348 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal348
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names348[rand() % names348.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog348 : Animal348
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation348 : Dog348
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList348<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff348()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog348 [5] {
			if i % 2 == 1   { it = alloc Dalmation348 }
			else            { it = alloc Dog348 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList348<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names349 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal349
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names349[rand() % names349.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog349 : Animal349
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation349 : Dog349
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList349<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff349()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog349 [5] {
			if i % 2 == 1   { it = alloc Dalmation349 }
			else            { it = alloc Dog349 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList349<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names350 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal350
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names350[rand() % names350.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog350 : Animal350
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation350 : Dog350
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList350<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff350()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog350 [5] {
			if i % 2 == 1   { it = alloc Dalmation350 }
			else            { it = alloc Dog350 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList350<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names351 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal351
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names351[rand() % names351.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog351 : Animal351
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation351 : Dog351
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList351<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff351()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog351 [5] {
			if i % 2 == 1   { it = alloc Dalmation351 }
			else            { it = alloc Dog351 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList351<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names352 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal352
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names352[rand() % names352.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog352 : Animal352
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation352 : Dog352
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList352<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff352()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog352 [5] {
			if i % 2 == 1   { it = alloc Dalmation352 }
			else            { it = alloc Dog352 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList352<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names353 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal353
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names353[rand() % names353.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog353 : Animal353
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation353 : Dog353
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList353<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff353()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog353 [5] {
			if i % 2 == 1   { it = alloc Dalmation353 }
			else            { it = alloc Dog353 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList353<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names354 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal354
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names354[rand() % names354.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog354 : Animal354
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation354 : Dog354
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList354<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff354()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog354 [5] {
			if i % 2 == 1   { it = alloc Dalmation354 }
			else            { it = alloc Dog354 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList354<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names355 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal355
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names355[rand() % names355.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog355 : Animal355
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation355 : Dog355
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList355<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff355()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog355 [5] {
			if i % 2 == 1   { it = alloc Dalmation355 }
			else            { it = alloc Dog355 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList355<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names356 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal356
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names356[rand() % names356.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog356 : Animal356
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation356 : Dog356
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList356<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff356()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog356 [5] {
			if i % 2 == 1   { it = alloc Dalmation356 }
			else            { it = alloc Dog356 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList356<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names357 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal357
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names357[rand() % names357.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog357 : Animal357
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation357 : Dog357
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList357<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff357()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog357 [5] {
			if i % 2 == 1   { it = alloc Dalmation357 }
			else            { it = alloc Dog357 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList357<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names358 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal358
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names358[rand() % names358.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog358 : Animal358
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation358 : Dog358
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList358<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff358()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog358 [5] {
			if i % 2 == 1   { it = alloc Dalmation358 }
			else            { it = alloc Dog358 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList358<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names359 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal359
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names359[rand() % names359.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog359 : Animal359
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation359 : Dog359
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList359<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff359()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog359 [5] {
			if i % 2 == 1   { it = alloc Dalmation359 }
			else            { it = alloc Dog359 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList359<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names360 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal360
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names360[rand() % names360.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog360 : Animal360
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation360 : Dog360
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList360<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff360()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog360 [5] {
			if i % 2 == 1   { it = alloc Dalmation360 }
			else            { it = alloc Dog360 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList360<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names361 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal361
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names361[rand() % names361.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog361 : Animal361
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation361 : Dog361
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList361<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff361()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog361 [5] {
			if i % 2 == 1   { it = alloc Dalmation361 }
			else            { it = alloc Dog361 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList361<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names362 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal362
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names362[rand() % names362.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog362 : Animal362
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation362 : Dog362
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList362<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff362()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog362 [5] {
			if i % 2 == 1   { it = alloc Dalmation362 }
			else            { it = alloc Dog362 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList362<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names363 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal363
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names363[rand() % names363.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog363 : Animal363
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation363 : Dog363
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList363<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff363()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog363 [5] {
			if i % 2 == 1   { it = alloc Dalmation363 }
			else            { it = alloc Dog363 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList363<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names364 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal364
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names364[rand() % names364.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog364 : Animal364
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation364 : Dog364
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList364<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff364()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog364 [5] {
			if i % 2 == 1   { it = alloc Dalmation364 }
			else            { it = alloc Dog364 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList364<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names365 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal365
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names365[rand() % names365.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog365 : Animal365
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation365 : Dog365
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList365<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff365()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog365 [5] {
			if i % 2 == 1   { it = alloc Dalmation365 }
			else            { it = alloc Dog365 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList365<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names366 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal366
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names366[rand() % names366.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog366 : Animal366
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation366 : Dog366
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList366<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff366()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog366 [5] {
			if i % 2 == 1   { it = alloc Dalmation366 }
			else            { it = alloc Dog366 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList366<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names367 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal367
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names367[rand() % names367.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog367 : Animal367
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation367 : Dog367
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList367<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff367()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog367 [5] {
			if i % 2 == 1   { it = alloc Dalmation367 }
			else            { it = alloc Dog367 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList367<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names368 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal368
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names368[rand() % names368.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog368 : Animal368
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation368 : Dog368
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList368<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff368()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog368 [5] {
			if i % 2 == 1   { it = alloc Dalmation368 }
			else            { it = alloc Dog368 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList368<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names369 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal369
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names369[rand() % names369.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog369 : Animal369
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation369 : Dog369
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList369<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff369()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog369 [5] {
			if i % 2 == 1   { it = alloc Dalmation369 }
			else            { it = alloc Dog369 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList369<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names370 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal370
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names370[rand() % names370.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog370 : Animal370
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation370 : Dog370
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList370<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff370()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog370 [5] {
			if i % 2 == 1   { it = alloc Dalmation370 }
			else            { it = alloc Dog370 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList370<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names371 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal371
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names371[rand() % names371.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog371 : Animal371
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation371 : Dog371
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList371<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff371()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog371 [5] {
			if i % 2 == 1   { it = alloc Dalmation371 }
			else            { it = alloc Dog371 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList371<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names372 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal372
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names372[rand() % names372.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog372 : Animal372
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation372 : Dog372
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList372<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff372()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog372 [5] {
			if i % 2 == 1   { it = alloc Dalmation372 }
			else            { it = alloc Dog372 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList372<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names373 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal373
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names373[rand() % names373.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog373 : Animal373
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation373 : Dog373
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList373<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff373()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog373 [5] {
			if i % 2 == 1   { it = alloc Dalmation373 }
			else            { it = alloc Dog373 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList373<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names374 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal374
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names374[rand() % names374.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog374 : Animal374
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation374 : Dog374
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList374<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff374()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog374 [5] {
			if i % 2 == 1   { it = alloc Dalmation374 }
			else            { it = alloc Dog374 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList374<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names375 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal375
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names375[rand() % names375.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog375 : Animal375
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation375 : Dog375
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList375<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff375()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog375 [5] {
			if i % 2 == 1   { it = alloc Dalmation375 }
			else            { it = alloc Dog375 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList375<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names376 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal376
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names376[rand() % names376.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog376 : Animal376
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation376 : Dog376
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList376<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff376()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog376 [5] {
			if i % 2 == 1   { it = alloc Dalmation376 }
			else            { it = alloc Dog376 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList376<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names377 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal377
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names377[rand() % names377.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog377 : Animal377
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation377 : Dog377
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList377<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff377()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog377 [5] {
			if i % 2 == 1   { it = alloc Dalmation377 }
			else            { it = alloc Dog377 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList377<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names378 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal378
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names378[rand() % names378.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog378 : Animal378
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation378 : Dog378
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList378<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff378()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog378 [5] {
			if i % 2 == 1   { it = alloc Dalmation378 }
			else            { it = alloc Dog378 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList378<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names379 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal379
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names379[rand() % names379.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog379 : Animal379
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation379 : Dog379
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList379<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff379()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog379 [5] {
			if i % 2 == 1   { it = alloc Dalmation379 }
			else            { it = alloc Dog379 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList379<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names380 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal380
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names380[rand() % names380.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog380 : Animal380
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation380 : Dog380
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList380<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff380()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog380 [5] {
			if i % 2 == 1   { it = alloc Dalmation380 }
			else            { it = alloc Dog380 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList380<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names381 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal381
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names381[rand() % names381.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog381 : Animal381
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation381 : Dog381
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList381<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff381()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog381 [5] {
			if i % 2 == 1   { it = alloc Dalmation381 }
			else            { it = alloc Dog381 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList381<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names382 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal382
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names382[rand() % names382.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog382 : Animal382
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation382 : Dog382
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList382<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff382()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog382 [5] {
			if i % 2 == 1   { it = alloc Dalmation382 }
			else            { it = alloc Dog382 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList382<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names383 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal383
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names383[rand() % names383.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog383 : Animal383
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation383 : Dog383
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList383<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff383()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog383 [5] {
			if i % 2 == 1   { it = alloc Dalmation383 }
			else            { it = alloc Dog383 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList383<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names384 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal384
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names384[rand() % names384.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog384 : Animal384
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation384 : Dog384
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList384<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff384()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog384 [5] {
			if i % 2 == 1   { it = alloc Dalmation384 }
			else            { it = alloc Dog384 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList384<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names385 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal385
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names385[rand() % names385.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog385 : Animal385
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation385 : Dog385
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList385<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff385()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog385 [5] {
			if i % 2 == 1   { it = alloc Dalmation385 }
			else            { it = alloc Dog385 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList385<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names386 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal386
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names386[rand() % names386.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog386 : Animal386
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation386 : Dog386
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList386<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff386()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog386 [5] {
			if i % 2 == 1   { it = alloc Dalmation386 }
			else            { it = alloc Dog386 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList386<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names387 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal387
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names387[rand() % names387.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog387 : Animal387
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation387 : Dog387
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList387<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff387()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog387 [5] {
			if i % 2 == 1   { it = alloc Dalmation387 }
			else            { it = alloc Dog387 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList387<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names388 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal388
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names388[rand() % names388.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog388 : Animal388
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation388 : Dog388
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList388<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff388()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog388 [5] {
			if i % 2 == 1   { it = alloc Dalmation388 }
			else            { it = alloc Dog388 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList388<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names389 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal389
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names389[rand() % names389.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog389 : Animal389
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation389 : Dog389
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList389<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff389()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog389 [5] {
			if i % 2 == 1   { it = alloc Dalmation389 }
			else            { it = alloc Dog389 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList389<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names390 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal390
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names390[rand() % names390.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog390 : Animal390
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation390 : Dog390
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList390<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff390()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog390 [5] {
			if i % 2 == 1   { it = alloc Dalmation390 }
			else            { it = alloc Dog390 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList390<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names391 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal391
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names391[rand() % names391.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog391 : Animal391
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation391 : Dog391
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList391<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff391()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog391 [5] {
			if i % 2 == 1   { it = alloc Dalmation391 }
			else            { it = alloc Dog391 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList391<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names392 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal392
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names392[rand() % names392.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog392 : Animal392
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation392 : Dog392
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList392<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff392()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog392 [5] {
			if i % 2 == 1   { it = alloc Dalmation392 }
			else            { it = alloc Dog392 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList392<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names393 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal393
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names393[rand() % names393.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog393 : Animal393
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation393 : Dog393
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList393<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff393()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog393 [5] {
			if i % 2 == 1   { it = alloc Dalmation393 }
			else            { it = alloc Dog393 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList393<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names394 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal394
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names394[rand() % names394.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog394 : Animal394
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation394 : Dog394
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList394<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff394()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog394 [5] {
			if i % 2 == 1   { it = alloc Dalmation394 }
			else            { it = alloc Dog394 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList394<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names395 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal395
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names395[rand() % names395.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog395 : Animal395
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation395 : Dog395
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList395<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff395()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog395 [5] {
			if i % 2 == 1   { it = alloc Dalmation395 }
			else            { it = alloc Dog395 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList395<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names396 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal396
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names396[rand() % names396.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog396 : Animal396
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation396 : Dog396
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList396<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff396()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog396 [5] {
			if i % 2 == 1   { it = alloc Dalmation396 }
			else            { it = alloc Dog396 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList396<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names397 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal397
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names397[rand() % names397.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog397 : Animal397
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation397 : Dog397
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList397<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff397()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog397 [5] {
			if i % 2 == 1   { it = alloc Dalmation397 }
			else            { it = alloc Dog397 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList397<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names398 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal398
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names398[rand() % names398.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog398 : Animal398
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation398 : Dog398
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList398<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff398()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog398 [5] {
			if i % 2 == 1   { it = alloc Dalmation398 }
			else            { it = alloc Dog398 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList398<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names399 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal399
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names399[rand() % names399.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog399 : Animal399
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation399 : Dog399
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList399<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff399()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog399 [5] {
			if i % 2 == 1   { it = alloc Dalmation399 }
			else            { it = alloc Dog399 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList399<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names400 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal400
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names400[rand() % names400.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog400 : Animal400
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation400 : Dog400
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList400<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff400()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog400 [5] {
			if i % 2 == 1   { it = alloc Dalmation400 }
			else            { it = alloc Dog400 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList400<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names401 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal401
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names401[rand() % names401.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog401 : Animal401
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation401 : Dog401
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList401<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff401()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog401 [5] {
			if i % 2 == 1   { it = alloc Dalmation401 }
			else            { it = alloc Dog401 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList401<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names402 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal402
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names402[rand() % names402.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog402 : Animal402
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation402 : Dog402
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList402<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff402()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog402 [5] {
			if i % 2 == 1   { it = alloc Dalmation402 }
			else            { it = alloc Dog402 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList402<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names403 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal403
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names403[rand() % names403.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog403 : Animal403
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation403 : Dog403
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList403<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff403()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog403 [5] {
			if i % 2 == 1   { it = alloc Dalmation403 }
			else            { it = alloc Dog403 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList403<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names404 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal404
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names404[rand() % names404.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog404 : Animal404
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation404 : Dog404
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList404<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff404()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog404 [5] {
			if i % 2 == 1   { it = alloc Dalmation404 }
			else            { it = alloc Dog404 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList404<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names405 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal405
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names405[rand() % names405.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog405 : Animal405
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation405 : Dog405
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList405<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff405()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog405 [5] {
			if i % 2 == 1   { it = alloc Dalmation405 }
			else            { it = alloc Dog405 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList405<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names406 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal406
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names406[rand() % names406.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog406 : Animal406
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation406 : Dog406
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList406<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff406()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog406 [5] {
			if i % 2 == 1   { it = alloc Dalmation406 }
			else            { it = alloc Dog406 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList406<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names407 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal407
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names407[rand() % names407.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog407 : Animal407
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation407 : Dog407
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList407<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff407()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog407 [5] {
			if i % 2 == 1   { it = alloc Dalmation407 }
			else            { it = alloc Dog407 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList407<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names408 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal408
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names408[rand() % names408.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog408 : Animal408
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation408 : Dog408
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList408<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff408()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog408 [5] {
			if i % 2 == 1   { it = alloc Dalmation408 }
			else            { it = alloc Dog408 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList408<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names409 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal409
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names409[rand() % names409.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog409 : Animal409
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation409 : Dog409
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList409<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff409()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog409 [5] {
			if i % 2 == 1   { it = alloc Dalmation409 }
			else            { it = alloc Dog409 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList409<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names410 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal410
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names410[rand() % names410.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog410 : Animal410
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation410 : Dog410
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList410<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff410()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog410 [5] {
			if i % 2 == 1   { it = alloc Dalmation410 }
			else            { it = alloc Dog410 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList410<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names411 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal411
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names411[rand() % names411.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog411 : Animal411
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation411 : Dog411
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList411<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff411()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog411 [5] {
			if i % 2 == 1   { it = alloc Dalmation411 }
			else            { it = alloc Dog411 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList411<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names412 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal412
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names412[rand() % names412.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog412 : Animal412
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation412 : Dog412
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList412<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff412()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog412 [5] {
			if i % 2 == 1   { it = alloc Dalmation412 }
			else            { it = alloc Dog412 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList412<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names413 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal413
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names413[rand() % names413.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog413 : Animal413
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation413 : Dog413
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList413<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff413()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog413 [5] {
			if i % 2 == 1   { it = alloc Dalmation413 }
			else            { it = alloc Dog413 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList413<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names414 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal414
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names414[rand() % names414.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog414 : Animal414
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation414 : Dog414
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList414<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff414()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog414 [5] {
			if i % 2 == 1   { it = alloc Dalmation414 }
			else            { it = alloc Dog414 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList414<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names415 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal415
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names415[rand() % names415.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog415 : Animal415
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation415 : Dog415
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList415<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff415()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog415 [5] {
			if i % 2 == 1   { it = alloc Dalmation415 }
			else            { it = alloc Dog415 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList415<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names416 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal416
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names416[rand() % names416.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog416 : Animal416
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation416 : Dog416
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList416<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff416()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog416 [5] {
			if i % 2 == 1   { it = alloc Dalmation416 }
			else            { it = alloc Dog416 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList416<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names417 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal417
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names417[rand() % names417.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog417 : Animal417
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation417 : Dog417
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList417<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff417()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog417 [5] {
			if i % 2 == 1   { it = alloc Dalmation417 }
			else            { it = alloc Dog417 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList417<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names418 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal418
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names418[rand() % names418.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog418 : Animal418
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation418 : Dog418
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList418<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff418()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog418 [5] {
			if i % 2 == 1   { it = alloc Dalmation418 }
			else            { it = alloc Dog418 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList418<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names419 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal419
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names419[rand() % names419.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog419 : Animal419
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation419 : Dog419
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList419<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff419()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog419 [5] {
			if i % 2 == 1   { it = alloc Dalmation419 }
			else            { it = alloc Dog419 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList419<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names420 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal420
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names420[rand() % names420.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog420 : Animal420
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation420 : Dog420
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList420<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff420()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog420 [5] {
			if i % 2 == 1   { it = alloc Dalmation420 }
			else            { it = alloc Dog420 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList420<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names421 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal421
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names421[rand() % names421.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog421 : Animal421
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation421 : Dog421
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList421<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff421()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog421 [5] {
			if i % 2 == 1   { it = alloc Dalmation421 }
			else            { it = alloc Dog421 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList421<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names422 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal422
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names422[rand() % names422.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog422 : Animal422
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation422 : Dog422
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList422<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff422()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog422 [5] {
			if i % 2 == 1   { it = alloc Dalmation422 }
			else            { it = alloc Dog422 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList422<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names423 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal423
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names423[rand() % names423.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog423 : Animal423
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation423 : Dog423
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList423<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff423()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog423 [5] {
			if i % 2 == 1   { it = alloc Dalmation423 }
			else            { it = alloc Dog423 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList423<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names424 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal424
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names424[rand() % names424.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog424 : Animal424
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation424 : Dog424
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList424<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff424()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog424 [5] {
			if i % 2 == 1   { it = alloc Dalmation424 }
			else            { it = alloc Dog424 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList424<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names425 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal425
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names425[rand() % names425.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog425 : Animal425
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation425 : Dog425
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList425<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff425()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog425 [5] {
			if i % 2 == 1   { it = alloc Dalmation425 }
			else            { it = alloc Dog425 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList425<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names426 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal426
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names426[rand() % names426.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog426 : Animal426
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation426 : Dog426
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList426<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff426()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog426 [5] {
			if i % 2 == 1   { it = alloc Dalmation426 }
			else            { it = alloc Dog426 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList426<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names427 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal427
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names427[rand() % names427.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog427 : Animal427
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation427 : Dog427
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList427<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff427()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog427 [5] {
			if i % 2 == 1   { it = alloc Dalmation427 }
			else            { it = alloc Dog427 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList427<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names428 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal428
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names428[rand() % names428.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog428 : Animal428
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation428 : Dog428
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList428<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff428()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog428 [5] {
			if i % 2 == 1   { it = alloc Dalmation428 }
			else            { it = alloc Dog428 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList428<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names429 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal429
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names429[rand() % names429.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog429 : Animal429
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation429 : Dog429
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList429<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff429()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog429 [5] {
			if i % 2 == 1   { it = alloc Dalmation429 }
			else            { it = alloc Dog429 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList429<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names430 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal430
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names430[rand() % names430.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog430 : Animal430
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation430 : Dog430
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList430<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff430()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog430 [5] {
			if i % 2 == 1   { it = alloc Dalmation430 }
			else            { it = alloc Dog430 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList430<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names431 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal431
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names431[rand() % names431.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog431 : Animal431
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation431 : Dog431
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList431<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff431()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog431 [5] {
			if i % 2 == 1   { it = alloc Dalmation431 }
			else            { it = alloc Dog431 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList431<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names432 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal432
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names432[rand() % names432.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog432 : Animal432
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation432 : Dog432
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList432<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff432()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog432 [5] {
			if i % 2 == 1   { it = alloc Dalmation432 }
			else            { it = alloc Dog432 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList432<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names433 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal433
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names433[rand() % names433.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog433 : Animal433
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation433 : Dog433
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList433<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff433()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog433 [5] {
			if i % 2 == 1   { it = alloc Dalmation433 }
			else            { it = alloc Dog433 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList433<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names434 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal434
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names434[rand() % names434.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog434 : Animal434
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation434 : Dog434
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList434<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff434()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog434 [5] {
			if i % 2 == 1   { it = alloc Dalmation434 }
			else            { it = alloc Dog434 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList434<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names435 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal435
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names435[rand() % names435.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog435 : Animal435
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation435 : Dog435
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList435<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff435()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog435 [5] {
			if i % 2 == 1   { it = alloc Dalmation435 }
			else            { it = alloc Dog435 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList435<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names436 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal436
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names436[rand() % names436.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog436 : Animal436
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation436 : Dog436
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList436<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff436()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog436 [5] {
			if i % 2 == 1   { it = alloc Dalmation436 }
			else            { it = alloc Dog436 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList436<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names437 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal437
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names437[rand() % names437.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog437 : Animal437
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation437 : Dog437
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList437<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff437()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog437 [5] {
			if i % 2 == 1   { it = alloc Dalmation437 }
			else            { it = alloc Dog437 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList437<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names438 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal438
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names438[rand() % names438.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog438 : Animal438
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation438 : Dog438
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList438<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff438()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog438 [5] {
			if i % 2 == 1   { it = alloc Dalmation438 }
			else            { it = alloc Dog438 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList438<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names439 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal439
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names439[rand() % names439.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog439 : Animal439
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation439 : Dog439
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList439<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff439()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog439 [5] {
			if i % 2 == 1   { it = alloc Dalmation439 }
			else            { it = alloc Dog439 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList439<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names440 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal440
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names440[rand() % names440.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog440 : Animal440
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation440 : Dog440
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList440<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff440()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog440 [5] {
			if i % 2 == 1   { it = alloc Dalmation440 }
			else            { it = alloc Dog440 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList440<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names441 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal441
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names441[rand() % names441.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog441 : Animal441
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation441 : Dog441
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList441<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff441()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog441 [5] {
			if i % 2 == 1   { it = alloc Dalmation441 }
			else            { it = alloc Dog441 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList441<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names442 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal442
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names442[rand() % names442.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog442 : Animal442
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation442 : Dog442
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList442<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff442()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog442 [5] {
			if i % 2 == 1   { it = alloc Dalmation442 }
			else            { it = alloc Dog442 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList442<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names443 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal443
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names443[rand() % names443.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog443 : Animal443
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation443 : Dog443
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList443<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff443()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog443 [5] {
			if i % 2 == 1   { it = alloc Dalmation443 }
			else            { it = alloc Dog443 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList443<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names444 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal444
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names444[rand() % names444.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog444 : Animal444
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation444 : Dog444
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList444<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff444()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog444 [5] {
			if i % 2 == 1   { it = alloc Dalmation444 }
			else            { it = alloc Dog444 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList444<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names445 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal445
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names445[rand() % names445.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog445 : Animal445
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation445 : Dog445
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList445<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff445()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog445 [5] {
			if i % 2 == 1   { it = alloc Dalmation445 }
			else            { it = alloc Dog445 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList445<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names446 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal446
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names446[rand() % names446.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog446 : Animal446
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation446 : Dog446
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList446<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff446()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog446 [5] {
			if i % 2 == 1   { it = alloc Dalmation446 }
			else            { it = alloc Dog446 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList446<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names447 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal447
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names447[rand() % names447.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog447 : Animal447
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation447 : Dog447
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList447<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff447()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog447 [5] {
			if i % 2 == 1   { it = alloc Dalmation447 }
			else            { it = alloc Dog447 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList447<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names448 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal448
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names448[rand() % names448.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog448 : Animal448
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation448 : Dog448
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList448<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff448()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog448 [5] {
			if i % 2 == 1   { it = alloc Dalmation448 }
			else            { it = alloc Dog448 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList448<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names449 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal449
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names449[rand() % names449.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog449 : Animal449
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation449 : Dog449
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList449<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff449()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog449 [5] {
			if i % 2 == 1   { it = alloc Dalmation449 }
			else            { it = alloc Dog449 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList449<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names450 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal450
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names450[rand() % names450.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog450 : Animal450
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation450 : Dog450
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList450<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff450()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog450 [5] {
			if i % 2 == 1   { it = alloc Dalmation450 }
			else            { it = alloc Dog450 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList450<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names451 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal451
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names451[rand() % names451.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog451 : Animal451
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation451 : Dog451
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList451<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff451()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog451 [5] {
			if i % 2 == 1   { it = alloc Dalmation451 }
			else            { it = alloc Dog451 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList451<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names452 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal452
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names452[rand() % names452.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog452 : Animal452
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation452 : Dog452
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList452<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff452()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog452 [5] {
			if i % 2 == 1   { it = alloc Dalmation452 }
			else            { it = alloc Dog452 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList452<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names453 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal453
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names453[rand() % names453.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog453 : Animal453
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation453 : Dog453
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList453<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff453()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog453 [5] {
			if i % 2 == 1   { it = alloc Dalmation453 }
			else            { it = alloc Dog453 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList453<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names454 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal454
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names454[rand() % names454.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog454 : Animal454
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation454 : Dog454
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList454<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff454()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog454 [5] {
			if i % 2 == 1   { it = alloc Dalmation454 }
			else            { it = alloc Dog454 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList454<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names455 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal455
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names455[rand() % names455.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog455 : Animal455
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation455 : Dog455
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList455<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff455()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog455 [5] {
			if i % 2 == 1   { it = alloc Dalmation455 }
			else            { it = alloc Dog455 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList455<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names456 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal456
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names456[rand() % names456.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog456 : Animal456
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation456 : Dog456
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList456<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff456()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog456 [5] {
			if i % 2 == 1   { it = alloc Dalmation456 }
			else            { it = alloc Dog456 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList456<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names457 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal457
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names457[rand() % names457.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog457 : Animal457
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation457 : Dog457
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList457<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff457()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog457 [5] {
			if i % 2 == 1   { it = alloc Dalmation457 }
			else            { it = alloc Dog457 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList457<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names458 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal458
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names458[rand() % names458.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog458 : Animal458
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation458 : Dog458
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList458<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff458()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog458 [5] {
			if i % 2 == 1   { it = alloc Dalmation458 }
			else            { it = alloc Dog458 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList458<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names459 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal459
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names459[rand() % names459.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog459 : Animal459
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation459 : Dog459
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList459<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff459()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog459 [5] {
			if i % 2 == 1   { it = alloc Dalmation459 }
			else            { it = alloc Dog459 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList459<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names460 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal460
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names460[rand() % names460.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog460 : Animal460
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation460 : Dog460
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList460<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff460()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog460 [5] {
			if i % 2 == 1   { it = alloc Dalmation460 }
			else            { it = alloc Dog460 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList460<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names461 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal461
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names461[rand() % names461.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog461 : Animal461
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation461 : Dog461
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList461<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff461()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog461 [5] {
			if i % 2 == 1   { it = alloc Dalmation461 }
			else            { it = alloc Dog461 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList461<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names462 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal462
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names462[rand() % names462.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog462 : Animal462
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation462 : Dog462
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList462<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff462()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog462 [5] {
			if i % 2 == 1   { it = alloc Dalmation462 }
			else            { it = alloc Dog462 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList462<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names463 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal463
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names463[rand() % names463.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog463 : Animal463
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation463 : Dog463
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList463<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff463()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog463 [5] {
			if i % 2 == 1   { it = alloc Dalmation463 }
			else            { it = alloc Dog463 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList463<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names464 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal464
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names464[rand() % names464.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog464 : Animal464
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation464 : Dog464
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList464<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff464()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog464 [5] {
			if i % 2 == 1   { it = alloc Dalmation464 }
			else            { it = alloc Dog464 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList464<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names465 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal465
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names465[rand() % names465.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog465 : Animal465
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation465 : Dog465
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList465<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff465()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog465 [5] {
			if i % 2 == 1   { it = alloc Dalmation465 }
			else            { it = alloc Dog465 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList465<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names466 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal466
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names466[rand() % names466.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog466 : Animal466
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation466 : Dog466
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList466<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff466()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog466 [5] {
			if i % 2 == 1   { it = alloc Dalmation466 }
			else            { it = alloc Dog466 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList466<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names467 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal467
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names467[rand() % names467.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog467 : Animal467
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation467 : Dog467
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList467<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff467()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog467 [5] {
			if i % 2 == 1   { it = alloc Dalmation467 }
			else            { it = alloc Dog467 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList467<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names468 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal468
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names468[rand() % names468.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog468 : Animal468
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation468 : Dog468
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList468<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff468()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog468 [5] {
			if i % 2 == 1   { it = alloc Dalmation468 }
			else            { it = alloc Dog468 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList468<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names469 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal469
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names469[rand() % names469.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog469 : Animal469
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation469 : Dog469
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList469<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff469()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog469 [5] {
			if i % 2 == 1   { it = alloc Dalmation469 }
			else            { it = alloc Dog469 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList469<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names470 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal470
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names470[rand() % names470.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog470 : Animal470
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation470 : Dog470
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList470<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff470()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog470 [5] {
			if i % 2 == 1   { it = alloc Dalmation470 }
			else            { it = alloc Dog470 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList470<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names471 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal471
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names471[rand() % names471.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog471 : Animal471
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation471 : Dog471
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList471<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff471()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog471 [5] {
			if i % 2 == 1   { it = alloc Dalmation471 }
			else            { it = alloc Dog471 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList471<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names472 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal472
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names472[rand() % names472.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog472 : Animal472
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation472 : Dog472
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList472<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff472()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog472 [5] {
			if i % 2 == 1   { it = alloc Dalmation472 }
			else            { it = alloc Dog472 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList472<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names473 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal473
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names473[rand() % names473.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog473 : Animal473
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation473 : Dog473
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList473<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff473()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog473 [5] {
			if i % 2 == 1   { it = alloc Dalmation473 }
			else            { it = alloc Dog473 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList473<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names474 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal474
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names474[rand() % names474.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog474 : Animal474
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation474 : Dog474
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList474<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff474()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog474 [5] {
			if i % 2 == 1   { it = alloc Dalmation474 }
			else            { it = alloc Dog474 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList474<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names475 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal475
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names475[rand() % names475.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog475 : Animal475
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation475 : Dog475
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList475<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff475()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog475 [5] {
			if i % 2 == 1   { it = alloc Dalmation475 }
			else            { it = alloc Dog475 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList475<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names476 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal476
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names476[rand() % names476.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog476 : Animal476
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation476 : Dog476
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList476<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff476()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog476 [5] {
			if i % 2 == 1   { it = alloc Dalmation476 }
			else            { it = alloc Dog476 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList476<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names477 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal477
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names477[rand() % names477.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog477 : Animal477
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation477 : Dog477
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList477<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff477()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog477 [5] {
			if i % 2 == 1   { it = alloc Dalmation477 }
			else            { it = alloc Dog477 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList477<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names478 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal478
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names478[rand() % names478.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog478 : Animal478
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation478 : Dog478
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList478<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff478()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog478 [5] {
			if i % 2 == 1   { it = alloc Dalmation478 }
			else            { it = alloc Dog478 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList478<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names479 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal479
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names479[rand() % names479.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog479 : Animal479
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation479 : Dog479
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList479<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff479()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog479 [5] {
			if i % 2 == 1   { it = alloc Dalmation479 }
			else            { it = alloc Dog479 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList479<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names480 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal480
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names480[rand() % names480.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog480 : Animal480
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation480 : Dog480
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList480<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff480()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog480 [5] {
			if i % 2 == 1   { it = alloc Dalmation480 }
			else            { it = alloc Dog480 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList480<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names481 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal481
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names481[rand() % names481.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog481 : Animal481
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation481 : Dog481
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList481<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff481()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog481 [5] {
			if i % 2 == 1   { it = alloc Dalmation481 }
			else            { it = alloc Dog481 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList481<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names482 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal482
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names482[rand() % names482.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog482 : Animal482
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation482 : Dog482
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList482<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff482()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog482 [5] {
			if i % 2 == 1   { it = alloc Dalmation482 }
			else            { it = alloc Dog482 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList482<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names483 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal483
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names483[rand() % names483.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog483 : Animal483
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation483 : Dog483
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList483<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff483()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog483 [5] {
			if i % 2 == 1   { it = alloc Dalmation483 }
			else            { it = alloc Dog483 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList483<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names484 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal484
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names484[rand() % names484.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog484 : Animal484
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation484 : Dog484
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList484<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff484()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog484 [5] {
			if i % 2 == 1   { it = alloc Dalmation484 }
			else            { it = alloc Dog484 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList484<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names485 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal485
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names485[rand() % names485.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog485 : Animal485
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation485 : Dog485
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList485<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff485()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog485 [5] {
			if i % 2 == 1   { it = alloc Dalmation485 }
			else            { it = alloc Dog485 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList485<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names486 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal486
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names486[rand() % names486.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog486 : Animal486
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation486 : Dog486
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList486<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff486()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog486 [5] {
			if i % 2 == 1   { it = alloc Dalmation486 }
			else            { it = alloc Dog486 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList486<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names487 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal487
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names487[rand() % names487.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog487 : Animal487
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation487 : Dog487
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList487<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff487()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog487 [5] {
			if i % 2 == 1   { it = alloc Dalmation487 }
			else            { it = alloc Dog487 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList487<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names488 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal488
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names488[rand() % names488.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog488 : Animal488
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation488 : Dog488
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList488<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff488()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog488 [5] {
			if i % 2 == 1   { it = alloc Dalmation488 }
			else            { it = alloc Dog488 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList488<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names489 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal489
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names489[rand() % names489.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog489 : Animal489
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation489 : Dog489
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList489<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff489()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog489 [5] {
			if i % 2 == 1   { it = alloc Dalmation489 }
			else            { it = alloc Dog489 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList489<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names490 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal490
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names490[rand() % names490.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog490 : Animal490
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation490 : Dog490
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList490<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff490()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog490 [5] {
			if i % 2 == 1   { it = alloc Dalmation490 }
			else            { it = alloc Dog490 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList490<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names491 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal491
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names491[rand() % names491.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog491 : Animal491
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation491 : Dog491
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList491<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff491()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog491 [5] {
			if i % 2 == 1   { it = alloc Dalmation491 }
			else            { it = alloc Dog491 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList491<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names492 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal492
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names492[rand() % names492.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog492 : Animal492
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation492 : Dog492
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList492<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff492()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog492 [5] {
			if i % 2 == 1   { it = alloc Dalmation492 }
			else            { it = alloc Dog492 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList492<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names493 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal493
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names493[rand() % names493.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog493 : Animal493
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation493 : Dog493
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList493<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff493()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog493 [5] {
			if i % 2 == 1   { it = alloc Dalmation493 }
			else            { it = alloc Dog493 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList493<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names494 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal494
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names494[rand() % names494.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog494 : Animal494
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation494 : Dog494
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList494<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff494()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog494 [5] {
			if i % 2 == 1   { it = alloc Dalmation494 }
			else            { it = alloc Dog494 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList494<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names495 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal495
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names495[rand() % names495.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog495 : Animal495
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation495 : Dog495
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList495<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff495()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog495 [5] {
			if i % 2 == 1   { it = alloc Dalmation495 }
			else            { it = alloc Dog495 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList495<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names496 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal496
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names496[rand() % names496.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog496 : Animal496
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation496 : Dog496
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList496<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff496()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog496 [5] {
			if i % 2 == 1   { it = alloc Dalmation496 }
			else            { it = alloc Dog496 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList496<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names497 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal497
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names497[rand() % names497.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog497 : Animal497
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation497 : Dog497
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList497<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff497()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog497 [5] {
			if i % 2 == 1   { it = alloc Dalmation497 }
			else            { it = alloc Dog497 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList497<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names498 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal498
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names498[rand() % names498.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog498 : Animal498
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation498 : Dog498
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList498<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff498()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog498 [5] {
			if i % 2 == 1   { it = alloc Dalmation498 }
			else            { it = alloc Dog498 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList498<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names499 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal499
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names499[rand() % names499.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog499 : Animal499
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation499 : Dog499
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList499<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff499()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog499 [5] {
			if i % 2 == 1   { it = alloc Dalmation499 }
			else            { it = alloc Dog499 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList499<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names500 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal500
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names500[rand() % names500.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog500 : Animal500
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation500 : Dog500
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList500<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff500()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog500 [5] {
			if i % 2 == 1   { it = alloc Dalmation500 }
			else            { it = alloc Dog500 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList500<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names501 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal501
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names501[rand() % names501.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog501 : Animal501
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation501 : Dog501
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList501<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff501()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog501 [5] {
			if i % 2 == 1   { it = alloc Dalmation501 }
			else            { it = alloc Dog501 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList501<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names502 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal502
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names502[rand() % names502.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog502 : Animal502
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation502 : Dog502
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList502<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff502()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog502 [5] {
			if i % 2 == 1   { it = alloc Dalmation502 }
			else            { it = alloc Dog502 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList502<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names503 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal503
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names503[rand() % names503.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog503 : Animal503
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation503 : Dog503
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList503<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff503()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog503 [5] {
			if i % 2 == 1   { it = alloc Dalmation503 }
			else            { it = alloc Dog503 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList503<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names504 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal504
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names504[rand() % names504.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog504 : Animal504
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation504 : Dog504
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList504<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff504()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog504 [5] {
			if i % 2 == 1   { it = alloc Dalmation504 }
			else            { it = alloc Dog504 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList504<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names505 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal505
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names505[rand() % names505.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog505 : Animal505
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation505 : Dog505
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList505<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff505()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog505 [5] {
			if i % 2 == 1   { it = alloc Dalmation505 }
			else            { it = alloc Dog505 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList505<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names506 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal506
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names506[rand() % names506.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog506 : Animal506
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation506 : Dog506
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList506<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff506()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog506 [5] {
			if i % 2 == 1   { it = alloc Dalmation506 }
			else            { it = alloc Dog506 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList506<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names507 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal507
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names507[rand() % names507.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog507 : Animal507
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation507 : Dog507
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList507<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff507()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog507 [5] {
			if i % 2 == 1   { it = alloc Dalmation507 }
			else            { it = alloc Dog507 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList507<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names508 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal508
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names508[rand() % names508.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog508 : Animal508
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation508 : Dog508
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList508<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff508()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog508 [5] {
			if i % 2 == 1   { it = alloc Dalmation508 }
			else            { it = alloc Dog508 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList508<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names509 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal509
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names509[rand() % names509.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog509 : Animal509
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation509 : Dog509
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList509<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff509()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog509 [5] {
			if i % 2 == 1   { it = alloc Dalmation509 }
			else            { it = alloc Dog509 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList509<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names510 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal510
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names510[rand() % names510.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog510 : Animal510
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation510 : Dog510
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList510<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff510()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog510 [5] {
			if i % 2 == 1   { it = alloc Dalmation510 }
			else            { it = alloc Dog510 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList510<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names511 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal511
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names511[rand() % names511.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog511 : Animal511
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation511 : Dog511
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList511<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff511()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog511 [5] {
			if i % 2 == 1   { it = alloc Dalmation511 }
			else            { it = alloc Dog511 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList511<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}

@entry fn main() -> i32 {
	stuff0()
	stuff1()
	stuff2()
	stuff3()
	stuff4()
	stuff5()
	stuff6()
	stuff7()
	stuff8()
	stuff9()
	stuff10()
	stuff11()
	stuff12()
	stuff13()
	stuff14()
	stuff15()
	stuff16()
	stuff17()
	stuff18()
	stuff19()
	stuff20()
	stuff21()
	stuff22()
	stuff23()
	stuff24()
	stuff25()
	stuff26()
	stuff27()
	stuff28()
	stuff29()
	stuff30()
	stuff31()
	stuff32()
	stuff33()
	stuff34()
	stuff35()
	stuff36()
	stuff37()
	stuff38()
	stuff39()
	stuff40()
	stuff41()
	stuff42()
	stuff43()
	stuff44()
	stuff45()
	stuff46()
	stuff47()
	stuff48()
	stuff49()
	stuff50()
	stuff51()
	stuff52()
	stuff53()
	stuff54()
	stuff55()
	stuff56()
	stuff57()
	stuff58()
	stuff59()
	stuff60()
	stuff61()
	stuff62()
	stuff63()
	stuff64()
	stuff65()
	stuff66()
	stuff67()
	stuff68()
	stuff69()
	stuff70()
	stuff71()
	stuff72()
	stuff73()
	stuff74()
	stuff75()
	stuff76()
	stuff77()
	stuff78()
	stuff79()
	stuff80()
	stuff81()
	stuff82()
	stuff83()
	stuff84()
	stuff85()
	stuff86()
	stuff87()
	stuff88()
	stuff89()
	stuff90()
	stuff91()
	stuff92()
	stuff93()
	stuff94()
	stuff95()
	stuff96()
	stuff97()
	stuff98()
	stuff99()
	stuff100()
	stuff101()
	stuff102()
	stuff103()
	stuff104()
	stuff105()
	stuff106()
	stuff107()
	stuff108()
	stuff109()
	stuff110()
	stuff111()
	stuff112()
	stuff113()
	stuff114()
	stuff115()
	stuff116()
	stuff117()
	stuff118()
	stuff119()
	stuff120()
	stuff121()
	stuff122()
	stuff123()
	stuff124()
	stuff125()
	stuff126()
	stuff127()
	stuff128()
	stuff129()
	stuff130()
	stuff131()
	stuff132()
	stuff133()
	stuff134()
	stuff135()
	stuff136()
	stuff137()
	stuff138()
	stuff139()
	stuff140()
	stuff141()
	stuff142()
	stuff143()
	stuff144()
	stuff145()
	stuff146()
	stuff147()
	stuff148()
	stuff149()
	stuff150()
	stuff151()
	stuff152()
	stuff153()
	stuff154()
	stuff155()
	stuff156()
	stuff157()
	stuff158()
	stuff159()
	stuff160()
	stuff161()
	stuff162()
	stuff163()
	stuff164()
	stuff165()
	stuff166()
	stuff167()
	stuff168()
	stuff169()
	stuff170()
	stuff171()
	stuff172()
	stuff173()
	stuff174()
	stuff175()
	stuff176()
	stuff177()
	stuff178()
	stuff179()
	stuff180()
	stuff181()
	stuff182()
	stuff183()
	stuff184()
	stuff185()
	stuff186()
	stuff187()
	stuff188()
	stuff189()
	stuff190()
	stuff191()
	stuff192()
	stuff193()
	stuff194()
	stuff195()
	stuff196()
	stuff197()
	stuff198()
	stuff199()
	stuff200()
	stuff201()
	stuff202()
	stuff203()
	stuff204()
	stuff205()
	stuff206()
	stuff207()
	stuff208()
	stuff209()
	stuff210()
	stuff211()
	stuff212()
	stuff213()
	stuff214()
	stuff215()
	stuff216()
	stuff217()
	stuff218()
	stuff219()
	stuff220()
	stuff221()
	stuff222()
	stuff223()
	stuff224()
	stuff225()
	stuff226()
	stuff227()
	stuff228()
	stuff229()
	stuff230()
	stuff231()
	stuff232()
	stuff233()
	stuff234()
	stuff235()
	stuff236()
	stuff237()
	stuff238()
	stuff239()
	stuff240()
	stuff241()
	stuff242()
	stuff243()
	stuff244()
	stuff245()
	stuff246()
	stuff247()
	stuff248()
	stuff249()
	stuff250()
	stuff251()
	stuff252()
	stuff253()
	stuff254()
	stuff255()
	stuff256()
	stuff257()
	stuff258()
	stuff259()
	stuff260()
	stuff261()
	stuff262()
	stuff263()
	stuff264()
	stuff265()
	stuff266()
	stuff267()
	stuff268()
	stuff269()
	stuff270()
	stuff271()
	stuff272()
	stuff273()
	stuff274()
	stuff275()
	stuff276()
	stuff277()
	stuff278()
	stuff279()
	stuff280()
	stuff281()
	stuff282()
	stuff283()
	stuff284()
	stuff285()
	stuff286()
	stuff287()
	stuff288()
	stuff289()
	stuff290()
	stuff291()
	stuff292()
	stuff293()
	stuff294()
	stuff295()
	stuff296()
	stuff297()
	stuff298()
	stuff299()
	stuff300()
	stuff301()
	stuff302()
	stuff303()
	stuff304()
	stuff305()
	stuff306()
	stuff307()
	stuff308()
	stuff309()
	stuff310()
	stuff311()
	stuff312()
	stuff313()
	stuff314()
	stuff315()
	stuff316()
	stuff317()
	stuff318()
	stuff319()
	stuff320()
	stuff321()
	stuff322()
	stuff323()
	stuff324()
	stuff325()
	stuff326()
	stuff327()
	stuff328()
	stuff329()
	stuff330()
	stuff331()
	stuff332()
	stuff333()
	stuff334()
	stuff335()
	stuff336()
	stuff337()
	stuff338()
	stuff339()
	stuff340()
	stuff341()
	stuff342()
	stuff343()
	stuff344()
	stuff345()
	stuff346()
	stuff347()
	stuff348()
	stuff349()
	stuff350()
	stuff351()
	stuff352()
	stuff353()
	stuff354()
	stuff355()
	stuff356()
	stuff357()
	stuff358()
	stuff359()
	stuff360()
	stuff361()
	stuff362()
	stuff363()
	stuff364()
	stuff365()
	stuff366()
	stuff367()
	stuff368()
	stuff369()
	stuff370()
	stuff371()
	stuff372()
	stuff373()
	stuff374()
	stuff375()
	stuff376()
	stuff377()
	stuff378()
	stuff379()
	stuff380()
	stuff381()
	stuff382()
	stuff383()
	stuff384()
	stuff385()
	stuff386()
	stuff387()
	stuff388()
	stuff389()
	stuff390()
	stuff391()
	stuff392()
	stuff393()
	stuff394()
	stuff395()
	stuff396()
	stuff397()
	stuff398()
	stuff399()
	stuff400()
	stuff401()
	stuff402()
	stuff403()
	stuff404()
	stuff405()
	stuff406()
	stuff407()
	stuff408()
	stuff409()
	stuff410()
	stuff411()
	stuff412()
	stuff413()
	stuff414()
	stuff415()
	stuff416()
	stuff417()
	stuff418()
	stuff419()
	stuff420()
	stuff421()
	stuff422()
	stuff423()
	stuff424()
	stuff425()
	stuff426()
	stuff427()
	stuff428()
	stuff429()
	stuff430()
	stuff431()
	stuff432()
	stuff433()
	stuff434()
	stuff435()
	stuff436()
	stuff437()
	stuff438()
	stuff439()
	stuff440()
	stuff441()
	stuff442()
	stuff443()
	stuff444()
	stuff445()
	stuff446()
	stuff447()
	stuff448()
	stuff449()
	stuff450()
	stuff451()
	stuff452()
	stuff453()
	stuff454()
	stuff455()
	stuff456()
	stuff457()
	stuff458()
	stuff459()
	stuff460()
	stuff461()
	stuff462()
	stuff463()
	stuff464()
	stuff465()
	stuff466()
	stuff467()
	stuff468()
	stuff469()
	stuff470()
	stuff471()
	stuff472()
	stuff473()
	stuff474()
	stuff475()
	stuff476()
	stuff477()
	stuff478()
	stuff479()
	stuff480()
	stuff481()
	stuff482()
	stuff483()
	stuff484()
	stuff485()
	stuff486()
	stuff487()
	stuff488()
	stuff489()
	stuff490()
	stuff491()
	stuff492()
	stuff493()
	stuff494()
	stuff495()
	stuff496()
	stuff497()
	stuff498()
	stuff499()
	stuff500()
	stuff501()
	stuff502()
	stuff503()
	stuff504()
	stuff505()
	stuff506()
	stuff507()
	stuff508()
	stuff509()
	stuff510()
	stuff511()
	return 0
}
