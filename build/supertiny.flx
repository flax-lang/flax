// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import libc

// import std::io
// import std::map

struct foo
{
	var k: int
}

@entry fn main()
{
	// using std as _
	let foo = foo(30)
	var bar: ::foo

	libc::printf("foo.k = %d\n", foo.k)

	libc::printf("done!\n")
}



/*

import std::opt
import std::map

	var map: std::map!<int, str>
	map.insert(3, "foo")

	let r = map.search(3)

	libc::printf("map[3] = %s\n", map.search(3) as std::opt::some)

	let res = map.remove(3)
	libc::printf("map[3]: res = %d, is_none = %d\n", res, map.search(3) is std::opt::none)

	 */



/*
	! bugs !!!
	! 02/12
	{
		// 1. implicit method calling don't seem to work any more... strangely. done a cursory search for our
		// 	'SELF HANDLING' markers, but i can't seem to find the actual place where we *insert* the argument??
		// 	only where we insert the /parameter/ ...

		// 	i think this is less of a bug and more of an omission when we first started taking out the
		// 	haphazard self-handling.

		2. see anytest.flx -- the last segment, with (x as Large).c has some kind of corruption.
			we're getting bogus values on debug builds of the compiler?? which means there's some kind of UB going on
			in the compiler itself...

			expected: a = 631, b = 20, c = 173/30, d = 40, e = 50
			actual:   a = 631, b = 20, c = 173/-572662307, d = 40, e = 50

			note: it's 0xDDDDDDDD in hex, and according to The Internet (tm), that marks FREED MEMORY!

		3. after we enabled referring to types by name in any scope (see typecheck/variable.cpp), we have an issue because
			they're in the same namespace! we give super suboptimal error messages when we try to use a type as a value, or
			when we name a variable the same as a type (ie trying to use a value as a type!)

		4. we should not be able to pass a mapping to the variant of a union, that's a bit weird.
			eg: std::opt::some!<str> works, which is a little strange.
			edit: it only works in certain circumstances??? also if we use a constructor (like this: std::opt::some!<int>(10)), the thing
			get treated like a function call (and so finds no functions!)

		// 5. nested functions 'capture' the scope at which they are defined -- including variables!
		// 	this is Bad News(tm) because we don't support closures, but the typechecker (and codegen) sees the variable 'in scope', and doesn't
		// 	complain. need to figure out a way around this!!!

	}

	! more things.
	! caa 03/10
	{
		2. splatting tuples into a generic function *will not work*
		4. pass the overall location to the polymorph solver.
	}


	TODO for the immediate time frame (that keeps getting longer and where the real work always gets postponed)

	7. move long error messages on spans nearer to the left margin when there's only one span in the error.
	9. fix errors (in general?) {
		a. the generic solver should basically return only a Span, ie. a location with text.
		b. maybe find some way to 'link' two spans together with one message.
		c. figure out if/how we should split up errors when there are too many spans in one context.
			- do we duplicate the context?
			- if not then???
	}
	// 12. allow generic solver to infer things from generic types passed in {
	// 	eg: fn foobar<A, B>(a: Qux<T: A>, b: Qux<T: B>) => ...
	// 	foobar(Qux<T: i64>(), Qux<T: str>()) should infer that A = i64 and B = str.
	// }
	15. builtin way to get a character literal {
		even just enforcing that we get either a string literal of exactly length 1, or an i8 type, at compile-time.
		sure, we could just abort when passed a slice != length 1, but then why bother being statically typed??
	}
*/










// fn overloadErrorTest()
// {
// 	fn printThings(mul: f64, flts: [f64: ...])
// 	{
// 		printf("floats: ");
// 		for i in flts { printf("%.1f ", mul * i) }

// 		printf("\n")
// 	}

// 	fn printThings(mul: str, flts: [f64: ...])
// 	{
// 		printf("floats: ");
// 		for i in flts { printf("%s: %.1f ", mul.ptr, i) }

// 		printf("\n")
// 	}

// 	fn printThings()
// 	{
// 		printf("print things 3\n")
// 	}

// 	do {
// 		printThings(30, ...[as f64: 1, 2, 3, 4, 5 ])
// 		printThings(0.813, 1, 2, 4.41, 39, 491.3, 381.7)
// 	}
// }



// var glob: any
// fn test_refcounting_problem_thing()
// {
// 	fn foo(x: any)
// 	{
// 		if(x is int)
// 		{
// 			glob = x
// 		}
// 	}

// 	foo(30)
// }









