// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
// import "stdio" as _

// var glob: any
// fn test_refcounting_problem_thing()
// {
// 	fn foo(x: any)
// 	{
// 		if(x is int)
// 		{
// 			glob = x
// 		}
// 	}

// 	foo(30)
// }


@entry fn main()
{
	fn getnum() -> int { printf("got num\n"); return 40 }

	let x = 30
	if 1 == 1 < 4 > 3 > -5 == -7 + 2 < 10 > 3
	{
		printf("yay\n")
	}


	overloadErrorTest()
}



/*
	! more things.
	! caa 03/10
	{
		2. splatting tuples into a generic function *will not work*
		4. pass the overall location to the polymorph solver.
	}


	TODO for the immediate time frame (that keeps getting longer and where the real work always gets postponed)

	7. move long error messages on spans nearer to the left margin when there's only one span in the error.
	9. fix errors (in general?) {
		a. the generic solver should basically return only a Span, ie. a location with text.
		b. maybe find some way to 'link' two spans together with one message.
		c. figure out if/how we should split up errors when there are too many spans in one context.
			- do we duplicate the context?
			- if not then???
	}
	// 12. allow generic solver to infer things from generic types passed in {
	// 	eg: fn foobar<A, B>(a: Qux<T: A>, b: Qux<T: B>) => ...
	// 	foobar(Qux<T: i64>(), Qux<T: str>()) should infer that A = i64 and B = str.
	// }
	15. builtin way to get a character literal {
		even just enforcing that we get either a string literal of exactly length 1, or an i8 type, at compile-time.
		sure, we could just abort when passed a slice != length 1, but then why bother being statically typed??
	}
*/










fn overloadErrorTest()
{
	fn printThings(mul: f64, flts: [f64: ...])
	{
		printf("floats: ");
		for i in flts { printf("%.1f ", mul * i) }

		printf("\n")
	}

	fn printThings(mul: str, flts: [f64: ...])
	{
		printf("floats: ");
		for i in flts { printf("%s: %.1f ", mul.ptr, i) }

		printf("\n")
	}

	fn printThings()
	{
		printf("print things 3\n")
	}

	do {
		printThings(30, ...[as f64: 1, 2, 3, 4, 5 ])
		printThings(0.813, 1, 2, 4.41, 39, 491.3, 381.7)
	}
}











