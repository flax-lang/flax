// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc"
import "limits"

import "tests/fizzbuzz"
import "tests/recursiveFib"
import "tests/slices"
import "tests/intlimits"

// import "tests/functions"

// ffi fn printf(fmt: u8*, ...) -> i32

// fn foo(a: int, b: int)
// {
// 	printf("ONE\n")
// }

// fn bar(a: int) -> int
// {
// 	return a * a
// }

// fn foo() -> (int) -> int
// {
// 	return bar
// }

// fn bar1() -> bool { return true }
// fn bar2() -> bool { return false }


// fn doRecursiveFib(n: int, v: int, prev: int) -> int
// {
// 	if n == 0 { return prev }
// 	if n == 1 { return v }

// 	return doRecursiveFib(n - 1, v + prev, v)
// }

// fn doRecursiveFib(n: int) -> int
// {
// 	return doRecursiveFib(n, 1, 0)
// }


// fn cond() -> bool
// {
// 	printf("T")
// 	return true
// }

namespace g
{
	fn some() { }
	namespace h
	{
		namespace i
		{
			var globby = 30
		}
	}

	class nest
	{
		static fn nfn()
		{
			printf("nfn\n")
		}
	}
}

namespace ns
{
	fn test()
	{
		printf("this is a test\n")
	}

	namespace ns2
	{
		namespace ns3
		{
			fn test2() { printf("testing 2\n") }
		}
	}

	let someglob = 30
}

public fn twice(a: int) -> int { return 2 * a }

@entry fn main(argc: i32, argv: i8**) -> int
{
	fn inner()
	{
		printf("inner\n")
	}

	class foo
	{
		var k: int
		var j: double

		var s: string
		var f: (int) -> int

		struct bar
		{
			var x: int = 30
		}

		var b: bar

		static fn sfn() { printf("static func\n"); }

		fn dostuff(a: int) -> double { return (k as f64) + (a as f64) * j + (self.get2() + get2()) + (f(15) as f64) }
		fn get2() -> f64 { return 2.0 }
	}


	fn somefn() -> foo
	{
		var a: foo
		a.k = 30
		a.s = "rick" + "astley"

		a.b.x = 117

		return a
	}

	// fn getstr() -> string { return "A" + "B" }

	let q = somefn()
	printf("q.k = %d, q.s = %s, q.b.x = %d\n", q.k, q.s, q.b.x)

	var x: foo
	x.f = twice
	x.j = 1.738

	foo.get2(&x)
	let f = foo.sfn
	f()

	let nf = g.nest.nfn
	nf()

	// let some = twice
	// printf("some = %d, %p\n", some(17), some)

	printf("x = %.2f / twice = %d\n", x.dostuff(30), x.f(30))
	printf("global = %d\n", g.h.i.globby)

	let uni = "ƒ(x) = √x"
	printf("'%s'.length = %d, count = %d\n", uni, uni.length, uni.count)

	ns.test()

	printf("\n\n")


	// doFizzBuzz(20)
	// doSlicesTest()

	// let fib = doRecursiveFib(20)
	// printf("\nfib(20) = %d\n", fib)

	printIntegerLimits()

	enum Foob: int
	{
		case one = 10
		case two = 20
		case three = "30"
	}



	// var s = getstr()

	// printf("a.k = %d / a.j = %.2f\n", a.k, a.j)

	// var tup = (s, 30, 40)
	// printf("tup = (%s, %d, %d)\n", tup.0, tup.1, tup.2)

	// inner()



	// let str = "hello" + "world"
	// let str1 = str + " number 10"

	// printf("---\n")
	// var str2: string
	// str2 = str1

	// let x = foo()(7)
	// printf("x = %d\n", x)

	// // printf("str = %s\n", str1)

	// let arr = [ 1, 2 ] + [ 3, 4 ]

	// let eq = ("hello" == "hello")
	// printf("eq = %d\n", eq)

	// var counter = 0
	// while counter < 30
	// {
	// 	counter += 1
	// 	printf("%d - ", counter)

	// 	// var str = "foo" + "bar"

	// 	if counter > 20
	// 	{
	// 		break
	// 	}
	// 	else
	// 	{
	// 		continue
	// 	}

	// 	printf("no\n")
	// }
	// printf("\n\n")

	// ns.test1()

	// let k: (string, string, string) = (1, 2, 3)

	// printf("str = %s\n", str)

	// printf("fib(20) = %d\n", doRecursiveFib(20))

	// var bar = -(401 + 76.1) as f64
	// var qux = 30

	// var fun: (int, int) -> void = foo

	// fun(30, 30)

	// printf("bar = %.1f, &bar = %p, qux = %d\n", bar, &bar, *&qux)
	// printf(@r"%s, %d, not-bar = %f\n", @r"Hello, World", -34, 1.1 - 4.5)
	// printf("end\n")

	// foo(10)
	// foo(10, 20)


	// var one = 40
	// let op = &one

	// var arr = [ 1, 2, 3, 4 ]
	// arr[0] = 3

	// printf("arr[0] = %d\n", arr[0])


	// if(var k = 2; bar1() || bar2())
	// {
	// 	printf("k < 3\n")

	// 	if(10 > 30)
	// 	{
	// 		printf("TRUE\n")
	// 	}
	// 	else
	// 	{
	// 		printf("FALSE\n")
	// 	}
	// }
	// else if(var m = 40; m > 1)
	// {
	// 	printf("m > 1\n");
	// }
	// else
	// {
	// 	printf("else: k = %d, m = %d\n", k, m)
	// }

	printf("quit\n")

	return 0
}



// fn bar1() -> bool
// {
// 	printf("BAR ONE\n")
// 	return true
// }

// fn bar2() -> bool
// {
// 	printf("BAR TWO\n")

// 	if true { }
// 	else if false { }

// 	return false
// }








