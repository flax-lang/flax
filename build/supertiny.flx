// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
import "math" as _

// ffi fn srand(s: i32)
// ffi fn rand() -> i32

// let names = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

// class Animal
// {
// 	init(w: f64)
// 	{
// 		// printf("make animal w = %f\n", w)
// 		weight = w
// 		name = names[rand() % names.length]
// 	}

// 	virtual fn makeNoise()
// 	{
// 		printf("some generic sound\n")
// 	}

// 	var name: str
// 	var weight: f64
// 	var cute: bool = true
// }

// class Dog : Animal
// {
// 	init() : super(w: 300)
// 	{
// 		// printf("make dog (w = %f)\n", weight)
// 	}

// 	override fn makeNoise()
// 	{
// 		printf("bark bark (%f)\n", weight)
// 	}

// 	virtual fn wag()
// 	{
// 		printf("wagging tail of length %d\n", tail)
// 	}

// 	var tail: int = 37
// }

// class Dalmation : Dog
// {
// 	init() : super()
// 	{
// 		printf("make dalmation\n")
// 	}

// 	override fn wag()
// 	{
// 		printf("dalmation wags %d\n", tail)
// 	}

// 	var numSpots: int
// }


class LinkedList<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init(data: T)
	{
		printf("called init with %d\n", data)
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() { printf("hi\n"); }
}




@entry fn main()
{
	/*
		Things to fix:

		2. possibly allow overloading mutable and non-mutable methods with the same signature?
	*/

	/*
		TODO list for proper generic support:

		// 1. factor out the code in typecheck/variable.cpp that searches for generic stuff into a new thing
		// 2. modify resolveFunction to take generic mapping information.
		// 3. call that new thing from typecheck/call.cpp in resolveFunction.
		4. if we're passed in the generic mappings, we can use similar logic (the variable thing) (that we factored out) to instantiate
			the appropriate generic function.

		5. for cases where we don't have explicit mappings, since resolveFunction already has the parameter types, we can call our type
			inference algorithm from there, both for functions as well as type constructors -- both struct and class.

		5b. for struct constructors, it should be a simple case of mapping the struct fields to the function call parameter 'format', if you will.
			for classes we just pass in all the init functions as candidates, since those will just be generic over their parents' types.

		6. once we get the generic solver working, we should be able to provide it a partial list (that the user may have given) to aid its solving.
			for now, it's all or nothing -- if you provide some you must provide all (or we will error).
	*/


	do {
		fn foo<T>(a: T, b: T) -> T { return a + b }

		let k = foo<T: int>(10, 20)
		printf("k = %d\n", k)

		let a: [int] = [ 1, 2, 3 ]
		let b: [int] = [ 4, 5, 6 ]

		let h = foo<T: [int]>(a, b)
		for n, i in h {
			printf("%d: %d\n", i, n)
		}

		// printf("\n\n. %d", fa)
	}


	// do {
	// 	// don't question.
	// 	srand(284811)

	// 	// fn test() -> f64 { printf("hi\n"); return 31.51 }

	// 	let dogs = alloc &Dog [5] {
	// 		if i % 2 == 1   { it = alloc Dalmation }
	// 		else            { it = alloc Dog }
	// 	}

	// 	for dog, i in dogs {
	// 		printf("%d: %s - ", i, dog.name)
	// 		dog.wag()
	// 	}
	// }



	do {
		var list = LinkedList<T: int>(data: 41)
		LinkedList<T: int>.hello()

		var list2 = LinkedList<T: str>(data: "foo")
		list2.insert("hello")
		list2.insert("world")

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		do {
			var head = list.head
			while(head)
			{
				printf("%d\n", head.data)
				head = head.next
			}
		}

		do {
			var head = list2.head
			while(head)
			{
				printf("%s\n", head.data)
				head = head.next
			}
		}
	}
}











/*

@operator prefix 950 √
@operator infix 800 dot
@operator infix 800 cross



struct vec2
{
	var x: int
	var y: int
}

struct vec3
{
	var x: int
	var y: int
	var z: int
}


operator infix + (a: vec2, b: vec2) -> vec2
{
	return vec2(x: a.x + b.x,
				y: a.y + b.y);
}

operator infix + (a: vec3, b: vec3) -> vec3
{
	return vec3(x: a.x + b.x,
				y: a.y + b.y,
				z: a.z + b.z);
}



operator prefix √ (a: double) -> double
{
	return sqrt(a)
}

operator infix dot (a: vec2, b: vec2) -> int
{
	return a.x * b.x + a.y * b.y
}

operator infix dot (a: vec3, b: vec3) -> int
{
	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)
}

operator infix cross (a: vec3, b: vec3) -> vec3
{
	return vec3(x: (a.y * b.z) - (a.z * b.y),
				y: (a.z * b.x) - (a.x * b.z),
				z: (a.x * b.y) - (a.y * b.x));
}



 */
