// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
import "math" as _

@operator prefix 950 √
@operator infix 800 dot
@operator infix 800 cross


struct vec2
{
	var x: int
	var y: int
}

struct vec3
{
	var x: int
	var y: int
	var z: int
}


operator infix + (a: vec2, b: vec2) -> vec2
{
	return vec2(x: a.x + b.x,
				y: a.y + b.y);
}

operator infix + (a: vec3, b: vec3) -> vec3
{
	return vec3(x: a.x + b.x,
				y: a.y + b.y,
				z: a.z + b.z);
}



operator prefix √ (a: double) -> double
{
	return sqrt(a)
}

operator infix dot (a: vec2, b: vec2) -> int
{
	return a.x * b.x + a.y * b.y
}

operator infix dot (a: vec3, b: vec3) -> int
{
	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)
}

operator infix cross (a: vec3, b: vec3) -> vec3
{
	return vec3(x: (a.y * b.z) - (a.z * b.y),
				y: (a.z * b.x) - (a.x * b.z),
				z: (a.x * b.y) - (a.y * b.x));
}


fn somefunc(a: int, b: int) -> int => a * b


@entry fn main()
{
	let a = vec3(y: 20, x: 10, z: 4)
	let b = vec3(23, 17, 9)
	let k = vec3()
	// var a: vec3; a.x = 10; a.y = 20; a.z = 4;
	// var b: vec3; b.x = 23; b.y = 17; b.z = 9;

	let c = a + b
	let d = a dot b
	let e = a cross b

	printf("%d\n", somefunc(a: 10, b: 20))

	printf("c = (%d, %d, %d), e = (%d, %d, %d)  |  (%d), (%f)\n", c.x, c.y, c.z, e.x, e.y, e.z, d, √1491)
}




