// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
import "math" as _

ffi fn srand(s: i32)
ffi fn rand() -> i32

// let names = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

// class Animal
// {
// 	init(w: f64)
// 	{
// 		// printf("make animal w = %f\n", w)
// 		weight = w
// 		name = names[rand() % names.length]
// 	}

// 	virtual fn makeNoise()
// 	{
// 		printf("some generic sound\n")
// 	}

// 	var name: string
// 	var weight: f64
// 	var cute: bool = true
// }

// class Dog : Animal
// {
// 	init() : super(w: 300)
// 	{
// 		// printf("make dog (w = %f)\n", weight)
// 	}

// 	override fn makeNoise()
// 	{
// 		printf("bark bark (%f)\n", weight)
// 	}

// 	virtual fn wag()
// 	{
// 		printf("wagging tail of length %d\n", tail)
// 	}

// 	var tail: int = 37
// }

// class Dalmation : Dog
// {
// 	init() : super()
// 	{
// 		printf("make dalmation\n")
// 	}

// 	override fn wag()
// 	{
// 		printf("dalmation wags %d\n", tail)
// 	}

// 	var numSpots: int
// }


struct LinkedList<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}
}


let x: &Foo = null
let y = *x

struct Foo
{
	var a: int
}



@entry fn main()
{
	/*
		Things to fix:

		1. handling of mutating operations on dynamic arrays
		2. possibly allow overloading mutable and non-mutable methods with the same signature?

	*/

	var k: Foo




	// // don't question.
	// srand(284811)

	// // fn test() -> f64 { printf("hi\n"); return 31.51 }

	// let dogs = alloc &Dog [5] {
	// 	it = alloc Dog
	// }

	// for dog, i in dogs {
	// 	printf("%d: %s\n", i, dog.name)
	// }


	var list: LinkedList<T: int>

	list.insert(10)
	list.insert(20)
	list.insert(30)
	list.insert(40)

	var head = list.head
	while(head)
	{
		printf("%d\n", head.data)
		head = head.next
	}
}











/*

@operator prefix 950 √
@operator infix 800 dot
@operator infix 800 cross



struct vec2
{
	var x: int
	var y: int
}

struct vec3
{
	var x: int
	var y: int
	var z: int
}


operator infix + (a: vec2, b: vec2) -> vec2
{
	return vec2(x: a.x + b.x,
				y: a.y + b.y);
}

operator infix + (a: vec3, b: vec3) -> vec3
{
	return vec3(x: a.x + b.x,
				y: a.y + b.y,
				z: a.z + b.z);
}



operator prefix √ (a: double) -> double
{
	return sqrt(a)
}

operator infix dot (a: vec2, b: vec2) -> int
{
	return a.x * b.x + a.y * b.y
}

operator infix dot (a: vec3, b: vec3) -> int
{
	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)
}

operator infix cross (a: vec3, b: vec3) -> vec3
{
	return vec3(x: (a.y * b.z) - (a.z * b.y),
				y: (a.z * b.x) - (a.x * b.z),
				z: (a.x * b.y) - (a.y * b.x));
}



 */
