// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
// import "stdio" as _

// var glob: any
// fn test_refcounting_problem_thing()
// {
// 	fn foo(x: any)
// 	{
// 		if(x is int)
// 		{
// 			glob = x
// 		}
// 	}

// 	foo(30)
// }


import "tests/linkedlist"

@entry fn main()
{
	// do {
	// 	class Foo<T>
	// 	{
	// 		init() { }
	// 		static fn bar(x: T) { printf("x = %d\n", x) }
	// 	}

	// 	Foo.bar(30)
	// }


	test_linkedlist.doLinkedListTest()











	// // some normal FP stuff
	// fn map<T, U>(arr: [T:], fun: fn(T) -> U) -> [U]
	// {
	// 	var ret: [U]
	// 	for it in arr => ret.append(fun(it))

	// 	return ret
	// }

	// do {
	// 	printf("set 1:")

	// 	fn twice<K>(a: K) -> K => a * 2

	// 	let new = map(fun: twice, arr: [ 1, 2, 3, 4, 5 ])
	// 	for it in new { printf(" %d", it) }

	// 	printf("\n")
	// }

	// do {
	// 	printf("set 2:")

	// 	fn twice(a: str) -> string => string(a) + string(a)

	// 	let new = map([ "a", "b", "c", "d", "e" ], twice)
	// 	for it in new => printf(" %s", it)

	// 	printf("\n")
	// }

	// do {
	// 	printf("set 3:")

	// 	fn square<A, B>(a: A) -> B => (a * a)

	// 	let new: [f64] = map([ 7.3, 8.7, 9.1, 10.4, 11.6 ], square)
	// 	for it in new { printf(" %.2f", it) }

	// 	printf("\n")
	// }

	// do {
	// 	fn gincr<A>(x: A) -> A => x + 1
	// 	fn apply<B, C>(x: B, f: fn(B) -> C) -> C => f(x)

	// 	fn mapstupid<D, E, F>(arr: [D:], f: fn(D) -> E, fa: fn(D, fn(D) -> E) -> F) -> [F]
	// 	{
	// 		var i = 0
	// 		var ret: [F]
	// 		while i < arr.length
	// 		{
	// 			ret.append(fa(arr[i], f))
	// 			i += 1
	// 		}

	// 		return ret
	// 	}

	// 	printf("set 4:")
	// 	let new = mapstupid([ 5, 6, 7, 8, 9 ], gincr, apply)
	// 	for it in new { printf(" %d", it) }

	// 	printf("\n")
	// }

	// do {
	// 	fn map2<T, K, R>(arr: [(T, K):], f: fn(T, K) -> R) -> [R]
	// 	{
	// 		var i = 0
	// 		var ret: [R]
	// 		while i < arr.length
	// 		{
	// 			ret.append(f(arr[i].0, arr[i].1))
	// 			i += 1
	// 		}

	// 		return ret
	// 	}

	// 	fn add2<A, B>(x: A, y: B) -> A => x + y

	// 	printf("set 5:")
	// 	let new = map2([ (2, 2), (4, 4), (6, 6), (8, 8), (10, 10) ], add2)
	// 	for it in new { printf(" %d", it) }

	// 	printf("\n")
	// }

	// do {
	// 	fn prints<T, U>(m: T, a: [U: ...])
	// 	{
	// 		for x in a => printf(" %.2d", m * x)
	// 	}

	// 	printf("set 6:")
	// 	let xs = [ 1, 2, 3, 4, 5 ]
	// 	prints(3, ...xs)

	// 	printf("\n")
	// }
}


/*
	! more things.
	! caa 03/10
	{
		1. clean up all the nested types -- sst's Decl::Param, FnCallArgument, ast's Defn::Arg, all that shit.
		2. splatting tuples into a generic function *will not work*
		3. fix errors. should probably go back to using virtual inheritance for them. fuck performance cos we shouldn't be erroring so often,
			and they're slightly cheaper when we don't use them because it's just a pointer.
		4. pass the overall location to the polymorph solver.
		// 5. check for variadic forwarding -- enforce the splat.
		6. print out the solutions we found for inference on error.
		7. clean up FunctionDefn vs FunctionDecl
		8. check if the solution is complete before we blindly try to re-solve everything.
	}










	! slightly more updated notes
	! caa 23/09
	{
		possible things:

		// 1. change the generic type engine to operate on pairs of fir::Types, instead of pts::Types {
		// 	We'd basically need to pre-resolve the pts::Types before going into the inference thingy, which might be
		// 	a bit challenging, maybe.

		// 	the pre-entry to the engine could simply match the pts::Types against the 'problemset' of the generic function,
		// 	and create appropriate fir::PlaceholderTypes based on that information. Should be viable, but i'm not sure.

		// 	Everything else should work the same, and possibly be a bit cleaner since we don't need to be confused between pts and fir??
		// }

		// 2. after that, change function call resolution to use the generic inference solver as well {
		// 	since this would operate on resolved functions, we can omit calling the 'pre-entry' mentioned above (for generic functions)
		// 	and just match fir::Types between the argument types and the parameter types.

		// 	then, we'd have to integrate the existing system of 'scores', and return that information as well from the solver.
		// }

		3. finally, solve the original problem that we set out to solve {
			the original problem is that we have PlaceholderTypes as parameter types for static functions, but the solver was unable to pick
			up on that (and we don't really want it to)

			after re-writing the interfaces, we can potentially omit the entire 'problemspace' thing. We already (i believe) have a method on
			FIR types 'containsPlaceholders'. So we should be able to check for the presence of placeholders and use that to trigger the
			recursive solver (for passing functions and such), rather than relying on a problemset.
		}

		// 4. pretty sure we never actually implemented the iterative solver -- we should probably do that.
	}



	TODO for the immediate time frame (that keeps getting longer and where the real work always gets postponed)

	7. move long error messages on spans nearer to the left margin when there's only one span in the error.
	9. fix errors (in general?) {
		a. the generic solver should basically return only a Span, ie. a location with text.
		b. maybe find some way to 'link' two spans together with one message.
		c. figure out if/how we should split up errors when there are too many spans in one context.
			- do we duplicate the context?
			- if not then???
	}
	12. allow generic solver to infer things from generic types passed in {
		eg: fn foobar<A, B>(a: Qux<T: A>, b: Qux<T: B>) => ...
		foobar(Qux<T: i64>(), Qux<T: str>()) should infer that A = i64 and B = str.
	}
	15. builtin way to get a character literal {
		even just enforcing that we get either a string literal of exactly length 1, or an i8 type, at compile-time.
		sure, we could just abort when passed a slice != length 1, but then why bother being statically typed??
	}
	// 17. refcounted moving is broken -- not sure if design flaw or not. investigate.
	18. generic unions {
		currently they work okay, but it's very troublesome to unwrap, construct or declare them, because you need to
		explicitly state the type of the union.

		given that we just managed to do the thing where we can infer generic types from constructor arguments, we should be
		able to do a similar thing for this case.

		the problem here is that we need to be able to turn `Option<T: int>.Some(...)` into `Option.Some(...)`, but when we
		just access `Option` directly without type arguments, we will get yelled at by the typechecker.

		the alternative to this problem is just to disallow inference when doing it like this. then, inference is only enabled
		when we `use` the union:

		```
		using Option

		let x = Some(30)
		let y = None
		```

		on this hand, we will also need to somehow allow `using` a generic union without specifying its type... bah.
	}
	19. using for unions (see 18 for some issues re: generic types)
*/










// fn overloadErrorTest()
// {
// 	fn printThings(mul: f64, flts: [f64: ...])
// 	{
// 		printf("floats: ");
// 		for i in flts { printf("%.1f ", mul * i) }

// 		printf("\n")
// 	}

// 	fn printThings(mul: str, flts: [f64: ...])
// 	{
// 		printf("floats: ");
// 		for i in flts { printf("%s: %.1f ", mul.ptr, i) }

// 		printf("\n")
// 	}

// 	fn printThings()
// 	{
// 		printf("print things 3\n")
// 	}


// 	do {
// 		printThings(30, ...[ 1, 2, 3, 4, 5 ])
// 		printThings(0.813, 1, 2, 4.41, 39, 491.3, 381.7)
// 	}
// }
