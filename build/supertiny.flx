// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
import "math" as _

fn prod(a: int, b: int, c: int, d: int, e: int, f: int) -> int => a*b*c*d*e*f


@entry fn main()
{
	let tup = (1, 2, 3, 4, 5, 6)
	printf("prod = %d\n", prod(...tup))

	let tup1 = (1, 2, 3)
	let tup2 = (4, 5, 6)

	let p1 = prod(1, 2, 3, ...tup2)
	let p2 = prod(...tup1, 4, 5, 6)
	let p3 = prod(...tup1, ...tup2)

	struct vec3
	{
		var x: int
		var y: int
		var z: int
	}

	let v3 = vec3(...tup2)

	printf("p1 = %d; p2 = %d; p3 = %d\n", p1, p2, p3)
}




/*

@operator prefix 950 âˆš
@operator infix 800 dot
@operator infix 800 cross



struct vec2
{
	var x: int
	var y: int
}

struct vec3
{
	var x: int
	var y: int
	var z: int
}


operator infix + (a: vec2, b: vec2) -> vec2
{
	return vec2(x: a.x + b.x,
				y: a.y + b.y);
}

operator infix + (a: vec3, b: vec3) -> vec3
{
	return vec3(x: a.x + b.x,
				y: a.y + b.y,
				z: a.z + b.z);
}



operator prefix âˆš (a: double) -> double
{
	return sqrt(a)
}

operator infix dot (a: vec2, b: vec2) -> int
{
	return a.x * b.x + a.y * b.y
}

operator infix dot (a: vec3, b: vec3) -> int
{
	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)
}

operator infix cross (a: vec3, b: vec3) -> vec3
{
	return vec3(x: (a.y * b.z) - (a.z * b.y),
				y: (a.z * b.x) - (a.x * b.z),
				z: (a.x * b.y) - (a.y * b.x));
}



 */