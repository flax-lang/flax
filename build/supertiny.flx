// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
import "math" as _

// ffi fn srand(s: i32)
// ffi fn rand() -> i32

// let names = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

// class Animal
// {
// 	init(w: f64)
// 	{
// 		// printf("make animal w = %f\n", w)
// 		weight = w
// 		name = names[rand() % names.length]
// 	}

// 	virtual fn makeNoise()
// 	{
// 		printf("some generic sound\n")
// 	}

// 	var name: str
// 	var weight: f64
// 	var cute: bool = true
// }

// class Dog : Animal
// {
// 	init() : super(w: 300)
// 	{
// 		// printf("make dog (w = %f)\n", weight)
// 	}

// 	override fn makeNoise()
// 	{
// 		printf("bark bark (%f)\n", weight)
// 	}

// 	virtual fn wag()
// 	{
// 		printf("wagging tail of length %d\n", tail)
// 	}

// 	var tail: int = 37
// }

// class Dalmation : Dog
// {
// 	init() : super()
// 	{
// 		printf("make dalmation\n")
// 	}

// 	override fn wag()
// 	{
// 		printf("dalmation wags %d\n", tail)
// 	}

// 	var numSpots: int
// }


// class LinkedList<T>
// {
// 	struct Node
// 	{
// 		var data: T

// 		var prev: &Node
// 		var next: &Node
// 	}

// 	var head: &Node
// 	var tail: &Node

// 	var count: int

// 	init(data: T)
// 	{
// 		printf("called init with %p\n", data)
// 	}

// 	mut fn insert(thing: T)
// 	{
// 		var nn = alloc mut Node (data: thing, prev: null, next: null)

// 		if head == null { head = nn; tail = nn }
// 		else
// 		{
// 			var ot = tail as mut
// 			tail = nn

// 			nn.prev = ot
// 			ot.next = nn
// 		}

// 		count += 1
// 	}

// 	static fn hello() { printf("hi\n"); }
// }

// fn printThings(mul: int, ints: [int: ...])
// {
// 	printf("ints: ");
// 	for i in ints { printf("%d ", mul * i) }

// 	printf("\n")
// }

fn printThings(mul: f64, flts: [f64: ...])
{
	printf("floats: ");
	for i in flts { printf("%.1f ", mul * i) }

	printf("\n")
}

fn printThings(mul: str, flts: [f64: ...])
{
	printf("floats: ");
	for i in flts { printf("%s: %.1f ", mul.ptr, i) }

	printf("\n")
}

fn printThings()
{
	printf("print things 3\n")
}

@entry fn main()
{
	/*
		TODO list for proper generic support:

		// 1. factor out the code in typecheck/variable.cpp that searches for generic stuff into a new thing
		// 2. modify resolveFunction to take generic mapping information.
		// 3. call that new thing from typecheck/call.cpp in resolveFunction.
		4. if we're passed in the generic mappings, we can use similar logic (the variable thing) (that we factored out) to instantiate
			the appropriate generic function.

		5. for cases where we don't have explicit mappings, since resolveFunction already has the parameter types, we can call our type
			inference algorithm from there, both for functions as well as type constructors -- both struct and class.

		5b. for struct constructors, it should be a simple case of mapping the struct fields to the function call parameter 'format', if you will.
			for classes we just pass in all the init functions as candidates, since those will just be generic over their parents' types.

		6. once we get the generic solver working, we should be able to provide it a partial list (that the user may have given) to aid its solving.
			for now, it's all or nothing -- if you provide some you must provide all (or we will error).
	*/

	/*
		TODO for this week (that keeps getting longer and where the real work always gets postponed)

		// 1. constructor syntax for builtin types
		2. start work on the generic type solver?           <-- seriously get started on this
		// 3. variadic functions
		// 3a. make variadic forwarding work properly
		4. optional arguments                               <-- do we actually want this?

	 */

	do {
		printf("HELLO???\n")
		printThings(30, ...[ 1, 2, 3, 4, 5 ])
		// printThings(0.813, 1, 2, 4.41, 39, 491.3, 381.7)

		let k: str = "foo"
		k + 30
	}

	// do {
	// 	let foo = string("HELLO") + string(" ") + string("WORLD") + string("???".ptr, "???".length)
	// 	printf("foo = '%s'\n", foo)
	// }


	// do {
	// 	class Foo<T>
	// 	{
	// 		var x: T

	// 		init() { }
	// 	}

	// 	class Bar<T> : Foo<T: T>
	// 	{
	// 		var y: T

	// 		init(y: T) : super()
	// 		{
	// 			self.y = y
	// 			self.x = y + y
	// 		}
	// 	}

	// 	let k = Bar<T: int>(y: 30)
	// 	printf("y = %d\n", k.x)
	// }

	// do {
	// 	fn foo<T>(a: T, b: T) -> T { return a + b }

	// 	let k = foo<T: int>(10, 20)
	// 	printf("k = %d\n", k)

	// 	let a: [int] = [ 1, 2, 3 ]
	// 	let b: [int] = [ 4, 5, 6 ]

	// 	let h = foo<T: [int]>(a, b)
	// 	for n, i in h {
	// 		printf("%d: %d\n", i, n)
	// 	}

	// 	// printf("\n\n. %d", fa)
	// }


	// do {
	// 	// don't question.
	// 	srand(284811)

	// 	// fn test() -> f64 { printf("hi\n"); return 31.51 }

	// 	let dogs = alloc &Dog [5] {
	// 		if i % 2 == 1   { it = alloc Dalmation }
	// 		else            { it = alloc Dog }
	// 	}

	// 	for dog, i in dogs {
	// 		printf("%d: %s - ", i, dog.name)
	// 		dog.wag()
	// 	}
	// }



	// do {
	// 	var list = LinkedList<T: int>(data: 41)
	// 	LinkedList<T: int>.hello()

	// 	var list2 = LinkedList<T: str>(data: "foo")
	// 	list2.insert("hello")
	// 	list2.insert("world")

	// 	list.insert(10)
	// 	list.insert(20)
	// 	list.insert(30)
	// 	list.insert(40)

	// 	do {
	// 		var head = list.head
	// 		while(head)
	// 		{
	// 			printf("%d\n", head.data)
	// 			head = head.next
	// 		}
	// 	}

	// 	do {
	// 		var head = list2.head
	// 		while(head)
	// 		{
	// 			printf("%s\n", head.data)
	// 			head = head.next
	// 		}
	// 	}
	// }
}











/*

@operator prefix 950 √
@operator infix 800 dot
@operator infix 800 cross



struct vec2
{
	var x: int
	var y: int
}

struct vec3
{
	var x: int
	var y: int
	var z: int
}


operator infix + (a: vec2, b: vec2) -> vec2
{
	return vec2(x: a.x + b.x,
				y: a.y + b.y);
}

operator infix + (a: vec3, b: vec3) -> vec3
{
	return vec3(x: a.x + b.x,
				y: a.y + b.y,
				z: a.z + b.z);
}



operator prefix √ (a: double) -> double
{
	return sqrt(a)
}

operator infix dot (a: vec2, b: vec2) -> int
{
	return a.x * b.x + a.y * b.y
}

operator infix dot (a: vec3, b: vec3) -> int
{
	return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)
}

operator infix cross (a: vec3, b: vec3) -> vec3
{
	return vec3(x: (a.y * b.z) - (a.z * b.y),
				y: (a.z * b.x) - (a.x * b.z),
				z: (a.x * b.y) - (a.y * b.x));
}



 */






 /*


error: No matching overload in call to 'printThings(number, [i64:])' amongst 3 candidates
at:    /path/to/source/file.flx:341:23

call site:
    |
341 |    printThings(30, ...[ 1, 2, 3, 4, 5 ])
    |    ^^^^^^^^^^^

note: candidate 1 was defined here
at:   /path/to/thing:425:4
    |
425 |    fn printThings(a: int, b: [f64: ...])
    |                           ^^^^^^^^^^^^^
    |                           |> mismatched type '[i64: ...]' at call site

note: candidate 2 was defined here:
at: /path/to/thing:430:4
    |
430 |    fn printThings(a: str, b: [f64: ...])
    |                   ^^^^^^     ^^^^^^^^^^
    |                   |          |> mismatched type '[i64: ...]' at call site
    |                   |          |> bla bla bla
    |                   |
    |                   |> mismatched type 'int' at call site

note: candidate 3 was defined here:
at: /path/to/thing:440:4
    |
440 |    fn printThings()
    |                  ^^
    |                  |> mismatched number of arguments;
    |                     expected 0, found 2 at call site




 */
