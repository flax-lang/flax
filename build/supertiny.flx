// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny
import "IntegerLimits.flx"
import "LibCInterface.flx"

// ffi fn printf(fmt: u8*, ...) -> i32

// fn foo(a: int, b: int)
// {
// 	printf("ONE\n")
// }

// fn bar(a: int) -> int
// {
// 	return a * a
// }

// fn foo() -> (int) -> int
// {
// 	return bar
// }

// fn bar1() -> bool { return true }
// fn bar2() -> bool { return false }


// fn doRecursiveFib(n: int, v: int, prev: int) -> int
// {
// 	if n == 0 { return prev }
// 	if n == 1 { return v }

// 	return doRecursiveFib(n - 1, v + prev, v)
// }

// fn doRecursiveFib(n: int) -> int
// {
// 	return doRecursiveFib(n, 1, 0)
// }


// fn cond() -> bool
// {
// 	printf("T")
// 	return true
// }

namespace ns
{
	fn test()
	{
		printf("this is a test\n")
	}

	namespace ns2
	{
		fn test2()
		{
			printf("testing 2\n")
		}
	}
}


@entry fn main(argc: i32, argv: i8**) -> int
{
	fn inner()
	{
		printf("inner\n")
	}

	struct foo
	{
		var k: int
		var j: double

		var s: string
	}

	fn somefn() -> foo
	{
		var a: foo
		a.k = 30
		a.s = "rick" + "astley"

		return a
	}

	// fn getstr() -> string { return "A" + "B" }

	let f = somefn()
	printf("f.k = %d, f.s = %s\n", f.k, f.s)

	// var s = getstr()

	// printf("a.k = %d / a.j = %.2f\n", a.k, a.j)

	// var tup = (s, 30, 40)
	// printf("tup = (%s, %d, %d)\n", tup.0, tup.1, tup.2)

	// inner()



	// let str = "hello" + "world"
	// let str1 = str + " number 10"

	// printf("---\n")
	// var str2: string
	// str2 = str1

	// let x = foo()(7)
	// printf("x = %d\n", x)

	// // printf("str = %s\n", str1)

	// let arr = [ 1, 2 ] + [ 3, 4 ]

	// let eq = ("hello" == "hello")
	// printf("eq = %d\n", eq)

	// var counter = 0
	// while counter < 30
	// {
	// 	counter += 1
	// 	printf("%d - ", counter)

	// 	// var str = "foo" + "bar"

	// 	if counter > 20
	// 	{
	// 		break
	// 	}
	// 	else
	// 	{
	// 		continue
	// 	}

	// 	printf("no\n")
	// }
	// printf("\n\n")

	// ns.test1()
	ns.ns2.test2()

	// let k: (string, string, string) = (1, 2, 3)

	// printf("str = %s\n", str)

	// printf("fib(20) = %d\n", doRecursiveFib(20))

	// var bar = -(401 + 76.1) as f64
	// var qux = 30

	// var fun: (int, int) -> void = foo

	// fun(30, 30)

	// printf("bar = %.1f, &bar = %p, qux = %d\n", bar, &bar, *&qux)
	// printf(@r"%s, %d, not-bar = %f\n", @r"Hello, World", -34, 1.1 - 4.5)
	// printf("end\n")

	// foo(10)
	// foo(10, 20)


	// var one = 40
	// let op = &one

	// var arr = [ 1, 2, 3, 4 ]
	// arr[0] = 3

	// printf("arr[0] = %d\n", arr[0])


	// if(var k = 2; bar1() || bar2())
	// {
	// 	printf("k < 3\n")

	// 	if(10 > 30)
	// 	{
	// 		printf("TRUE\n")
	// 	}
	// 	else
	// 	{
	// 		printf("FALSE\n")
	// 	}
	// }
	// else if(var m = 40; m > 1)
	// {
	// 	printf("m > 1\n");
	// }
	// else
	// {
	// 	printf("else: k = %d, m = %d\n", k, m)
	// }

	printf("quit\n")

	return 0
}



// fn bar1() -> bool
// {
// 	printf("BAR ONE\n")
// 	return true
// }

// fn bar2() -> bool
// {
// 	printf("BAR TWO\n")

// 	if true { }
// 	else if false { }

// 	return false
// }








