// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

export supertiny

import "libc" as _
import "stdio" as _

// var glob: any
// fn test_refcounting_problem_thing()
// {
// 	fn foo(x: any)
// 	{
// 		if(x is int)
// 		{
// 			glob = x
// 		}
// 	}

// 	foo(30)
// }


@entry fn main()
{
	// some normal FP stuff
	fn map<T, U>(arr: [T:], fun: fn(T) -> U) -> [U]
	{
		var ret: [U]
		for it in arr => ret.append(fun(it))

		return ret
	}

	do {
		printf("set 1:")

		fn twice<K>(a: K) -> K => a * 2

		let new = map(fun: twice, arr: [ 1, 2, 3, 4, 5 ])
		for it in new { printf(" %d", it) }

		printf("\n")
	}



	/* do {
		union option<T>
		{
			some: T
			none
		}

		let x = option<T: str>.some("123")
		let y = option<T: int>.some(456)

		printf("x = %s, y = %d\n", x as option<T: str>.some, y as option<T: int>.some)

		if let z = 30; z > 50
		{
			println("z > 50")
		}
		else
		{
			println("z is %", z)
		}
	} */

	/*
	do {
		// class Foo<T>
		// {
		// 	init() { }
		// 	static fn bar(x: T) { printf("x = %d\n", x) }
		// }

		// Foo.bar(30)
	}
	*/


	// do {
	// 	struct outer
	// 	{
	// 		class inner
	// 		{
	// 			var x: int

	// 			init(a: int, b: int)
	// 			{
	// 				x = a * b
	// 			}
	// 		}
	// 	}

	// 	let foo = outer.inner(a: 30, b: 40)
	// 	println("foo.x = %", foo.x)
	// }
}


/*
	! slightly more updated notes
	! caa 23/09
	{
		possible things:

		1. change the generic type engine to operate on pairs of fir::Types, instead of pts::Types {
			We'd basically need to pre-resolve the pts::Types before going into the inference thingy, which might be
			a bit challenging, maybe.

			the pre-entry to the engine could simply match the pts::Types against the 'problemset' of the generic function,
			and create appropriate fir::PlaceholderTypes based on that information. Should be viable, but i'm not sure.

			Everything else should work the same, and possibly be a bit cleaner since we don't need to be confused between pts and fir??
		}

		2. after that, change function call resolution to use the generic inference solver as well {
			since this would operate on resolved functions, we can omit calling the 'pre-entry' mentioned above (for generic functions)
			and just match fir::Types between the argument types and the parameter types.

			then, we'd have to integrate the existing system of 'scores', and return that information as well from the solver.
		}

		3. finally, solve the original problem that we set out to solve {
			the original problem is that we have PlaceholderTypes as parameter types for static functions, but the solver was unable to pick
			up on that (and we don't really want it to)

			after re-writing the interfaces, we can potentially omit the entire 'problemspace' thing. We already (i believe) have a method on
			FIR types 'containsPlaceholders'. So we should be able to check for the presence of placeholders and use that to trigger the
			recursive solver (for passing functions and such), rather than relying on a problemset.


		}

		4. pretty sure we never actually implemented the iterative solver -- we should probably do that.
	}



	! NOTES FOR IMPLEMENTATION
	! from like 09/08
	{
		so currently we have an issue where we need to re-typecheck a given function definition (from AST->SST again). the current
		architecture that we have in place to infer generic types is inadequate to allow omitting type arguments for nested things, eg. in
		unions and static functions of generic types.

		the proposed architecture we are in the midst of implementing fills the LHS of function-call dotops with placeholder types if it is
		a generic type and we do not have the solution. the next step is to substitute those placeholder types when we actually typecheck
		the function call, using the types of its parameters as inputs to the generic solver.

		one of the restrictions that we have is that we need to perform the inference for every candidate, because we can't be performing
		overload resolution with placeholder types.

		a couple of issues arise: {
			1. dirty-ish hack where we don't actually have the sst::Expr of the argument to pass to the solver, so we put in a null-check that
				feels really out-of-place

			2. related issue, we previously re-architected all of the generic solver functions to take FnCallArguments instead of Params, because
				of the thing where we wanted to re-typecheck function call arguments -- to enable passing generic functions to generic functions.
				works well for that use case, but complicates this one, because we don't have the expressions.

				right now we're just creating sst::TypeExprs, but that doesn't hide the fact that we don't actually have the information anywhere
				(unless we pass more things around)

				the reason we're sticking with Params for the overload resolver is that sometimes
					(a) we're checking for duplicates, so naturally we only have the types and not expressions
					(b) we need to insert fake arguments (for method calls) and we don't have an expression there as well

				we can solve this problem with some careful refactoring, ie. pulling out the actual resolver code and making sure it
				only takes types, then having different interfaces to the main code. however, i'd rather not do that unless
				absolutely necessary, as we already have more than a glut of various functions that only serve to wrap other functions
				after a light transformation of the input arguments

			3. then, we have the actual solving issue -- because the static function that we're trying to call is not *itself* generic,
				the solver will think that it has no generic parameters to solve. The problem is that the 'problemSpace' as we call it
				is encoded in the placeholder types contained in the function type itself. Even worse, the static function might not even take
				any arguments, in which case we have 0 information (but in such cases we can just error)

				so this either calls for
					(a) a re-architecting of the function call resolution system
					(b) passing more information around, ie. the generic type that has the static function, so we can retrieve the problem space

				the problem with (a) is that i have no idea what the target architecture will even be, so i have no idea what direction this should
				even go in.

				the problem with (b) is that this will just snowball into us passing more and more specific pieces of information for very specific
				usecases that just end up making the code messy and unmaintainable.
		}

		the entire thing above hasn't even considered the other main scenario of this placeholder thing, which is constructing union types without
		explicitly stating the generic types -- ie. option.some(T) instead of option<T>.some(T)

		even if we fix the issues we face with static functions above, i'm not sure that those fixes will exactly transfer to the union problem, or
		whether we'd have to write even more special case code for it.

		the objective of the rewrite was to re-architect the compiler so that we would minimise the amount of special-case code that we originally
		had to handle generics. it would defeat the purpose to put more of that crap in at this stage.

		the ideal scenario is that through the inevitable refactoring that the above problems will lead to, we might be able to make the architecture
		of the solver/placeholder system both (a) more robust and (b) more general.
	}



	TODO for the immediate time frame (that keeps getting longer and where the real work always gets postponed)

	7. move long error messages on spans nearer to the left margin when there's only one span in the error.
	9. fix errors (in general?) {
		a. the generic solver should basically return only a Span, ie. a location with text.
		b. maybe find some way to 'link' two spans together with one message.
		c. figure out if/how we should split up errors when there are too many spans in one context.
			- do we duplicate the context?
			- if not then???
	}
	12. allow generic solver to infer things from generic types passed in {
		eg: fn foobar<A, B>(a: Qux<T: A>, b: Qux<T: B>) => ...
		foobar(Qux<T: i64>(), Qux<T: str>()) should infer that A = i64 and B = str.
	}
	15. builtin way to get a character literal {
		even just enforcing that we get either a string literal of exactly length 1, or an i8 type, at compile-time.
		sure, we could just abort when passed a slice != length 1, but then why bother being statically typed??
	}
	// 17. refcounted moving is broken -- not sure if design flaw or not. investigate.
	18. generic unions {
		currently they work okay, but it's very troublesome to unwrap, construct or declare them, because you need to
		explicitly state the type of the union.

		given that we just managed to do the thing where we can infer generic types from constructor arguments, we should be
		able to do a similar thing for this case.

		the problem here is that we need to be able to turn `Option<T: int>.Some(...)` into `Option.Some(...)`, but when we
		just access `Option` directly without type arguments, we will get yelled at by the typechecker.

		the alternative to this problem is just to disallow inference when doing it like this. then, inference is only enabled
		when we `use` the union:

		```
		using Option

		let x = Some(30)
		let y = None
		```

		on this hand, we will also need to somehow allow `using` a generic union without specifying its type... bah.
	}
	19. using for unions (see 18 for some issues re: generic types)
*/










// fn overloadErrorTest()
// {
// 	fn printThings(mul: f64, flts: [f64: ...])
// 	{
// 		printf("floats: ");
// 		for i in flts { printf("%.1f ", mul * i) }

// 		printf("\n")
// 	}

// 	fn printThings(mul: str, flts: [f64: ...])
// 	{
// 		printf("floats: ");
// 		for i in flts { printf("%s: %.1f ", mul.ptr, i) }

// 		printf("\n")
// 	}

// 	fn printThings()
// 	{
// 		printf("print things 3\n")
// 	}


// 	do {
// 		printThings(30, ...[ 1, 2, 3, 4, 5 ])
// 		printThings(0.813, 1, 2, 4.41, 39, 491.3, 381.7)
// 	}
// }
