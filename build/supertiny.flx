// supertiny.flx
// Copyright (c) 2014 - 2017, zhiayang
// Licensed under the Apache License Version 2.0.

export supertiny

import libc as _

// import std::io
// import std::map
import std::opt

@raw union ipv4
{
	_: struct {
		_: @raw union {
			bytes2: [u8: 4]
			raw3: u32
		}
	}

	_: struct {
		bytes: [u8: 4]
	}

	_: struct {
		raw2: u32
	}

	raw: u32
}


struct foo
{
	x: int
	y: str
}

@entry fn main()
{
	// do {
	// 	var addr: ipv4
	// 	addr.raw3 = 0xff01a8c0;

	// 	printf("%d.%d.%d.%d\n", addr.bytes[0], addr.bytes[1], addr.bytes[2], addr.bytes[3]);
	// }

	// do {
	// 	var x: int
	// 	var y: int

	// 	(x, y) = (30, 40)
	// 	(x, y) = (y, x)

	// 	printf("%d, %d\n", x, y)
	// }

	do {
		let k = foo(y: "20", x: 31)
		let m = true
	}


	/* do {
		var x: @raw union {
			bar: f64
			foo: i64
		}

		x.bar = 3.14159

		printf("x = %.2lf\n", x.bar)
		printf("x = %d\n", x.foo)
	} */
}


/*

import std::opt
import std::    map

	var map: std::map!<int, str>
	map.insert(3, "foo")

	let r = map.search(3)

	libc::printf("map[3] = %s\n", map.search(3) as std::opt::some)

	let res = map.remove(3)
	libc::printf("map[3]: res = %d, is_none = %d\n", res, map.search(3) is std::opt::none)

*/



/*
	! bugs !
	{
		1. we should not be able to pass a mapping to the variant of a union, that's a bit weird.
			eg: std::opt::some!<str> works, which is a little strange.
			edit: it only works in certain circumstances??? also if we use a constructor (like this: std::opt::some!<int>(10)), the thing
			get treated like a function call (and so finds no functions!)

		2. splatting tuples into a generic function *will not work*
		3. pass the overall location to the polymorph solver.
	}


	TODO for the immediate time frame (that keeps getting longer and where the real work always gets postponed)

	7. move long error messages on spans nearer to the left margin when there's only one span in the error.
	9. fix errors (in general?) {
		a. the generic solver should basically return only a Span, ie. a location with text.
		b. maybe find some way to 'link' two spans together with one message.
		c. figure out if/how we should split up errors when there are too many spans in one context.
			- do we duplicate the context?
			- if not then???
	}

	16. operator overload errors {
		something like this:

		failed to resolve candidate for 'operator == (type_1, type_2)'
		callsite was here: 'foo == bar'
		potential candidates: 'operator == (type_1, type_3)'

		ofc potential candidates should be limited to ones where at least one of the types
		are similar.
	}

	17. better errors for ref-counting legality {
		when throwing an error due to having a ref-counted type in unsupported places (like in a raw-union), we
		should let the compiler show which member made the struct refcounted (because having a RC field in a struct
		makes that struct RC), since the 'root cause' could be nested very deep in the type hierarchy somewhere.

		eg.
		error: reference-counted type 'foo' cannot be a member of a raw-union:
		 39 |    bar: foo

		note:  'foo' inherits reference-counting from indirectly containing a field with a reference-counted type:
		 303 |   blabla: string

		note:  this is the type hierarchy leading from 'foo' leading to the type in question:
		       (foo <- qux <- some_type_t <- ... <- some_struct <- string)


		of course it would be nice if we can selectively print more context and omit stuff in the middle, like this:

		10  |    struct some_struct {
		... |       ...
		391 |       blabla: string
		    |

		something like that. detecting indentation would be a little tricky if we want to correctly indent the
		'...' that would appear in the struct body.

		actually having a proper API to set up this kind of error message would be a tough one as well...
	}

	18. figure out how constructors should work with transparent fields {

		i don't really feel like testing it out now, but more than likely it will not work properly, or at all.

		the ideal case is to enforce named arguments if the type has transparency, since we also enforce that you can't have
		fields with the same name that are accessible at the same "level".

		that should be fine I guess, but we have to make provisions for initialising all the intermediate structs/unions
		etc.

		also there's currently a massive bug with struct constructors. how nice.
	}
*/












