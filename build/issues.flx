// issues.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.


// NOTE: this file *SHOULD NOT* be compiled, at least until all the 'TOFIX'es have been moved to the
// 'FIXED' section.


// note: this issues system is some kind of shitty queue
// queue numbers are recycled, but issues are not moved forward in the queue (ie. their numbers are not decremented)
// more urgent issues are placed in front to reuse lower queue numbers

// ^ why am i documenting this?



//
// TOFIX:
//

// 1. UNFUCK LITERAL VALUES
// JESUS CHRIST THEY SUCK HORSE COCK RIGHT ABOUT NOW







// 8. abort(), exit(), etc. should be allowed as the last expression in a function
// 	and allow the compiler to just ignore the fact that there's no return value
// 	ie. __attribute__((noreturn))
func foo() -> int { abort() }




// 10. honestly the whole thing is fucked up. a rewrite of everything is impossible, however.
// 	the type inference needs to be smarter -- generalising and re-purposing the existing generic type solver
// 	for this might turn out to be a good idea in the future.




// 11. also the fucking generic type solver isn't finished god dammit




// 14. class instance method access should capture the instance
// the call to fn() should not require explicit passing of the instance, but rather it should refer to the 'f' instance.
// Foo.method would continue to work, but would require an instance.
class Foo { func method() { /* ... */ } }
Foo f;
let fn = f.method;
fn();




// 15. wasn't there supposed to be automatic operator == for structs????? WTF
struct Bar { /* ... */ }
Bar x;
Bar y;
let cond = (x == y)




// 16. special handling in parser for "." as a unary operator or something, so numbers like
// 	".51" work
let x = .31




// 17. a function with multiple overloads should be able to be passed as a parameter to another function, since we know the types.
// 	applies to generic functions as well, both in the parameter type and the function being passed.




// 18. modify the iterative generic solver to be able to solve for variadic functions as well
// right now, we redirect to the naive solver for variadic functions, which limits possibilities.







//
// FIXED
//
/*
	(fixed in e664992)
	- enums declared in functions do not work
	- global variables outside of namespaces don't work

	(fixed in bb6baf0)
	- handle refcounts when doing slices

	(added in e7c50a0)
	- dynamic array slices

	(fixed in 42b1aaf)
	- assign [] to dynamic arrays
	- pass [] to functions taking dynamic arrays

	(fixed in 9334be3)
	- do { } while { } parsing bug

	(fixed in dc63839)
	- T.0.1 parses as T. (0.1) where 0.1 is a number

	(fixed in d9f8d4b)
	- defer does not happen after the return, only before

	(fixed in 61325cd)
	- shit like this works "let g = 3let v = 10"

	(fixed in 6d31d14)
	- remove implicit returns, unless the function has exactly one *statement*.

	(added in b56ef9c)
	- init+cond in if statements, a-la c++17

	(added in 63ba763)
	- for loops, ranges, for-in loops

	(fixed in 586c963)
	- empty array literals are now generic things (WIP)
	- iterative generic solver is now used for everything


*/


//
// TO TEST
//
/*
	1. tuple operators
	2. array of strings
*/


//
// TODO
//
/*
	3. splatting (http://coffeescript.org/#splats)

	4. clean up typechecking
		-- store the fir::Type of each AST node
		-- recursively visit each node to get its type before anything happens

	5. arbitrary refcounted types (ie. rc<T>)
		recent work with 'any' has demonstrated that it's *somewhat trivial* to add a new refcounted type to the type system. The real
		challenge is not in making it refcounted, it's simply in integrating it with the rest of the type system (in terms of operator
		results, compares, special-cases, etc.)
*/






