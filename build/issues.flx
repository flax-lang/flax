// issues.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

/*
 * This file isn't meant to be compiled.
 * It's just a list of outstanding issues in the compiler that we've yet to get to.

 ? Note that some issues existed pre-rewrite, so they may not make sense. The 'fixed' log has not been
 ? updated to reflect problems that were fixed in the process of the rewrite, for obvious reasons.
*/

/*
	! FEATURES TO IMPLEMENT

	1. Constructor syntax for types


	2. Using namepace


	5. String operators


	7. Defer


	9. For loops


	10. Decomposition
		Include nested decomposition, eg. array of tuples and tuple of arrays. (maybe just the former and not the latter??)
		eg. let [(a, b), (c, d), ...] = array				# type = (int, int)[]
		or: let ([a, b, c, ...], [x, y, z, ...]) = tuple	# type = (int[], int[])


	11. Splatting single value into decomposition declaration
		eg. let (a, b) = ...10   <-- a == b == 10


	12. Operator overloading


	13. Generic functions & types


	14. Multi-dimensional arrays, as opposed to our current 'array-of-arrays' approach
		eg. index with 'foo[a, b, c]' instead of 'foo[a][b][c]'


	16. [[noreturn]] for functions, so we don't error when no value is returned (eg. when calling abort())

*/



/*
	? THINGS TO INVESTIGATE

	1. Should slices be a 'weak' reference to the elements?
		ie. should making a slice of a dynamic array increase the refcount of the elements of the dynamic array?
		Right now, we don't increment the reference count -- ie. we've implemented weak slices.

		Do we want strong slices?


	2. Foreach loops where you specify the skip, allows for things like these:
		for [ first, middle, last, ... ] in (list) step 3 { ... }


	3. Variadic functions should take a slice of any.
*/





/*
	* FIXED ISSUES

	(f3f8dbb)
	- add ranges
	- add foreach loops on ranges, arrays, and strings
	- add '=>' syntax for single-statement blocks, eg. "if x == 0 => x += 4"

	(dacc809)
	- fix lexing/parsing of negative numerical literals

	(ca3ae4b)
	- better type inference/support for empty array literals
	- implicit conversion from pointers to booleans for null checking

	(5be4db1)
	- fix runtime glue code for arrays wrt. reference counting

	(e3a2b55)
	- add alloc and dealloc
	- add dynamic array operators (pop(), back())

	(b7c6f74)
	- add enums

	(408260c4)
	- add classes
*/


/*
	! TODO

	3. splatting (http://coffeescript.org/#splats)

	5. arbitrary refcounted types (ie. rc<T>)
		recent work with 'any' has demonstrated that it's *somewhat trivial* to add a new refcounted type to the type system. The real
		challenge is not in making it refcounted, it's simply in integrating it with the rest of the type system (in terms of operator
		results, compares, special-cases, etc.)
*/






