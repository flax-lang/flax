// issues.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

/*
 * This file isn't meant to be compiled.
 * It's just a list of outstanding issues in the compiler that we've yet to get to.

 ? Note that some issues existed pre-rewrite, so they may not make sense. The 'fixed' log has not been
 ? updated to reflect problems that were fixed in the process of the rewrite, for obvious reasons.
*/

/*
	! FEATURES TO IMPLEMENT

	1. Constructor syntax for types


	2. Using namepace


	3. Named parameter calling, and optional arguments.


	5. String operators


	10. Decomposition
		Include nested decomposition, eg. array of tuples and tuple of arrays. (maybe just the former and not the latter??)
		eg. let [(a, b), (c, d), ...] = array				# type = (int, int)[]
		or: let ([a, b, c, ...], [x, y, z, ...]) = tuple	# type = (int[], int[])


	11. Splatting single value into decomposition declaration
		eg. let (a, b) = ...10   <-- a == b == 10


	13. Generic functions & types


	14. Multi-dimensional arrays, as opposed to our current 'array-of-arrays' approach
		eg. index with 'foo[a, b, c]' instead of 'foo[a][b][c]'


	16. [[noreturn]] for functions, so we don't error when no value is returned (eg. when calling abort())

*/


/*
	! THINGS TO FIX

	1. Importing the same module under multiple names should not be allowed.
		Right now it fails and produces unexpected behaviour -- I think only the first import is considered,
		but no errors are thrown.
*/



/*
	? THINGS TO INVESTIGATE

	1. Should slices be a 'weak' reference to the elements?
		ie. should making a slice of a dynamic array increase the refcount of the elements of the dynamic array?
		Right now, we don't increment the reference count -- ie. we've implemented weak slices.

		Do we want strong slices?


	2. Foreach loops where you take more than one thing at a time, like this, maybe:
		for [ first, middle, last, ... ] in list { ... }


	3. Variadic functions should take a slice of any.


	4. Type inference for single-expr functions? It's a little weird to have two arrows like this:
		fn foo(a: T) -> T => a * a

		The type inference would require some re-working though, because to generate the declaration of the function we need the return type, but to
		get the return type in this situation we need to typecheck the function body. Albeit it's a single function, there might still be
		unresolved or unresolvable things inside the body.

		Possibly investigate whether we can do the typechecking in the generateDecl function?? But it's highly likely we separated those for a reason,
		so I don't think it's doable at this point.

		It's not really a high-priority thing anyway.


	5. wrt. named parameters:

		there are two cases of named parameters being used; first in a type constructor, and second in a regular function call.

		When calling a type constructor of a struct, all arguments are optional, ie. you can specify all, some or none of the fields
		as named arguments in your constructor call. Those not provided will be given the default value for their type, or, if the
		struct definition itself has initialisers at the field declaration site, that particular init value.

		On the other hand, the constructor for a class acts like a normal function, in that only defined 'init' functions can be called,
		and they can only be called with their corresponding arguments.

		For these regular function calls, named parameters are must come after any positional arguments, and positional arguments cannot come after
		named arguments. Thus, once you start naming arguments in a call, you must name all subsequent arguments.

		Note that functions cannot be overloaded solely on the names of the arguments, just the types.

		Finally, for optional arguments, it behaves much the same, except that you *must* refer to it by name to specify a value. For example:

		fn foo(a: int, b: int = 3) => ...

		* valid combinations:
		foo(30)
		foo(a: 30)
		foo(30, b: 5)
		foo(a: 30, b: 1)

		* invalid combinations:
		foo(a: 30, 1)		<-- cannot have positional arguments after named ones
		foo(30, 7)			<-- must name the optional argument 'b'


		Yep, that's about it for named args. I don't plan on supporting the whole 'internal/external name' thing that Swift has going on.
		It's probably just an objective-c fetishism thing, and muddles up function declarations. If you want the internal name to be different,
		just create a new variable, it's not going to kill the program.


	6. wrt tuples: https://www.reddit.com/r/ProgrammingLanguages/comments/7o5fs0/languages_with_better_tuple_support/

		definitely some interesting ideas over there. Would streamline things by making functions take a tuple as an argument, although it means
		we need to slightly tweak overload resolution and overload distance computation, but since they're just operating on a list of types
		anyway, it should be simple (famous last words right) to do.

		One thing is that we don't have named tuples, so there's no correlation between calling a function with named arguments and tuples. However,
		passing a struct straight to a function that takes named arguments (that correspond to the fields of the struct) feels wrong and obscene.

		What we can do instead is the reverse; if a function takes a struct, allow ad-hoc construction of the struct simply by calling it with
		named arguments. However, this is one of the things that complicates function resolution for very little benefit; assuming we implement
		constructor syntax for structs, plus named arguments in constructors, then this entire thing is rendered basically moot, because you
		can just type a few more characters of the struct name and avoid a lot of implementation headaches.

		So basically, the only thing we're taking away from that guy's post is having functions take tuples as arguments? Again, we don't have
		named tuples so a lot of the 'hype' of his post is pointless and misdirected for our use case.

		In which case the question comes -- do we want named tuples? What advantages do they serve over structs? On a surface level, they're just
		structs, but (1) without methods, (2) without requiring a type definition, and thus (3) more ad-hoc.

		They can be useful, but I feel that wherever you're using named tuples a lot, you'd be better served by a struct. I guess?

		Do an RFC on the IRC channel I guess.
*/





/*
	* FIXED / IMPLEMENTED THINGS

	(ec7b2f3)
	- fix false assertion (assert index > 0) for InsertValue by index in FIR. Index can obviously be 0 for the first element.

	(3add15b)
	- fix implicit casting arguments to overloaded operators
	- add ability to overload unicode symbols as operators

	(d2f8dbd)
	- add ability to overload prefix operators
	- internally, move Operator to be a string type to make our lives easier with overloading.

	(dcc28ba)
	- fix member access on structs that were passed as arguments (ie. 'did not have pointer' -- solved by using ExtractValue in such cases)
	- fix method calling (same thing as above) -- but this time we need to use ImmutAlloc, because we need a 'this' pointer
	- add basic operator overloading for binary, non-assigment operators.

	(45e818e)
	- check for, and error on, duplicate module imports.

	(5a9aa9e)
	- add deferred statements and blocks

	(80a6619)
	- add single-expression functions with `fn foo(a: T) -> T => a * 2`

	(3b438c2)
	- add support for reverse ranges (negative steps, start > end)

	(f3f8dbb)
	- add ranges
	- add foreach loops on ranges, arrays, and strings
	- add '=>' syntax for single-statement blocks, eg. "if x == 0 => x += 4"

	(dacc809)
	- fix lexing/parsing of negative numerical literals

	(ca3ae4b)
	- better type inference/support for empty array literals
	- implicit conversion from pointers to booleans for null checking

	(5be4db1)
	- fix runtime glue code for arrays wrt. reference counting

	(e3a2b55)
	- add alloc and dealloc
	- add dynamic array operators (pop(), back())

	(b7c6f74)
	- add enums

	(408260c4)
	- add classes
*/


/*
	! TODO

	3. splatting (http://coffeescript.org/#splats)

	5. arbitrary refcounted types (ie. rc<T>)
		recent work with 'any' has demonstrated that it's *somewhat trivial* to add a new refcounted type to the type system. The real
		challenge is not in making it refcounted, it's simply in integrating it with the rest of the type system (in terms of operator
		results, compares, special-cases, etc.)
*/






