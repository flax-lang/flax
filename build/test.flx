// test.flx
// Copyright (c) 2014 - The Foreseeable Future, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Math
import String


public func main() -> Int
{
	var foo: String

	printf("HELLO\n")

	let g: Int8 = 100
	printf("g is: %d\n", g)

	let m: (Math.Vector3, Math.Vector3) = (fa(), fb())
	printf("m is [(%f, %f, %f), (%f, %f, %f)]\n", m.0.x, m.0.y, m.0.z, m.1.x, m.1.y, m.1.z)


	let dot: Double = m.0 • m.1
	printf("dot = %f\n", dot);


	let v1: Math.Vector3(1.0, 2.0, 4.0)
	let v2: Math.Vector3(3.0, 6.0, 9.0)

	var v = v1 + v2
	printf("v: (%f, %f, %f)\n", v.x, v.y, v.z)
	v += v1
	printf("v: (%f, %f, %f)\n", v.x, v.y, v.z)

	var cross: Math.Vector3 = m.0 x m.1
	cross = cross / 10
	printf("cross = (%f, %f, %f)\n", cross.x, cross.y, cross.z)



	return 0
}


class Bar
{
	init()
	{
		printf("DID BAR\n");
		var foo: some.Qux
	}

	// var foo: Foo
	var qux: some.Qux
}

namespace some
{
	class Qux
	{
	}
}

func fa() -> Math.Vector3
{
	var ret: Math.Vector3
	ret.x = 5
	ret.y = 25
	ret.z = 125

	return ret
}

func fb() -> Math.Vector3
{
	var ret: Math.Vector3
	ret.x = 3
	ret.y = 9
	ret.z = 27

	return ret
}


class Foo
{
}


// one clear order-dependency is members in structs. need to find a way to create the type, from the Class* or Struct*,
// by only having the name. Note that, at this point,
//
// there's 0 way to refer to it, since it hasn't been touched. perhaps one of the initial passes in TopLevel
// would add the AST node to the functree, but not generate or touch it yet.
// dependency resolver would have to trawl the functree (starting from current one down) to find the type.
// NOTE: would need to note scopes/namespaces/nested types.
// NOTE: the way shit is, it's gonna be hell when we implement using/namespace importing...
//
// if we do it this way, should we createType() and codegen() at the same time?






// import tests.fizzbuzz
// import tests.recursiveFib
// import tests.scopes
// import tests.arraytest
// import tests.generics

// import Utilities

// ƒ runTests()
// {
// 	// fib
// 	printf("*** FIBONACII SEQUENCE ***\n")

// 	var n = 0
// 	while n < 20
// 	{
// 		printf("%d: %lld\n", n, doRecursiveFib(n))
// 		n += 1
// 	}
// 	printf("\n\n");


// 	// fizzbuzz
// 	printf("*** FIZZBUZZ ***\n")
// 	doFizzBuzz(20);
// 	printf("\n\n");


// 	// scopes
// 	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
// 	doScopeTest("__llvm_jit__build/test")
// 	printf("\n\n");


// 	// arrays
// 	printf("*** ARRAY REGRESSION TEST ***\n")
// 	doArrayTest()
// 	printf("\n\n")


// 	printf("*** GENERICS TEST ***\n")
// 	doGenericsTest()
// 	printf("\n\n")
// }



// class Foo
// {
// 	var v3: Math.Vector3
// 	{
// 		get {
// 			var ret: Math.Vector3

// 			ret.x = 1
// 			ret.y = 4
// 			ret.z = 9

// 			return ret
// 		}
// 		set {
// 			printf("set v3\n")
// 		}
// 	}




// 	var _bar: Int = 537
// 	var bar: Int
// 	{
// 		get {
// 			return self._bar
// 		}
// 		set {
// 			self._bar = newValue
// 		}
// 	}

// 	ƒ doBar() -> Int
// 	{
// 		printf("in foo\n")

// 		return self._bar
// 	}
// }

// class Bar : Foo
// {
// 	override var bar: Int
// 	{
// 		get {
// 			return 73
// 		}
// 		set {
// 			// super.bar = newValue
// 		}
// 	}

// 	override var v3: Math.Vector3
// 	{
// 		get {
// 			var ret: Math.Vector3


// 			// ret.x = super.v3.x + 3
// 			// ret.y = super.v3.y + 5
// 			// ret.z = super.v3.z + 7

// 			ret.x = 33.1

// 			return ret
// 		}
// 		set {
// 			let m = 0
// 		}
// 	}









// 	override ƒ doBar()
// 	{
// 		printf("in bar: %f\n", self.v3.x)
// 	}

// 	var foo = 73
// }

// class FooBar : Bar
// {
// 	override ƒ doBar()
// 	{
// 		printf("in foobar\n")
// 	}
// }








// func main(argc: Int32, argv: Int8**) -> Int
// {
// 	runTests()
// 	printf("========= TESTS COMPLETE =========\n\n")


// 	var k: Int


// 	let bar: Bar()
// 	let foo: Foo()
// 	printf("bar.bar = %d\n", bar._bar)
// 	printf("foo.bar = %d\n", foo.bar)


// 	bar.doBar()
// 	foo.doBar()

// 	let fb: FooBar()
// 	fb.doBar()
// 	printf("%d\n", fb._bar)

// 	printf("pi = %f\n", Math.π())

// 	var vec: Math.Vector2
// 	vec.x = 3
// 	vec.y = 2

// 	var vec2: Math.Vector2
// 	vec2.x = 1
// 	vec2.y = 7



// 	let m = vec + vec2
// 	printf("m = (%f, %f)\n", m.x, m.y)


// 	// let g = foo(30, 1)

// 	// var dream = Math.Complex.Cmplx()
// 	// dream.r = 40
// 	// dream.i = 1.412

// 	// printf("bar.vector3 = (%f, %f, %f), dream = (%f, %f)\n", bar.v3.x, bar.v3.y, bar.v3.z, dream.r, dream.i)







// 	// structs vs classes:
// 	//
// 	// structs will be pure data. POD types and other structs only. nothing else.
// 	// classes will be everything else.
// 	//
// 	// that's it. simple shit.

// 	// todo: look into these.

// 	// >>> universal function call syntax -- use dot-operator calling on everything.
// 	// 	1. when you try to call a.b(c, ...), the usual "finding things in c" takes place
// 	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
// 	// 	3. search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

// 	// >>> multiple, dynamic dispatch











// 	return 0
// }















