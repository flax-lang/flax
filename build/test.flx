// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

/*
import Foundation
import Utilities
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics
import tests.limits
import tests.misc

import tests.functions


ƒ runTests()
{
	// fib
	let fibTitle		= "       *** FIBONACII SEQUENCE ***       \n"
	let fizzbuzzTitle	= "            *** FIZZBUZZ ***            \n"
	let intLimitsTitle	= "       *** PRINTING INT LIMITS ***      \n"
	let scopeTitle		= "*** SCOPE RESOLUTION REGRESSION TEST ***\n"
	let operatorTitle	= " *** OPERATOR/TUPLE REGRESSION TEST *** \n"
	let arrayTitle		= "      *** ARRAY REGRESSION TEST ***     \n"
	let genericsTitle	= "    *** GENERICS REGRESSION TEST ***    \n"
	let functionsTitle	= "    *** FUNCTION REGRESSION TEST ***    \n"
	let miscTitle		= "       *** MISCELLANEOUS TESTS ***      \n"
	let thinLine		= "----------------------------------------\n"
	let endTitle		= "============ TESTS COMPLETE ============\n"




	printf("%s%s", fibTitle, thinLine)
	do {
		var n = 1
		while n < 20
		{
			printf("%lld", doRecursiveFib(n))
			n += 1

			if n != 20
			{
				printf(", ")
			}
		}
		printf("\n\n\n")
	}


	// fizzbuzz
	printf("%s%s", fizzbuzzTitle, thinLine)
	doFizzBuzz(15)
	printf("\n\n\n")


	// int limits
	printf("%s%s", intLimitsTitle, thinLine)
	printIntegerLimits()
	printf("\n\n\n")


	// scopes
	printf("%s%s", scopeTitle, thinLine)
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n\n")


	// operators and tuples (vectors type, mainly)
	printf("%s%s", operatorTitle, thinLine)
	doOperatorTupleTest()
	printf("\n\n\n")


	// arrays
	printf("%s%s", arrayTitle, thinLine)
	doArrayTest()
	printf("\n\n\n")


	// generics
	printf("%s%s", genericsTitle, thinLine)
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n\n")


	// first-class-functions
	printf("%s%s", functionsTitle, thinLine)
	doFunctionTest()
	printf("\n\n\n")



	// misc tests
	printf("%s%s", miscTitle, thinLine)
	doFunctionTest()
	printf("\n\n\n")



	// fin.
	printf("%s\n\n\n\n\n", endTitle)
}





// name idea: mill


struct FormatOptions
{
	var paddingChar: Character
	var precision: int64
	var width: int64
	var paddingKind: int64			// 0 = left, 1 = centre, 2 = right
	var type: String
	var argNum: int64
}




func parseFormatOptions(str: String) -> FormatOptions
{
	let colon		= Character(":")
	let lbrace		= Character("{")
	let rbrace		= Character("}")

	let lettero		= Character("o")
	let letterx		= Character("x")
	let letterX		= Character("X")
	let letterp		= Character("p")
	let letterb		= Character("b")

	let larrow		= Character("<")
	let rarrow		= Character(">")
	let caret		= Character("^")

	let plus		= Character("+")
	let pound		= Character("#")
	let zero		= Character("0")
	let period		= Character(".")

	var ret: FormatOptions


	if str.length < 1 || str[0] != lbrace
	{
		programExit("wtf")
		return ret
	}

	// skip the first.

	let cc = str[1]

	if cc.isDigit()
	{
		var argnum: String
		var i = 1

		while i < str.length && str[i].isDigit()
		{
			argnum += str[i]
			i += 1
		}

		printf("string = %s", argnum)
	}



	println()

	return ret
}





public func main(argc: int32, argv: int8**) -> int
{
	runTests()


	do {
		println("Hello, {%}. This is world {%}, version {%, precision: 2}. {%}.", "World", 2, 3.71, "Goodbye")
		printf("pi = %.16lf, %s\n", Math.π(), "lol")

		println("%b", "a" != "b")

		parseFormatOptions("{401:x}")
	}






	// operator overloading notes:
	// top-level operators need to stay
	// method operators need to stay
	// protocols can dictate needing operators
	//
	// protocols first check the class and any extensions to see if the operator is defined
	// that's it...
	//
	// top level operators secretly create an extension on the type to the left, and make a method instead.
	// this way, protocol resolution can just check the extensions without having to bother with looking at
	// top-level functions.
	//
	// basically, top-level operators will just be syntactic sugar for extensions defining operators.


	// structs vs classes
	// structs:
	// methods. members. no intialisers.
	// extensions cannot have initialisers or stored properties
	// can conform to protocols.
	// vtable handling is done by having global vtable per type. for structs these are immutable.
	// looked up via type id.

	// classes:
	// everything. methods, members, properties, initialisers.
	// vtable is stored *in object*.
	// can be copied and modified at runtime for shits and giggles.




	// note: when we get protocol types working
	// eg. let x = String()
	// func foo(x: SomeProtocol) { ... }
	// foo(x)
	//
	// comparing fir::Type pointers isn't going to work any more.



	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "find a function named b in a" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 		-> search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	printf("\n<< done >>\n")
	return 0
}

*/















/*
	how to be stupid:
	associating reference count with the reference, instead of the object being referenced
	._.

	new string structure:

	struct string
	{
		i8* ptr
		i64 len
	}

	ptr actually points 8 bytes ahead of the allocated memory
	ie. ptr = malloc(len + 1) + 8
	the refcount is a 64-bit number stored at the beginning of the allocated memory

	THIS TIME, it is actually referring to the number of times the *DATA* is being referenced
	instead of some arbitrary number that means nothing

	to access it, we just cast ptr to an i64, then pointer arithmetically subtract 1.

	god i am so stupid

	string literals work like they currently do, i guess -- just store -1 in the 8 byte space.




	for arbitrary rc<T>, it's basically the same
	struct rc<T>
	{
		T* ptr
	}

	exactly the same; refcount is a 64-bit number stored 8 bytes before where ptr points
	to access it, same thing, cast ptr to an i64*, then subtract 1 with ptr arith.


	note: the things above will be done at the llvm level. for strings at least, we'll retain the FIR instructions for
	accessing data, len and refcount. At the llvm level, data and len will still be struct GEPs, but refcount will do some
	pointer magic. not a big deal


	for rc<T>, it's likely that it'll be a fir::Type, like fir::StringType, with an elementType. in which case, it should be similarly
	easy to set up the actual work at the llvm level. the type of refcount is always i64, so that shouldn't be a problem for the type
	system to handle.

	at the llvm level, rc<T> just gets converted to an appropriate struct type. the types are all concrete, so we can just do the
	same trick as with the strings.

	ezpz.

	this time, i'll stop doing stupid things.
*/



/*
	wtf:

	llvm has extractvalue and insertvalue instructions that can get member fields from non-pointer structs
	i feel cheated.
*/





/*
	stuff:


	foo() results in an rvalue
	in let x = foo(),

	x is assigned an rvalue
	as with x = y + "lol"

	it's clear that the refcount of the old value of x must be decremented
	for y + lol, we remove it from the refcounting list
	for foo(), if it returns some rc<T>, the refcount of T is increased




	foo() { return x }

	let y = foo()

	y holds a reference to x, rc(x)++
	so rc(x) == 2

	at the end of scope, y is gone, so rc(x)--
	x is leaked since refcount remains 1.



	for lvalue = rvalue, in essence the rvalue is moved to the lvalue
	so in theory the recount should not change at all

	let y = x + 10
	x + 10 gets removed from the refcount stack, and rc(y) == 1

	let y = foo()
	foo() gets removed from the refcount stack, and rc(y) == 1

	this works, i suppose, if funccall doesn't add the result to the list.


	what if foo() returns a global?

	if we have
	let x = foo()
	let y = foo()

	then the global gets referenced twice, but the refcount remains 1 (assuming no previous references)
	so it gets freed twice...


*/



















// import LibCInterface

ffi func printf(fmt: int8*, ...)

struct SomeStruct
{
	var str: string = "bar" + "foob"
}

class A
{
	init(a: int) { self.x = a }
	init() { }

	var x = 10

	operator = (other: A)
	{
		self.x = other.x
	}
}

struct B
{
	var x = 20
}

operator == (a: B, b: B) -> bool { return a.x == b.x }

public func main() -> int
{
	do {
		var a: A
		a = A()

		let b = A(3)
		a = b

		printf(@raw "%d\n", a.x)
	}

	do {
		var x = B()
		let y = B(40)

		x = y

		printf(@raw "%d, %d\n", x.x, x == y)
	}


	// let k: string = "hello"
	// var g: string = "world"

	// // k + g
	// g = k
	// printf(@raw "something\n");

	// printf(@raw "[%s], [%s]\n", k, g)
	// foo()

	var ss = SomeStruct()
	// ss.str = "lol"

	// ss.str = "kappa"

	printf(@raw "[%s]\n", ss.str)


	// bar()
	// qux()

	// bar()

	var k: string
	glob = k
	printf(@raw "k = [%s], glob = [%s]\n", k, glob)

	return 0
}

// func qux()
// {
// 	printf(@raw "cmp: [%d]\n", "foo" + "x" <= "foo" + "x")
// }


func bar()
{
	// let a = "ohmy"
	// let b = "gosh"

	// let x = a + b
	// printf(@raw "[%s]\n", x)

	bar1()
}

func wat() -> int
{
	return 10
}

var gs: string
var glob = "foo"

func takeS(a: string)
{
	printf(@raw "str: [%s]\n", a)
	gs = a
}

func retS() -> string
{
	let r = "goto" + "hell"
	printf(@raw "ret gs\n")
	// return gs
	return r
}

func bar1()
{
	let xxx = "str"
	printf(@raw "do xxx\n")
	var yyy = xxx + "onk"
	printf(@raw "do yyy\n")
	printf(@raw "[%s], [%s]\n", xxx, yyy)

	var zzz = yyy + "alingadingdong"
	printf(@raw "do zzz 1\n")
	zzz = "russian" + yyy
	printf(@raw "do zzz 2\n")

	var aaa: string
	aaa = yyy
	printf(@raw "do aaa\n")

	printf(@raw "[%s] [%s], [%s], [%s]\n", xxx, yyy, zzz, aaa)

	takeS("hello" + "world")

	// printf(@raw "global: [%s]\n", gs)



	// var bbb: string
	// var ccc: string
	// var ddd: string
	// var eee: string

	// bbb = yyy
	// ccc = yyy
	// ddd = yyy
	// eee = yyy

	printf(@raw "\n\n\n\n")

	let gs1 = retS()
	let gs2 = retS()

	retS()

	printf(@raw "ret: [%s], [%s]\n", gs1, gs2)
}


func foo()
{
	defer printf(@raw "fuck\n")

	var i = 0
	while i < 10
	{
		defer printf(@raw "kappa\n")

		printf(@raw "lol")

		if i == 4 { return }

		i += 1
	}
}




















