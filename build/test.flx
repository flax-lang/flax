// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Foundation
import Utilities
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics
import tests.limits



ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(15);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// operators and tuples (vectors type, mainly)
	printf("*** OPERATORS/TUPLE REGRESSION TEST ***\n")
	doOperatorTupleTest()
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	// generics
	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n")


	// int limits
	printf("*** PRINTING INT LIMITS ***\n")
	printIntegerLimits()
	printf("\n\n")


	// fin.
	printf("========= TESTS COMPLETE =========\n\n")
}

// ƒ randomTest(fmt: String, argn: Int64, args: Any*)
// {
// 	var i = 0
// 	while i < argn
// 	{
// 		let argtype = typeof(args[i])

// 		if argtype == typeof(String)
// 		{
// 			printf("%s", args[i] as String)
// 		}
// 		else if argtype == typeof(Int8)
// 		{
// 			printf("%hhd", args[i] as Int8)
// 		}
// 		else if argtype == typeof(Int16)
// 		{
// 			printf("%hd", args[i] as Int16)
// 		}
// 		else if argtype == typeof(Int32)
// 		{
// 			printf("%d", args[i] as Int32)
// 		}
// 		else if argtype == typeof(Int64)
// 		{
// 			printf("%lld", args[i] as Int64)
// 		}
// 		else if argtype == typeof(Uint8)
// 		{
// 			printf("%hhu", args[i] as Uint8)
// 		}
// 		else if argtype == typeof(Uint16)
// 		{
// 			printf("%hu", args[i] as Uint16)
// 		}
// 		else if argtype == typeof(Uint32)
// 		{
// 			printf("%u", args[i] as Uint32)
// 		}
// 		else if argtype == typeof(Uint64)
// 		{
// 			printf("%llu", args[i] as Uint64)
// 		}

// 		i += 1
// 	}
// }





// name idea: mill

// syntax thingy
// do we follow swift, in doing this:
// ƒ foo(fmt: String, args: Any...)

// or, something like this (since it is conceptually an array-like structure)
// ƒ foo(fmt: String, args: Any[...])

// both require some amount of parsing patches, but should be equally doable.
// i'm personally a fan of the secound.

// it should be possible, theoretically, to implement this as a kind of array??
// with a whole "length" and "data" thing. possibly.
// not entirely sure how that will work...
// we don't even have a length property, i don't think, for arrays right now.
// we can statically type check **CONSTANT** indexes into fixed-length arrays at compile time.
// aka it's basically useless.

// but i don't think it will be possible to do that for vararg functions
// so we def. need a length property or something.
// i kinda want varargs first,
// although it would be possibel to move the slipshod array system into a generic Array<> thing, once it's implemented
// (if ever)

// that has a lot more friction though, so i'm more keen to get the non-generic varargs thing working first.
// first, the Any[...] implementation.
// theoretically it should also be possible not to restrict it to Any, and have Int[...], String[...] and so on.
// the array mechanics should work, and typeof() isn't necessary.



// import Math
// import LibCInterface
// import String
// import Foundation
// import tests.operators
// import tests.arraytest

struct Test
{
	var a: Int = 40
}

operator + (a: Test, b: Test) -> Test
{
	return Test()
}

func t() -> Bool { printf(@raw "called true\n"); true }
func f() -> Bool { printf(@raw "called false\n"); false }


var foo: Test

public func main(argc: Int32, argv: Int8**) -> Int
{
	runTests()

	// printf("pi = %.16lf\n", Math.π())

	// var k: String = "HELLO"
	// k[1] = 65 as Int8

	// printf("%c\n", k[0], k[1])


	// var arr8: Array<Int8>
	// var arr32: Array<Int32>

	// arr8.data = alloc[3] Int8
	// arr32.data = alloc[30] Int8
	// printf("data8  = %p\n", arr8.data);
	// printf("data32 = %p\n", arr32.data);


	// thought/todo: enforce immutability in fir?
	// say a value can be immutable, and we can tell alloca whether this is immutable
	// or probably an immutable variant -- AllocateImmutable(type, value) -- since we can't store to it
	// and yea, error on trying to Store() to the value.

	// sounds workable, except maybe error propagation.
	// i don't want to use exceptions, but it might be necessary...
	// and i definitely don't want to have to pass Expr* user to every CreateStore() out there...


	if !f() && t() && t() && t()
	{
		printf("done\n")
	}

	var lol: String = "HELLO"
	printf("lol[2]: %c\n", lol[2])

	var k: Math.Vector2
	k = Math.Vector2(1.0, 4.0)

	printf("k = (%f, %f)\n", k.x, k.y);


	var foo = 40
	printf("HELLO %d\n", foo + 3)
	let a = Test()
	let b = Test()

	let c = a + b

	let v1 = Math.Vector2(1.0, 3.0)
	let v2 = Math.Vector2(5.0, 9.0)

	let v3 = v1 + v2

	var g = "FOO"
	g = "BAR"

	printf(">> g = %s\n", g)

	printf(">> %d\n", c.a)
	printf(">> (%f, %f)\n", v3.x, v3.y)



	// var args = alloc[10] Any
	// args[0] = "HELLO"
	// #(args + 1) = 40
	// args[2] = "GOODBYE"


	// randomTest("", 3, args)

	// println("Hello, ", "World! ", 40, " ", 483, " Goodbye!")

	// var i = 0
	// while true
	// {
	// 	printf("%lld\n", i += 1)
	// 	usleep((10 * 1000) as Uint32)
	// }






	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "finding things in c" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 	3. search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	// printf("\n<< done >>\n");
	return 0
}

















































