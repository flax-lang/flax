// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

/*
import Foundation
import Utilities
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics
import tests.limits
import tests.misc

import tests.functions


ƒ runTests()
{
	// fib
	let fibTitle		= "       *** FIBONACII SEQUENCE ***       \n"
	let fizzbuzzTitle	= "            *** FIZZBUZZ ***            \n"
	let intLimitsTitle	= "       *** PRINTING INT LIMITS ***      \n"
	let scopeTitle		= "*** SCOPE RESOLUTION REGRESSION TEST ***\n"
	let operatorTitle	= " *** OPERATOR/TUPLE REGRESSION TEST *** \n"
	let arrayTitle		= "      *** ARRAY REGRESSION TEST ***     \n"
	let genericsTitle	= "    *** GENERICS REGRESSION TEST ***    \n"
	let functionsTitle	= "    *** FUNCTION REGRESSION TEST ***    \n"
	let miscTitle		= "       *** MISCELLANEOUS TESTS ***      \n"
	let thinLine		= "----------------------------------------\n"
	let endTitle		= "============ TESTS COMPLETE ============\n"




	printf("%s%s", fibTitle, thinLine)
	do {
		var n = 1
		while n < 20
		{
			printf("%lld", doRecursiveFib(n))
			n += 1

			if n != 20
			{
				printf(", ")
			}
		}
		printf("\n\n\n")
	}


	// fizzbuzz
	printf("%s%s", fizzbuzzTitle, thinLine)
	doFizzBuzz(15)
	printf("\n\n\n")


	// int limits
	printf("%s%s", intLimitsTitle, thinLine)
	printIntegerLimits()
	printf("\n\n\n")


	// scopes
	printf("%s%s", scopeTitle, thinLine)
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n\n")


	// operators and tuples (vectors type, mainly)
	printf("%s%s", operatorTitle, thinLine)
	doOperatorTupleTest()
	printf("\n\n\n")


	// arrays
	printf("%s%s", arrayTitle, thinLine)
	doArrayTest()
	printf("\n\n\n")


	// generics
	printf("%s%s", genericsTitle, thinLine)
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n\n")


	// first-class-functions
	printf("%s%s", functionsTitle, thinLine)
	doFunctionTest()
	printf("\n\n\n")



	// misc tests
	printf("%s%s", miscTitle, thinLine)
	doFunctionTest()
	printf("\n\n\n")



	// fin.
	printf("%s\n\n\n\n\n", endTitle)
}





// name idea: mill


struct FormatOptions
{
	var paddingChar: Character
	var precision: int64
	var width: int64
	var paddingKind: int64			// 0 = left, 1 = centre, 2 = right
	var type: String
	var argNum: int64
}




func parseFormatOptions(str: String) -> FormatOptions
{
	let colon		= Character(":")
	let lbrace		= Character("{")
	let rbrace		= Character("}")

	let lettero		= Character("o")
	let letterx		= Character("x")
	let letterX		= Character("X")
	let letterp		= Character("p")
	let letterb		= Character("b")

	let larrow		= Character("<")
	let rarrow		= Character(">")
	let caret		= Character("^")

	let plus		= Character("+")
	let pound		= Character("#")
	let zero		= Character("0")
	let period		= Character(".")

	var ret: FormatOptions


	if str.length < 1 || str[0] != lbrace
	{
		programExit("wtf")
		return ret
	}

	// skip the first.

	let cc = str[1]

	if cc.isDigit()
	{
		var argnum: String
		var i = 1

		while i < str.length && str[i].isDigit()
		{
			argnum += str[i]
			i += 1
		}

		printf("string = %s", argnum)
	}



	println()

	return ret
}





public func main(argc: int32, argv: int8**) -> int
{
	runTests()


	do {
		println("Hello, {%}. This is world {%}, version {%, precision: 2}. {%}.", "World", 2, 3.71, "Goodbye")
		printf("pi = %.16lf, %s\n", Math.π(), "lol")

		println("%b", "a" != "b")

		parseFormatOptions("{401:x}")
	}






	// operator overloading notes:
	// top-level operators need to stay
	// method operators need to stay
	// protocols can dictate needing operators
	//
	// protocols first check the class and any extensions to see if the operator is defined
	// that's it...
	//
	// top level operators secretly create an extension on the type to the left, and make a method instead.
	// this way, protocol resolution can just check the extensions without having to bother with looking at
	// top-level functions.
	//
	// basically, top-level operators will just be syntactic sugar for extensions defining operators.


	// structs vs classes
	// structs:
	// methods. members. no intialisers.
	// extensions cannot have initialisers or stored properties
	// can conform to protocols.
	// vtable handling is done by having global vtable per type. for structs these are immutable.
	// looked up via type id.

	// classes:
	// everything. methods, members, properties, initialisers.
	// vtable is stored *in object*.
	// can be copied and modified at runtime for shits and giggles.




	// note: when we get protocol types working
	// eg. let x = String()
	// func foo(x: SomeProtocol) { ... }
	// foo(x)
	//
	// comparing fir::Type pointers isn't going to work any more.



















	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "find a function named b in a" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 		-> search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	printf("\n<< done >>\n")
	return 0
}














*/


// import LibCInterface

ffi func printf(fmt: int8*, ...)

public func main() -> int
{
	let k: string = "hello"
	var g: string = "world"

	// k + g





	printf(@raw "[%s], [%s]\n", k, g)
	foo()

	return 0
}


func foo()
{
	defer printf("fuck\n")

	var i = 0
	while i < 10
	{
		defer printf("kappa\n")

		printf("lol")

		if i == 4 { return }

		i += 1
	}
}




















