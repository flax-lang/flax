// test.flx
// Copyright (c) 2014 - The Foreseeable Future, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import String

func main() -> Int
{
	var foo: String

	printf("HELLO\n")


	let b: Bar()
	return 0
}


class Bar
{
	init()
	{
		printf("DID BAR\n");
	}

	var foo: Foo
}





class Foo
{
}






// import tests.fizzbuzz
// import tests.recursiveFib
// import tests.scopes
// import tests.arraytest
// import tests.generics

// import Utilities

// ƒ runTests()
// {
// 	// fib
// 	printf("*** FIBONACII SEQUENCE ***\n")

// 	var n = 0
// 	while n < 20
// 	{
// 		printf("%d: %lld\n", n, doRecursiveFib(n))
// 		n += 1
// 	}
// 	printf("\n\n");


// 	// fizzbuzz
// 	printf("*** FIZZBUZZ ***\n")
// 	doFizzBuzz(20);
// 	printf("\n\n");


// 	// scopes
// 	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
// 	doScopeTest("__llvm_jit__build/test")
// 	printf("\n\n");


// 	// arrays
// 	printf("*** ARRAY REGRESSION TEST ***\n")
// 	doArrayTest()
// 	printf("\n\n")


// 	printf("*** GENERICS TEST ***\n")
// 	doGenericsTest()
// 	printf("\n\n")
// }



// class Foo
// {
// 	var v3: Math.Vector3
// 	{
// 		get {
// 			var ret: Math.Vector3

// 			ret.x = 1
// 			ret.y = 4
// 			ret.z = 9

// 			return ret
// 		}
// 		set {
// 			printf("set v3\n")
// 		}
// 	}




// 	var _bar: Int = 537
// 	var bar: Int
// 	{
// 		get {
// 			return self._bar
// 		}
// 		set {
// 			self._bar = newValue
// 		}
// 	}

// 	ƒ doBar() -> Int
// 	{
// 		printf("in foo\n")

// 		return self._bar
// 	}
// }

// class Bar : Foo
// {
// 	override var bar: Int
// 	{
// 		get {
// 			return 73
// 		}
// 		set {
// 			// super.bar = newValue
// 		}
// 	}

// 	override var v3: Math.Vector3
// 	{
// 		get {
// 			var ret: Math.Vector3


// 			// ret.x = super.v3.x + 3
// 			// ret.y = super.v3.y + 5
// 			// ret.z = super.v3.z + 7

// 			ret.x = 33.1

// 			return ret
// 		}
// 		set {
// 			let m = 0
// 		}
// 	}









// 	override ƒ doBar()
// 	{
// 		printf("in bar: %f\n", self.v3.x)
// 	}

// 	var foo = 73
// }

// class FooBar : Bar
// {
// 	override ƒ doBar()
// 	{
// 		printf("in foobar\n")
// 	}
// }








// func main(argc: Int32, argv: Int8**) -> Int
// {
// 	runTests()
// 	printf("========= TESTS COMPLETE =========\n\n")


// 	var k: Int


// 	let bar: Bar()
// 	let foo: Foo()
// 	printf("bar.bar = %d\n", bar._bar)
// 	printf("foo.bar = %d\n", foo.bar)


// 	bar.doBar()
// 	foo.doBar()

// 	let fb: FooBar()
// 	fb.doBar()
// 	printf("%d\n", fb._bar)

// 	printf("pi = %f\n", Math.π())

// 	var vec: Math.Vector2
// 	vec.x = 3
// 	vec.y = 2

// 	var vec2: Math.Vector2
// 	vec2.x = 1
// 	vec2.y = 7



// 	let m = vec + vec2
// 	printf("m = (%f, %f)\n", m.x, m.y)


// 	// let g = foo(30, 1)

// 	// var dream = Math.Complex.Cmplx()
// 	// dream.r = 40
// 	// dream.i = 1.412

// 	// printf("bar.vector3 = (%f, %f, %f), dream = (%f, %f)\n", bar.v3.x, bar.v3.y, bar.v3.z, dream.r, dream.i)







// 	// structs vs classes:
// 	//
// 	// structs will be pure data. POD types and other structs only. nothing else.
// 	// classes will be everything else.
// 	//
// 	// that's it. simple shit.

// 	// todo: look into these.

// 	// >>> universal function call syntax -- use dot-operator calling on everything.
// 	// 	1. when you try to call a.b(c, ...), the usual "finding things in c" takes place
// 	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
// 	// 	3. search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

// 	// >>> multiple, dynamic dispatch











// 	return 0
// }















