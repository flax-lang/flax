// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Foundation
import Utilities
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics
import tests.limits



ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(15);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// operators and tuples (vectors type, mainly)
	printf("*** OPERATORS/TUPLE REGRESSION TEST ***\n")
	doOperatorTupleTest()
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	// generics
	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n")


	// int limits
	printf("*** PRINTING INT LIMITS ***\n")
	printIntegerLimits()
	printf("\n\n")


	// fin.
	printf("========= TESTS COMPLETE =========\n\n")
}





// name idea: mill





















struct FormatOptions
{
	var paddingChar: Character
	var precision: int64
	var width: int64
	var paddingKind: int64			// 0 = left, 1 = centre, 2 = right
	var type: String
	var argNum: int64
}




func parseFormatOptions(str: String) -> FormatOptions
{
	let colon		= Character(":")
	let lbrace		= Character("{")
	let rbrace		= Character("}")

	let lettero		= Character("o")
	let letterx		= Character("x")
	let letterX		= Character("X")
	let letterp		= Character("p")
	let letterb		= Character("b")

	let larrow		= Character("<")
	let rarrow		= Character(">")
	let caret		= Character("^")

	let plus		= Character("+")
	let pound		= Character("#")
	let zero		= Character("0")
	let period		= Character(".")

	var ret: FormatOptions


	if str.length < 1 || str[0] != lbrace
	{
		programExit("wtf")
		return ret
	}

	// skip the first.

	let cc = str[1]

	if cc.isDigit()
	{
		var argnum: String
		var i = 1

		while i < str.length && str[i].isDigit()
		{
			argnum += str[i]
			i += 1
		}

		printf("string = %s", argnum)
	}



	println()

	return ret
}


class TestingClass
{
	init(x: int)
	{
		self.thing = x
	}

	var thing: int
}


extension TestingClass : StringConvertible, Equatable
{
	func toString() -> String
	{
		"hello"
	}

	operator == (a: TestingClass) -> bool
	{
		return self.thing == a.thing
	}
}


func cts<T : StringConvertible>(thing: T) -> String
{
	return thing.toString()
}

func pt<T>(a: T, b: T*) -> T
{
	return a
}

func vt<T>(b: T[...])
{
	var i = 0

	while i < b.length
	{
		printf("%d\n", b[i])
		i += 1
	}
}


@nomangle func mtest(k: int, g: int)
{
	printf("(%d, %d)\n", k, g)

	let x = TestingClass(10)
	let y = TestingClass(20)

	let g = 10
	pt(10, &g)

	vt(10, 30, 40, 50, 60)

	printf("%d, (%s, %s, %s, %s)\n", x == y, cts(k), cts(x), cts(g), cts(y))
}




// although it would be possible to move the slipshod array system into a generic Array<> thing, once it's implemented
// sidenote: oh look, it works for arbitrary types.
// sometimes, i'm impressed by the things i've implemented.

// i think this form of varargs should *stay*, since it's basically a compiler primitive.
// once we have an Array<> type, then it'd be as simple as having the Array<T> class define an initialiser with T[...],
// since we can forward LLVarArrays effortlessly. then it's as easy as let arr = Array(b), and you can have all the Array<> class
// niceties with varargs, without compromising freestanding functionality.

// imho it's not worth it to have the compiler do the same thing as with String, because 1. String is not generic, and 2. varargs isn't
// a "core" language feature, so to speak.

func variadicTest(a: String, b: int[...])
{
	printf("%s: [", a)
	var i = 0
	while i < b.length
	{
		printf("%d", b[i])
		i += 1

		if i != b.length { printf(", ") }
	}

	printf("]\n")
}


public func main(argc: int32, argv: int8**) -> int
{
	runTests()


	do
	{
		println("Hello, {%}. This is world {%}, version {%, precision: 2}. {%}.", "World", 2, 3.71, "Goodbye")
		printf("pi = %.16lf, %s\n", Math.π(), "lol")

		println("%b", "a" != "b")

		parseFormatOptions("{401:x}")

		mtest(10, 41)
	}


	do
	{
		var bar = (10, 20)
		// var foo: (int, int)* = &bar
	}

	do
	{
		var g = "439"
		let k = g.toInteger()
		printf("%s, %d\n", g, k)
	}


	printf("\n\n====================\n\n")

	do
	{
		let v1 = Math.Vector2(1.0, 4.0)
		let v2 = Math.Vector2(3.0, 7.0)

		let vr = v1 ⨯ v2
		printf("(%.2f), vr = %.2f\n", v1 • v2, vr)

		var lol: String = "HELLO"
		printf("%d\n", lol[1].hasData())
		printf("lol[2]: %c // %d // %s\n", lol[1].toAscii(), lol[1].hasData(), lol)

		lol.data = null
	}


	struct Foo
	{
		var a: int
	}

	do
	{
		var k: Math.Vector2
		k = Math.Vector2(1.0, 4.0)

		printf("k = (%.2f, %.2f)\n", k.x, k.y);

		let x = Foo(30)
		var y: Foo = Foo()
		y.a = 10

		y = x
		printf("%d\n", y.a)
	}



	do
	{
		var args = alloc[10] Any
		args[0] = "HELLO"
		#(args + 1) = 40
		args[2] = "GOODBYE"
	}


	variadicTest("ints", 10, 20, 30, 40, 50, 60)






	// operator overloading notes:
	// top-level operators need to stay
	// method operators need to stay
	// protocols can dictate needing operators
	//
	// protocols first check the class and any extensions to see if the operator is defined
	// that's it...
	//
	// top level operators secretly create an extension on the type to the left, and make a method instead.
	// this way, protocol resolution can just check the extensions without having to bother with looking at
	// top-level functions.
	//
	// basically, top-level operators will just be syntactic sugar for extensions defining operators.


	// structs vs classes
	// structs:
	// methods. members. no intialisers.
	// extensions cannot have initialisers or stored properties
	// can conform to protocols.
	// vtable handling is done by having global vtable per type. for structs these are immutable.
	// looked up via type id.

	// classes:
	// everything. methods, members, properties, initialisers.
	// vtable is stored *in object*.
	// can be copied and modified at runtime for shits and giggles.




	// note: when we get protocol types working
	// eg. let x = String()
	// func foo(x: SomeProtocol) { ... }
	// foo(x)
	//
	// comparing fir::Type pointers isn't going to work any more.



















	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "find a function named b in a" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 		-> search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	printf("\n<< done >>\n")
	return 0
}




































