// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

// import String
// import LibCInterface




// class Foo
// {
// 	func generic_test<T>(a: T)
// 	{
// 		printf("something\n")
// 	}
// }


// public func main()
// {
// 	let g = Foo()

// 	g.generic_test("50")
// 	g.generic_test(100)
// }













import Foundation
import Utilities
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics
import tests.limits



ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(15);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// operators and tuples (vectors type, mainly)
	printf("*** OPERATORS/TUPLE REGRESSION TEST ***\n")
	doOperatorTupleTest()
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	// generics
	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n")


	// int limits
	printf("*** PRINTING INT LIMITS ***\n")
	printIntegerLimits()
	printf("\n\n")


	// fin.
	printf("========= TESTS COMPLETE =========\n\n")
}





// name idea: mill

// syntax thingy
// do we follow swift, in doing this:
// ƒ foo(fmt: String, args: Any...)

// or, something like this (since it is conceptually an array-like structure)
// ƒ foo(fmt: String, args: Any[...])

// both require some amount of parsing patches, but should be equally doable.
// i'm personally a fan of the secound.

// it should be possible, theoretically, to implement this as a kind of array??
// with a whole "length" and "data" thing. possibly.
// not entirely sure how that will work...
// we don't even have a length property, i don't think, for arrays right now.
// we can statically type check **CONSTANT** indexes into fixed-length arrays at compile time.
// aka it's basically useless.

// but i don't think it will be possible to do that for vararg functions
// so we def. need a length property or something.
// i kinda want varargs first,
// although it would be possibel to move the slipshod array system into a generic Array<> thing, once it's implemented
// (if ever)

// that has a lot more friction though, so i'm more keen to get the non-generic varargs thing working first.
// first, the Any[...] implementation.
// theoretically it should also be possible not to restrict it to Any, and have Int[...], String[...] and so on.
// the array mechanics should work, and typeof() isn't necessary.


















struct FormatOptions
{
	var paddingChar: Character
	var precision: int64
	var width: int64
	var paddingKind: int64			// 0 = left, 1 = centre, 2 = right
	var type: String
	var argNum: int64
}



func parseFormatOptions(str: String) -> FormatOptions
{
	let colon		= Character(":")
	let lbrace		= Character("{")
	let rbrace		= Character("}")

	let lettero		= Character("o")
	let letterx		= Character("x")
	let letterX		= Character("X")
	let letterp		= Character("p")
	let letterb		= Character("b")

	let larrow		= Character("<")
	let rarrow		= Character(">")
	let caret		= Character("^")

	let plus		= Character("+")
	let pound		= Character("#")
	let zero		= Character("0")
	let period		= Character(".")

	var ret: FormatOptions


	if str.length < 1 || str[0] != lbrace
	{
		programExit("wtf")
		return ret
	}

	// skip the first.

	let cc = str[1]

	if cc.isDigit()
	{
		var argnum: String
		var i = 1

		while i < str.length && str[i].isDigit()
		{
			argnum += str[i]
			i += 1
		}

		printf("string = %s", argnum)
	}



	println()

	return ret
}


class TestingClass
{
	init(x: int)
	{
		self.thing = x
	}

	var thing: int
}


extension TestingClass : StringConvertible, Equatable
{
	func toString() -> String
	{
		"hello"
	}

	func isEqual(a: TestingClass) -> bool
	{
		return self.thing == a.thing
	}
}


func cts<T : StringConvertible>(thing: T) -> String
{
	return thing.toString()
}



@nomangle func mtest(k: int, g: int)
{
	printf("(%d, %d)\n", k, g)

	let x = TestingClass(10)
	let y = TestingClass(20)


	printf("%d, (%s, %s, %s, %s)\n", x == y, cts(k), cts(x), cts(g), cts(y))
}



public func main(argc: int32, argv: int8**) -> int
{
	runTests()


	println("Hello, {%}. This is world {%}, version {%, precision: 2}. {%}.", "World", 2, 3.71, "Goodbye")
	printf("pi = %.16lf, %s\n", Math.π(), "lol")

	println("%b", "a" != "b")

	parseFormatOptions("{401:x}")

	mtest(10, 41)



	var g = "439"
	let k = g.toInteger()
	printf("%s, %d\n", g, k)





	// var arr8: Array<Int8>
	// var arr32: Array<Int32>

	// arr8.data = alloc[3] Int8
	// arr32.data = alloc[30] Int8
	// printf("data8  = %p\n", arr8.data);
	// printf("data32 = %p\n", arr32.data);



	printf("\n\n====================\n\n")

	let smth = alloc[4] Math.Vector2
	smth[0].x = 10

	let v1 = Math.Vector2(1.0, 4.0)
	let v2 = Math.Vector2(3.0, 7.0)

	let vr = v1 ⨯ v2
	printf("(%d), vr = %f\n", v1 • v2, vr)

	var lol: String = "HELLO"
	printf("%d\n", lol[1].hasData())
	printf("lol[2]: %c // %d // %s\n", lol[1].toAscii(), lol[1].hasData(), lol)

	// var k: Math.Vector2
	// k = Math.Vector2(1.0, 4.0)

	// printf("k = (%f, %f)\n", k.x, k.y);

	lol.data = null

	// var args = alloc[10] Any
	// args[0] = "HELLO"
	// #(args + 1) = 40
	// args[2] = "GOODBYE"






	// operator overloading notes:
	// top-level operators need to stay
	// method operators need to stay
	// protocols can dictate needing operators
	//
	// protocols first check the class and any extensions to see if the operator is defined
	// that's it...
	//
	// top level operators secretly create an extension on the type to the left, and make a method instead.
	// this way, protocol resolution can just check the extensions without having to bother with looking at
	// top-level functions.
	//
	// basically, top-level operators will just be syntactic sugar for extensions defining operators.
























	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "find a function named b in a" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 		-> search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	printf("\n<< done >>\n")
	return 0
}



































