// test.flx
// Copyright (c) 2014 - The Foreseeable Future, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Foundation
import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.arraytest
import tests.generics

import Utilities

ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(20);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	printf("\n\n")
}



struct Foo
{
	var _bar: Int = 537
	var bar: Int
	{
		get
		{
			return self._bar
		}
		set
		{
			self._bar = newValue
		}
	}

	ƒ doBar() -> Int
	{
		printf("in foo\n")

		return self._bar
	}
}

struct Bar : Foo
{
	override var bar: Int
	{
		get
		{
			return 73
		}
		set
		{
			// super.bar = newValue
		}
	}

	override ƒ doBar()
	{
		printf("in bar\n")
	}

	var foo = 73
}


func main(argc: Int32, argv: Int8**) -> Int
{
	// runTests()
	printf("========= TESTS COMPLETE =========\n\n")


	let b: Bar = Bar()
	let f: Foo = Foo()
	printf("bar.bar = %d\n", b._bar)
	printf("foo.bar = %d, %d\n", f.bar)

	b.doBar()
	f.doBar()

	// this is a good place to do my ranting
	// do we want to differentiate between structs and classes?
	// Swift differentiates them by having structs be "value types", and classes be "reference types".
	//
	// I don't want to do this, because this is still supposed to be a low-ish level
	// language -- implicit ref types (ie. without pointers and doing a background malloc()) doesn't sound
	// too ideal.
	//
	// Since the struct type already does pretty much everything, there are a few possible options:
	//
	// 1.	have the struct and class keyword be aliases, except class has private members by default (C++ style)
	//
	// 2.	have structs be limited to only having var members, which are either POD types or other structs.
	//		no funcs, no init(), no inheritance, nothing. They would be a plain data class, like in the C days.
	//
	// 3.	have structs be limited to the following:
	// 			funcs and computed properties
	//			conform to protocols
	//
	//		and have classes do everything else:
	//			inherit from classes
	//			override funcs and computed vars.
	//			virtual inheritance (vtable, runtime call resolution, dynamic type casting)
	//			...???
	//



	return 0
}




























