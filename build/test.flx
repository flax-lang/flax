// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Foundation
import Utilities
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics
import tests.limits



ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(15);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// operators and tuples (vectors type, mainly)
	printf("*** OPERATORS/TUPLE REGRESSION TEST ***\n")
	doOperatorTupleTest()
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	// generics
	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n")


	// int limits
	printf("*** PRINTING INT LIMITS ***\n")
	printIntegerLimits()
	printf("\n\n")


	// fin.
	printf("========= TESTS COMPLETE =========\n\n")
}





// name idea: mill

// syntax thingy
// do we follow swift, in doing this:
// ƒ foo(fmt: String, args: Any...)

// or, something like this (since it is conceptually an array-like structure)
// ƒ foo(fmt: String, args: Any[...])

// both require some amount of parsing patches, but should be equally doable.
// i'm personally a fan of the secound.

// it should be possible, theoretically, to implement this as a kind of array??
// with a whole "length" and "data" thing. possibly.
// not entirely sure how that will work...
// we don't even have a length property, i don't think, for arrays right now.
// we can statically type check **CONSTANT** indexes into fixed-length arrays at compile time.
// aka it's basically useless.

// but i don't think it will be possible to do that for vararg functions
// so we def. need a length property or something.
// i kinda want varargs first,
// although it would be possibel to move the slipshod array system into a generic Array<> thing, once it's implemented
// (if ever)

// that has a lot more friction though, so i'm more keen to get the non-generic varargs thing working first.
// first, the Any[...] implementation.
// theoretically it should also be possible not to restrict it to Any, and have Int[...], String[...] and so on.
// the array mechanics should work, and typeof() isn't necessary.


















struct FormatOptions
{
	var paddingChar: Character
	var precision: int64
	var width: int64
	var paddingKind: int64			// 0 = left, 1 = centre, 2 = right
	var type: String
	var argNum: int64
}



func parseFormatOptions(str: String) -> FormatOptions
{
	let colon		= Character(":")
	let lbrace		= Character("{")
	let rbrace		= Character("}")

	let lettero		= Character("o")
	let letterx		= Character("x")
	let letterX		= Character("X")
	let letterp		= Character("p")
	let letterb		= Character("b")

	let larrow		= Character("<")
	let rarrow		= Character(">")
	let caret		= Character("^")

	let plus		= Character("+")
	let pound		= Character("#")
	let zero		= Character("0")
	let period		= Character(".")

	var ret: FormatOptions


	if str.length < 1 || str[0] != lbrace
	{
		programExit("wtf")
		return ret
	}

	// skip the first.

	let cc = str[1]

	if cc.isDigit()
	{
		var argnum: String
		var i = 1

		while i < str.length && str[i].isDigit()
		{
			argnum += str[i]
			i += 1
		}

		printf("string = %s", argnum)
	}




	return ret
}




extension String
{
	func toInteger() -> Int64
	{
		return 4913
	}
}


public func main(argc: int32, argv: int8**) -> int
{
	// runTests()


	println("Hello, {%}. This is world {%}, version {%, precision: 2}. {%}.", "World", 2, 3.71, "Goodbye")


	printf("pi = %.16lf, %d\n", Math.π(), 31)

	println("%b", "a" != "b")

	parseFormatOptions("{401:x}")

	// var arr8: Array<Int8>
	// var arr32: Array<Int32>

	// arr8.data = alloc[3] Int8
	// arr32.data = alloc[30] Int8
	// printf("data8  = %p\n", arr8.data);
	// printf("data32 = %p\n", arr32.data);



	printf("\n\n====================\n\n")

	var lol: String = "HELLO"
	printf("%d\n", lol[1].hasData())
	printf("lol[2]: %c // %d // %s\n", lol[1].toAscii(), lol[1].hasData(), lol)

	// var k: Math.Vector2
	// k = Math.Vector2(1.0, 4.0)

	// printf("k = (%f, %f)\n", k.x, k.y);

	lol.data = null

	// var args = alloc[10] Any
	// args[0] = "HELLO"
	// #(args + 1) = 40
	// args[2] = "GOODBYE"










	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "find a function named b in a" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 		-> search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	printf("\n<< done >>\n");
	return 0
}



































