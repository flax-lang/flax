// test.flx
// Copyright (c) 2014 - The Foreseeable Future, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Foundation
import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.arraytest
import tests.generics

import Utilities

ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(20);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	printf("\n\n")
}



class Foo
{
	var v3: Math.Vector3
	{
		get {
			var ret: Math.Vector3

			ret.x = 1
			ret.y = 4
			ret.z = 9

			return ret
		}
		set {
			printf("set v3\n")
		}
	}




	var _bar: Int = 537
	var bar: Int
	{
		get {
			return self._bar
		}
		set {
			self._bar = newValue
		}
	}

	ƒ doBar() -> Int
	{
		printf("in foo\n")

		return self._bar
	}
}

class Bar : Foo
{
	override var bar: Int
	{
		get {
			return 73
		}
		set
		{
			// super.bar = newValue
		}
	}

	override var v3: Math.Vector3
	{
		get {
			var ret: Math.Vector3


			// ret.x = super.v3.x + 3
			// ret.y = super.v3.y + 5
			// ret.z = super.v3.z + 7

			return ret
		}
		set {
			let m = 0
		}
	}









	override ƒ doBar()
	{
		printf("in bar: %f\n", self.v3.x)
	}

	var foo = 73
}

class FooBar : Bar
{
	override ƒ doBar()
	{
		printf("in foobar\n")
	}
}








func main(argc: Int32, argv: Int8**) -> Int
{
	// runTests()
	printf("========= TESTS COMPLETE =========\n\n")


	var k: Int


	let bar: Bar()
	let foo: Foo()
	printf("bar.bar = %d\n", bar._bar)
	printf("foo.bar = %d, %d\n", foo.bar)


	bar.doBar()
	foo.doBar()

	let fb: FooBar()
	fb.doBar()
	printf("%d\n", fb._bar)

	printf("pi = %f\n", Math.π())

	var vec: Math.Vector2
	vec.x = 3
	vec.y = 2

	var vec2: Math.Vector2
	vec2.x = 1
	vec2.y = 7


	/*
		todo: custom operator thoughts.

		currently, having it implemented in the parser is **impossible** to do. the parser cannot know anything.

		potential solution is to look for patterns like these:
		IDENTIFIER IDENTIFIER or IDENTIFIER IDENTIFIER IDENTIFIER

		ie. two or more identifier tokens in a row. i cannot think of a scenario where two or more identifiers will be consecutive
		in any source text.

		the parser can flag these groups as "potential custom operators".
		** PROBLEM: how do we settle precedence? by the time we get into the codegen, all the binops etc. have
		already been formed...


		one more potential solution is to just do a "preliminary parse" of all files, that would also recursively scan imports,
		looking only for 3 things:

		1. imports
		2. operators with custom identifiers
		3. @precedence attributes

		everything else will be ignored.
		This presents a snag when we do incremental compilation in the future -- you can ever only call the compiler on the main file,
		and every single import must be parsed to some degree...

		EDIT: not necessarily. since an externally defined custom operator must also be imported, it would also be parsed. Theoretically
		it shouldn't affect our ability to incrementally compile, although we still need to parse every file.

		This is in a similarly gross vein to how we handle instantiating generic functions -- BY TRYING EVERYTHING.
		It's sad, really.



		I think this is the solution we will end up implementing until a better one is found. This allows us to cleanly keep all
		precedence and parsing things in the parser as well.
	*/





	let m = vec + vec2
	printf("m = (%f, %f)\n", m.x, m.y)





	// var dream = Math.Complex.Cmplx()
	// dream.r = 40
	// dream.i = 1.412

	// printf("bar.vector3 = (%f, %f, %f), dream = (%f, %f)\n", bar.v3.x, bar.v3.y, bar.v3.z, dream.r, dream.i)


	/*
		structs vs classes:

		structs will be pure data. POD types and other structs only. nothing else.
		classes will be everything else.

		that's it. simple shit.
	*/














	/*

		todo: look into these.

		>>> universal function call syntax -- use dot-operator calling on everything.
			1. when you try to call a.b(c, ...), the usual "finding things in c" takes place
			2. if nothing in c matches b (or c is not a compound type), use UFCS.
			3. search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

		>>> multiple, dynamic dispatch
	*/











	return 0
}















