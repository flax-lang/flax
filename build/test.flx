// test.flx
// Copyright (c) 2014 - The Foreseeable Future, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Foundation
import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.arraytest
import tests.generics

import Utilities

ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	doFizzBuzz(20);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	printf("\n\n")
}



class Foo
{
	var _bar: Int = 537
	var bar: Int
	{
		get
		{
			return self._bar
		}
		set
		{
			self._bar = newValue
		}
	}

	ƒ doBar() -> Int
	{
		printf("in foo\n")

		return self._bar
	}
}

class Bar : Foo
{
	override var bar: Int
	{
		get
		{
			return 73
		}
		set
		{
			// super.bar = newValue
		}
	}

	override ƒ doBar()
	{
		printf("in bar\n")
	}

	var foo = 73
}

class FooBar : Bar
{
	override ƒ doBar()
	{
		printf("in foobar\n")
	}
}

func main(argc: Int32, argv: Int8**) -> Int
{
	// runTests()
	printf("========= TESTS COMPLETE =========\n\n")


	var k: Int


	let b: Bar()
	let f: Foo()
	printf("bar.bar = %d\n", b._bar)
	printf("foo.bar = %d, %d\n", f.bar)


	b.doBar()
	f.doBar()

	let fb: FooBar()
	fb.doBar()
	printf("%d\n", fb._bar)




	/*
		structs vs classes:

		structs will be pure data. POD types and other structs only. nothing else.
		classes will be everything else.

		that's it. simple shit.
	*/














	/*

		todo: look into these.

		>>> universal function call syntax -- use dot-operator calling on everything.
			1. when you try to call a.b(c, ...), the usual "finding things in c" takes place
			2. if nothing in c matches b (or c is not a compound type), use UFCS.
			3. search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

		>>> multiple, dynamic dispatch
	*/











	return 0
}




























