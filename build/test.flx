// test.flx
// Copyright (c) 2014 - 2015, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

import Math
import String

import tests.fizzbuzz
import tests.recursiveFib
import tests.scopes
import tests.operators
import tests.arraytest
import tests.generics

import Utilities


// name idea: mill


ƒ runTests()
{
	// fib
	printf("*** FIBONACII SEQUENCE ***\n")

	var n = 0
	while n < 20
	{
		printf("%d: %lld\n", n, doRecursiveFib(n))
		n += 1
	}
	printf("\n\n");


	// fizzbuzz
	printf("*** FIZZBUZZ ***\n")
	// doFizzBuzz(50);
	printf("\n\n");


	// scopes
	printf("*** SCOPE RESOLUTION REGRESSION TEST ***\n")
	doScopeTest("__llvm_jit__build/test")
	printf("\n\n");


	// operators and tuples (vectors type, mainly)
	printf("*** OPERATORS/TUPLE REGRESSION TEST ***\n")
	doOperatorTupleTest()
	printf("\n\n");


	// arrays
	printf("*** ARRAY REGRESSION TEST ***\n")
	doArrayTest()
	printf("\n\n")


	// generics
	printf("*** GENERICS TEST ***\n")
	doGenericsTest()
	let s = generic_test(5, "HELLO WORLD #")
	printf("s = %s\n", s)
	printf("\n\n")


	// fin.
	printf("========= TESTS COMPLETE =========\n\n")
}



class Foo
{
	ƒ doStuff()
	{
		printf("in foo\n")
	}
}

class Bar : Foo
{
	override ƒ doStuff()
	{
		printf("in bar\n")
	}
}

// namespace Int8
// {
// 	val min: Int8 = -12
// 	val max: Int8 = 127
// }

namespace Int32
{
	val min: Int8 = -12
	val max: Int8 = 100
}

// class FooBar : Bar
// {
// 	override ƒ doBar()
// 	{
// 		printf("in foobar\n")
// 	}
// }






func acceptFoo(f: Foo)
{
	printf("got foo\n")
}

func acceptFooPtr(f: Foo)
{
	printf("got foo pointer\n")
}


public func main(argc: Int32, argv: Int8**) -> Int
{
	runTests()

	// let b: Bar()

	// printf("pi = %f\n", Math.π())

	// acceptFoo(b)



	// let bp = alloc Bar
	// acceptFooPtr(bp)

	// let foo: Foo = Bar()
	// foo.doStuff()

	// printf("Int8.min = %d, Int8.max = %d\n", Int32.min, Int32.max);

	var foo = 1
	foo <<= 3
	printf("foo = %d\n", foo)
	// var arr: Array<Int8, Int32, Array<Int32>>









	// structs vs classes:
	//
	// structs will be pure data. POD types and other structs only. nothing else.
	// classes will be everything else.
	//
	// that's it. simple shit.

	// todo: look into these.

	// >>> universal function call syntax -- use dot-operator calling on everything.
	// 	1. when you try to call a.b(c, ...), the usual "finding things in c" takes place
	// 	2. if nothing in c matches b (or c is not a compound type), use UFCS.
	// 	3. search for a function b(a, c, ...). if it exists, call it. if not, throw error as usual.

	// >>> multiple, dynamic dispatch


	printf("\n\n\n<< done >>\n");
	return 0
}















