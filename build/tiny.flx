// tiny.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

ffi fn malloc(size: i64) -> i8*
ffi fn printf(fmt: i8*, ...) -> i32


class Array<T>
{
	var data: T*

	init(ptr: T*)
	{
		self.data = ptr
	}

	operator [] (index: i64) -> T
	{
		get { self.data[index] }
		set { printf("setting\n"); self.data[index] = value }
	}

	fn method(x: Array<T: T>*)
	{
	}
}

/*fn test2<T>(a: Array<T: T>)
{
	printf("typeid(T) = %d\n", typeid(T))
}

fn test<A, B>(a: Array<T: A>, b: Array<T: B>)
{
	printf("typeid(T) = %d / %d / %d / %d\n", typeid(A), typeid(B), typeid(a), typeid(b))
	let x = Array<T: A>(null)

	test2(x)
}*/

fn test<A, B>(a: A, b: B)
{
	let x = A()
	// test2(x)
}

fn test2<T>(x: T)
{
	printf("typeid(T) = %d\n", typeid(T))
}

public fn main() -> int
{
	/*do {
		// let ptr = (alloc[60] i64).data
		// defer dealloc ptr

		// var list = Array<T: i64>(ptr)
		var list = Array<T: i64>(null)

		// ptr[0] = 37

		// printf("x = %d\n", list[0])
		// list[1] = 401

		test(list, list)
	}*/


	do {
		let ptr = (alloc[60] string).data
		defer dealloc ptr

		var list1 = Array<T: string>(ptr)
		var list2 = Array<T: char>(null)

		// HAHAHAH THIS IS COMPLETLY FUCKED AS WELL

		/*
			list1.method(&list1)
			list2.method(&list2)
		*/

		// list1[3] = "foobar"

		// printf("0 = '%s', 3 = '%s'\n", list1[0], list1[3])

		// test(list1, list2)
	}










	// it is at this point that i solemnly declare:
	// generics are COMPLETELY FUCKED

	// completely and utterly fucked.
	// why wasn't this discovered earlier????

	// postulations:
	/*
		1. possibly something related to the cachedResolveTarget in the FuncCall AST

		2. for the operators, it's probably completely fucked.
			I'd imagine normal methods and such are also completely fucked if they take Self as an argument.
			fucked, fucked, fucked.

		3. lol, methods are completely and utterly fucked as well. what even, type already exists? fuck me
	*/

	test("foo", 10)
	test(char("A"), 3.0)

	return 0
}










// notes for next week and/or tomorrow:
/*
	add some implicit facilities via the init() call, if available
	obviously, if there's some other type parameter inside that isn't visible in the init() signature, we can't
	infer it (since we only look at declarations to infer), and so we'll complain. Simple as that.
*/









