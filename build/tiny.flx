// tiny.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

ffi func malloc(size: i64) -> i8*
ffi func printf(fmt: i8*, ...) -> i32

namespace NS
{
	class Array<T: SomeProt>
	{
		var data: T*

		init(ptr: T*)
		{
			self.data = ptr
		}

		operator [] (index: i64) -> T
		{
			get { self.data[index] }
			set { printf("setting\n"); self.data[index] = value }
		}
	}
}

protocol SomeProt
{
	func foo() -> int
}

extension i64 : SomeProt
{
	func foo() -> int { printf("lol") }
}
extension string : SomeProt
{
	func foo() -> int { printf("lol") }
}

func add<T>(a: T, b: T) -> T
{
	a + b
}

func bar(a: i64, b: i64) -> i64 { a * b }

public func main() -> int
{
	do {
		let ptr = (alloc[60] i64).data
		defer dealloc ptr

		var list = NS.Array<T: i64>(ptr)

		ptr[0] = 37

		printf("x = %d\n", list[0])
		list[1] = 401
	}

	do {
		let ptr = (alloc[60] string).data
		defer dealloc ptr


		var list = NS.Array<T: string>(ptr)
		list[3] = "foobar"

		printf("0 = '%s', 3 = '%s'\n", list[0], list[3])
	}

	let c = add<T: i64>(30, 40)
	printf("c = %d\n", c)

	return 0
}


// notes for next week and/or tomorrow:
/*
	fix createType to respect the generic types.
	do some reification bullshit, either implicitly or explicitly.

	we'll do it explicitly first, but probably add some implicit facilities via the init() call, if available
	obviously, if there's some other type parameter inside that isn't visible in the init() signature, we can't
	infer it (since we only look at declarations to infer), and so we'll complain. Simple as that.

	also: look into *possibly* changing the explicit syntax. <| ... |> seems a bit clunky.
	parser changes would possibly be large, although it might simply entail a "tryParseTypeParamList()" and "refundTokens()"
	kind of deal, who knows.

	Low-ish priority as of now, the syntax is just so we can have something to work with.
*/









