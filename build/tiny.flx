// tiny.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.

ffi fn malloc(size: i64) -> i8*
ffi fn printf(fmt: i8*, ...) -> i32


class Array<T>
{
	var data: T*

	init(ptr: T*)
	{
		self.data = ptr
	}

	operator [] (index: i64) -> T
	{
		get { self.data[index] }
		set { printf("setting\n"); self.data[index] = value }
	}

	fn method(x: Array<T: T>*)
	{
	}
}

/*fn test2<T>(a: Array<T: T>)
{
	printf("typeid(T) = %d\n", typeid(T))
}

fn test<A, B>(a: Array<T: A>, b: Array<T: B>)
{
	printf("typeid(T) = %d / %d / %d / %d\n", typeid(A), typeid(B), typeid(a), typeid(b))
	let x = Array<T: A>(null)

	test2(x)
}*/

fn test<A, B>(a: A, b: B)
{
	let x = A()
	test2(x)
}

fn test2<T>(x: T)
{
	printf("typeid(T) = %d\n", typeid(T))
}

public fn main() -> int
{
	/*do {
		// let ptr = (alloc[60] i64).data
		// defer dealloc ptr

		// var list = Array<T: i64>(ptr)
		var list = Array<T: i64>(null)

		// ptr[0] = 37

		// printf("x = %d\n", list[0])
		// list[1] = 401

		test(list, list)
	}*/


	do {
		let ptr1 = (alloc[60] string).data; defer dealloc ptr1
		let ptr2 = (alloc[60] char).data; defer dealloc ptr2

		var list1 = Array<T: string>(ptr1)
		var list2 = Array<T: char>(ptr2)

		// HAHAHAH THIS IS COMPLETLY FUCKED AS WELL

		// 0x00000001038007d0

		// list1.method(&list1)
		// list1[0]
		// list2[0]
		// list1[0]
		// list2.method(&list2)


		// list1[3] = "foobar"

		// printf("0 = '%s', 3 = '%s'\n", list1[0], list1[3])

		test(list1, list2)
	}










	// it is at this point that i solemnly declare:
	// generics are COMPLETELY FUCKED

	// completely and utterly fucked.
	// why wasn't this discovered earlier????

	// postulations:
	/*
		1. possibly something related to the cachedResolveTarget in the FuncCall AST

		2. for the operators, it's probably completely fucked.
			I'd imagine normal methods and such are also completely fucked if they take Self as an argument.
			fucked, fucked, fucked.

		3. lol, methods are completely and utterly fucked as well. what even, type already exists? fuck me


		I think it is at this point the migration of stateful information *away* from the AST is inevitable.
		frankly don't think we can continue sanely at this point





		// post-fix-session #1


		1. funccall problems fixed, but compile times get longer because we're essentially checking shit twice.
			i'm not sure what can be done about this

		2. operators are facing a similar problem: whichever mapping is most recently reified
			is the one that will work

			eg. {
				let foo = Array<T: int>(...)
				let bar = Array<T: string>(...)

				>> this will not work, since 'bar' was the most recently reified form of Array<T>
				foo[0]

				>> this will work
				bar[0]
			}

		3. not sure what's up with methods, have yet to investigate (and won't have time to for many weeks)


		more ramblings:

		we might have to move towards a post-typecheck AST system
		so typechecking creates a new AST tree, with proper duplication of generic functions and types, etc.

		it's either this or dumping more information into FIR (which i'm not too keen on -- it should stay language agnostic preferably)


		this would mean a large-scale rewrite of... basically everything important
		(the only things spared would be the parser and the llvm backend)

		includes rewriting things like:
		1. dot operator nightmare
		2. structs/classes/extensions + generic nonsense
		3. function decls and all that stupid shit
		4. OPERATORS??? and overloading (since it involves generic types/functions as well eventually)

		Certain things wouldn't need extensive changes, like (thankfully) the generic type solver.

		The objective for this new syntax tree (Concrete Syntax Tree? CST? sounds passable) is to allow "seamless" usability of
		generic things, mostly

		less duplication of code (getType() / codegen() perform a lot of the same operations, eg. FuncCall (and how i fixed it) and such)
		calling generic functions and using generic types should be *as transparent as possible* to consumers

		ie. people should not be having to do shit like check if this struct is generic, see if the consumer has type parameters,
		and reify it -- all of this should have happened in the AST phase, and the appropriate things completely reified.

		hence the name -- *concrete* syntax tree. codegen() should be straightforward with fewer special-case shit happening.



		honestly it's at this point where a project starts to become unfeasible (to complete), and it's either abandoned, or I'll do stupid
		pointless stuff that doesn't add that much to the language.

		*HOWEVER*, generic types really are the last *major* hurdle to flax being feature-complete, so there it is.
		It'll be done.
	*/

	test("foo", 10)
	test(char("A"), 3.0)

	// test2("foo")
	// test2(3)

	return 0
}










// notes for next week and/or tomorrow:
/*
	add some implicit facilities via the init() call, if available
	obviously, if there's some other type parameter inside that isn't visible in the init() signature, we can't
	infer it (since we only look at declarations to infer), and so we'll complain. Simple as that.
*/









