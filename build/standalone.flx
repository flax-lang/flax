// standalone.flx
// Copyright (c) 2014 - 2016, zhiayang@gmail.com
// Licensed under the Apache License Version 2.0.


/*
	TOFIX:

	1. enums declared in functions do not work

	3. dynamic array slices
	4. FOR LOOPS
		4a: `for x in y` would be pretty cool too.
		4b: `for x in (1, 3)` would be dope af
			4bi: should the range be open or closed by default? ie. is it 1 <= x <= 3, or 1 <= x < 3?
			4bii: potential range operator: `for x in 0..4` and/or `for x in 0..4` ? idk.
			4biii: i think one (either open or closed) should be chosen as default. it's not hard to ±1 if needed, i think

	5. assign [] to dynamic arrays
	6. general fixes to [] -- type inference
		6a: stuff like passing [] to a function taking an array, for instance
			type inference needs to happen.

	7. do { } while { }
		this parses as (do {} while), and ({ })
		do a newline / semicolon check or smth

	8. abort(), exit(), etc. should be allowed as the last expression in a function
		and allow the compiler to just ignore the fact that there's no return value
		ie. __attribute__((noreturn))

	9. honestly the whole scoping/namespacing thing is fucked up, and will need a rewrite.

	10. honestly the whole thing is fucked up. a rewrite of everything is impossible, however.
		the type inference needs to be smarter -- generalising and re-purposing the existing generic type solver
		for this might turn out to be a good idea in the future.

	11. also the fucking generic type solver isn't finished god dammit

	12. global variables outside of namespaces don't work

	13. T.0.1 parses as T. (0.1) where 0.1 is a number
		shit fails yo

		> only return integers from the lexer -- (0.0331) becomes '0', '.', '0331'
		> need to keep leading 0s


	TO TEST:

	1. tuple operators
	2. array of strings



	TO DO:

	1. array decomp
	2. tuple decomp
	3. splatting (http://coffeescript.org/#splats)

	4. clean up typechecking
		-- store the fir::Type of each AST node
		-- recursively visit each node to get its type before anything happens


	tuple decomp:
	let (a, b) = (10, 20)

	array decomp:
	let [a, b, ...x] = [ 10, 20, 30, 40, 50, 60 ]
	a = 10, b = 20, x = [ 30, 40, 50, 60 ]


*/




// import LibCInterface

ffi func printf(fmt: i8*, ...) -> i32

func map<T, R>(arr: T[], f: [(T) -> R]) -> R[]
{
	var i = 0
	var ret = alloc[arr.length] R
	while i < arr.length
	{
		ret[i] = f(arr[i])
		i += 1
	}

	return ret
}

func map<T, R>(arr: T[], f: [(T, int) -> R]) -> R[]
{
	var i = 0
	var ret = alloc[arr.length] R
	while i < arr.length
	{
		ret[i] = f(arr[i], 3)
		i += 1
	}

	return ret
}

func map2<T, K, R>(arr: (T, K)[], f: [(T, K) -> R]) -> R[]
{
	var i = 0
	var ret = alloc[arr.length] R
	while i < arr.length
	{
		ret[i] = f(arr[i].0, arr[i].1)
		i += 1
	}

	return ret
}


func incr(x: int) -> int { x + 1 }
func gmult<T>(x: T, m: T) -> T { x * m }
func add2<A, B>(x: A, y: B) -> A { x + y }






/*
	notes

	extension [] { }
	^ this extends all dynamic arrays

	extension T[]
	^ this extends dynamic arrays of type T

	presumably eventually we'll get generic types,
	so we need generic extensions to go with that.

	but dynamic arrays aren't "generic types" per-se, so we need something for it.

	lambdas:

	λ(x: int, y: int) -> string => {

	}

	.\(x: int, y: int) -> int => {

	}


	todo: handle taking address of function
	todo: basic blocks need to check if they all have a terminator
*/




func tmpf<T>(x: (T, T)) -> T
{
	return x.0 + x.1
}

func vartup<T, K, U>(f: [(T, T) -> K], y: (U, U)[...]) -> K[]
{
	var ret = alloc[y.length] K

	var i = 0
	while i < y.length
	{
		ret[i] = f(y[i])
	}

	retun ret
}











public func main()
{
	// generictest()

	// let (a, (b, (c, d), e), f) = (10, (20, ("foo", "bar"), 3.1), 10.41)

	var _ = 30


	printf("done\n")
}


func generictest()
{
	var arr = alloc[5] (int, int)
	var i = 0
	while i < arr.length
	{
		arr[i] = (i, i * (i + 5))
		i += 1
	}

	let new = map2(arr, add2)

	// vartup(tmpf, [ (1, 5), (3, 10), (7, 3) ])

	// let new = map(arr, gincr)
	// let new = map(arr, gmult)
	// let new = mapstupid(arr2, gincr, apply)


	i = 0
	while i < new.length
	{
		printf("%d: %d\n", i, new[i])
		i += 1
	}

	// fntest(10, 3)
	// let x = apply(10, 30)
	// printf("x = %d\n", x)
}


func apply<U, V>(x: U, f: [(U) -> V]) -> V { f(x) }

func gincr<T>(x: T) -> T { x + 1 }
func mapstupid<T, K, R>(arr: T[], fn: [(T) -> K], fa: [(T, [(T) -> K]) -> R]) -> R[]
{
	var i = 0
	var ret = alloc[arr.length] R
	while i < arr.length
	{
		ret[i] = fa(arr[i], fn)
		i += 1
	}

	return ret
}




// func mapint(arr: int[], f: [(int) -> int]) -> int[]
// {
// 	var i = 0
// 	var ret = alloc[arr.length] int
// 	while i < arr.length
// 	{
// 		ret[i] = f(arr[i])
// 		i += 1
// 	}

// 	return ret
// }











