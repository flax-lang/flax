diff --git a/README.md b/README.md
index 0a62fbc8f..afdd7f8cc 100644
--- a/README.md
+++ b/README.md
@@ -104,7 +104,7 @@ do {

 - The `makefile` is the preferred way to build on UNIX systems.
 - LLVM needs to be installed. On macOS, `brew install llvm@7` should work, and you might need to do some PPA fiddling for Debian-based distros.
-- A *C++17*-compatible compiler should be used.
+- A C++17-compatible compiler should be used.
 - Find the `flaxc` executable in `build/sysroot/usr/local/bin`
 - Additionally, the (admittedly limited) standard library will be copied from `./libs` to `./build/sysroot/usr/local/lib/flaxlibs/`

diff --git a/build/ultratiny.flx b/build/ultratiny.flx
index 8f2ac0cbe..0a5ecef33 100644
--- a/build/ultratiny.flx
+++ b/build/ultratiny.flx
@@ -4,21 +4,26 @@

 export ultratiny
 import libc as _
+import "tests/scopes.flx"

 class Foo
 {
 	init(x: int)
 	{
-		printf("create foo %d\n", x)
-		this.value = x
+		printf("* create foo %d\n", x)
+		this.rc = alloc mut int
+		*this.rc = 1
+
+		this.v = x
 	}

-	// copy(other: &self) { this.value = other.value; printf("copying foo\n") }
-	// move(other: &mut self) { printf("moving foo\n") }
+	copy(from: &self) { this.v = from.v; this.rc = from.rc; *this.rc += 1; printf("* copy foo %d/rc: %d\n", this.v, *this.rc) }
+	move(from: &mut self) { this.v = from.v; this.rc = from.rc; from.rc = null; printf("* move foo %d/rc: %d\n", this.v, *this.rc) }

-	// deinit => printf("delete foo\n")
+	deinit { if(this.rc) => *this.rc -= 1; printf("* delete foo %d/rc: %d\n", this.v, *this.rc) }

-	var value: int
+	var rc: &mut int
+	var v: int
 }

 fn bar() -> Foo
@@ -26,14 +31,40 @@ fn bar() -> Foo
 	return Foo(x: 7)
 }

+fn con(x: Foo)
+{
+	printf("\nconsumed %d, rc: %d\n\n", x.v, *x.rc)
+}
+
+
 @entry fn main()
 {
-	bar()
-	// let x = Foo(x: 3)
+	let y = bar()
+	printf("\ny.value = %d, rc: %d\n\n", y.v, *y.rc)
+
+	let x = Foo(x: 13)
+	printf("\nx.value = %d, rc: %d\n\n", x.v, *x.rc)
+
+	con(x)
+
+	// test_scopes::doScopeTest("__llvm_jit__build/test")
 }



+/*
+	! let x = alloc int { it = ... } fails!!
+
+	todo to cleanup semantics:
+	1. copy and move constructors must call a base class constructor if there is not default one
+	2. allow omitting the explicit call if the base class has a no-arg constructor (to prevent init() : super() { ... })
+	3. check if constructing stuff in conditionals will wrongly destruct them!
+
+	todo for implementing destructors properly:
+	2. only classes can contain other classes! (ANY notwithstanding)
+	3. similar to how class constructors call the superclass constructors, we need to call base destructors also!
+	4. virtual destructors! need to add it to the vtable!!!!!
+*/



diff --git a/external/tinyprocesslib/process_win.inc b/external/tinyprocesslib/process_win.inc
index 3dcd1de28..eef96e57d 100644
--- a/external/tinyprocesslib/process_win.inc
+++ b/external/tinyprocesslib/process_win.inc
@@ -161,7 +161,7 @@ int Process::get_exit_status() {
   DWORD exit_status;
   WaitForSingleObject(data.handle, INFINITE);
   if(!GetExitCodeProcess(data.handle, &exit_status))
-    exit_status=-1;
+    exit_status=(DWORD)-1;
   {
     std::lock_guard<std::mutex> lock(close_mutex);
     CloseHandle(data.handle);
diff --git a/external/utf8rewind/include/utf8rewind/utf8rewind.h b/external/utf8rewind/include/utf8rewind/utf8rewind.h
index 19b040c17..59c24b26d 100644
--- a/external/utf8rewind/include/utf8rewind/utf8rewind.h
+++ b/external/utf8rewind/include/utf8rewind/utf8rewind.h
@@ -68,6 +68,7 @@
 #include <stdint.h>
 #include <string.h>
 #include <wchar.h>
+#include <ctype.h>
 #include <sys/types.h>

 /*!
diff --git a/external/utf8rewind/source/utf8rewind.c b/external/utf8rewind/source/utf8rewind.c
index 1a4ff1f24..38b068906 100644
--- a/external/utf8rewind/source/utf8rewind.c
+++ b/external/utf8rewind/source/utf8rewind.c
@@ -432,7 +432,7 @@ size_t utf8toutf16(const char* input, size_t inputSize, utf16_t* target, size_t
 				/* Encoded value is always beyond BMP */

 				decoded -= (MAX_BASIC_MULTILINGUAL_PLANE + 1);
-				*dst++ = SURROGATE_HIGH_START + (decoded >> 10);
+				*dst++ = SURROGATE_HIGH_START + (utf16_t) (decoded >> 10);
 				*dst++ = SURROGATE_LOW_START + (decoded & 0x03FF);

 				dst_size -= 2 * sizeof(utf16_t);
@@ -804,7 +804,7 @@ size_t utf8casefold(const char* input, size_t inputSize, char* target, size_t ta

 			/* Read next code point */

-			if (!(state.last_code_point_size = codepoint_read(state.src, state.src_size, &state.last_code_point)))
+			if (state.last_code_point_size = codepoint_read(state.src, state.src_size, &state.last_code_point), state.last_code_point_size)
 			{
 				goto invaliddata;
 			}
@@ -865,7 +865,7 @@ size_t utf8casefold(const char* input, size_t inputSize, char* target, size_t ta
 			{
 				/* Write code point unchanged to output */

-				if (!(bytes_needed = codepoint_write(state.last_code_point, &state.dst, &state.dst_size)))
+				if (bytes_needed = codepoint_write(state.last_code_point, &state.dst, &state.dst_size), !bytes_needed)
 				{
 					goto outofspace;
 				}
@@ -885,7 +885,7 @@ size_t utf8casefold(const char* input, size_t inputSize, char* target, size_t ta

 			/* Read next code point */

-			if (!(state.last_code_point_size = codepoint_read(state.src, state.src_size, &state.last_code_point)))
+			if (state.last_code_point_size = codepoint_read(state.src, state.src_size, &state.last_code_point), state.last_code_point_size)
 			{
 				goto invaliddata;
 			}
@@ -930,7 +930,7 @@ size_t utf8casefold(const char* input, size_t inputSize, char* target, size_t ta
 			{
 				/* Write code point unchanged to output */

-				if (!(bytes_needed = codepoint_write(state.last_code_point, &state.dst, &state.dst_size)))
+				if (bytes_needed = codepoint_write(state.last_code_point, &state.dst, &state.dst_size), bytes_needed)
 				{
 					goto outofspace;
 				}
@@ -1074,7 +1074,7 @@ size_t utf8normalize(const char* input, size_t inputSize, char* target, size_t t
 	size_t dst_size = targetSize;
 	StreamState stream[4];
 	DecomposeState decompose_state;
-	ComposeState compose_state;
+	ComposeState compose_state = { 0 };
 	uint8_t compatibility = (flags & UTF8_NORMALIZE_COMPATIBILITY) != 0;
 	StreamState* stream_output;
 	uint8_t finished = 0;
diff --git a/libs/std/io.flx b/libs/std/io.flx
index 1f1a8bbd5..1a0317e33 100644
--- a/libs/std/io.flx
+++ b/libs/std/io.flx
@@ -5,9 +5,6 @@
 export std::io
 import libc

-let ASCII_BACKSLASH: i8     = 92
-let ASCII_PERCENT: i8       = 37
-
 fn error(msg: str)
 {
 	libc::printf("invalid format string: '%s'\n", msg)
diff --git a/meson.build b/meson.build
index d35319c5c..6fc0a12e6 100644
--- a/meson.build
+++ b/meson.build
@@ -1,4 +1,4 @@
-project('flax', version: '0.40.0-pre')
+project('flax', version: '0.40.0-pre', default_options: [ 'warning_level=3' ])

 add_languages(['c', 'cpp'])

@@ -12,21 +12,45 @@ if the_compiler.get_id() == 'msvc'
 	add_project_arguments('/permissive-', language: 'cpp')
 	add_project_arguments('-D_STDC_LIMIT_MACROS', language: 'cpp')
 	add_project_arguments('-D_SCL_SECURE_NO_WARNINGS', language: 'cpp')
- 	add_project_arguments('-D_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING', language: 'cpp')
+	add_project_arguments('-D_CRT_SECURE_NO_WARNINGS', language: 'cpp')
+	add_project_arguments('-D_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING', language: 'cpp')
+
+	add_project_arguments('/W4', language: ['c', 'cpp'])
+
+	# disable some useless warnings:
+	add_project_arguments('/wd4100', language: ['c', 'cpp'])    # unused function parameter
+	add_project_arguments('/wd4127', language: ['c', 'cpp'])    # if expression is constant (msvc apparently doesn't understand &&)
+	add_project_arguments('/wd4456', language: ['c', 'cpp'])    # local variable shadowing
+	add_project_arguments('/wd4457', language: ['c', 'cpp'])    # function parameter shadowing
+	add_project_arguments('/wd4458', language: ['c', 'cpp'])    # class member shadowing
+
+	# enable some useful warnings (set them to fire at level 1):
+	add_project_arguments('/w14062', language: ['c', 'cpp'])    # enum value not handled in switch-case
+	add_project_arguments('/w14263', language: ['c', 'cpp'])    # member method hides base method
+	add_project_arguments('/w14265', language: ['c', 'cpp'])    # non-virtual destructor when class has virtual methods
+	add_project_arguments('/w14548', language: ['c', 'cpp'])    # first part of comma-expression has no side-effects
+
+

 	add_project_link_arguments('/ignore:4099', language: ['c', 'cpp'])
 	add_project_link_arguments('/machine:X64', language: 'cpp')
+
+	add_project_link_arguments('/opt:noref', language: 'cpp')
 	add_project_link_arguments('/incremental', language: 'cpp')
-	add_project_link_arguments('/debug:fastlink', language: ['c', 'cpp'])
+
 	add_project_link_arguments('/nodefaultlib:libcmt.lib', language: 'cpp')
 	add_project_link_arguments('/nodefaultlib:libcmtd.lib', language: 'cpp')

 	if get_option('buildtype') == 'debug'
 		libKind = 'Debug'
+		debug_kind = 'fastlink'
 	else
 		libKind = 'Release'
+		debug_kind = 'none'
 	endif

+	add_project_link_arguments('/debug:' + debug_kind, language: ['c', 'cpp'])
+
 	# ok, so because meson is dumb, and we want to allow configuring the locations *without* editing this file
 	# eg. in CI environments, we run an external command that's just an echo of the environment variable, and
 	# capture the output to use. all because it's apparently "a bad idea" to allow people to read env vars...
@@ -126,6 +150,7 @@ if the_compiler.get_id() == 'msvc'
 	)

 	all_deps = [ legacy_stdio_dep, mpir_dep, mpfr_dep, libffi_dep, llvm_dep ]
+
 else
 	add_project_arguments('-std=c11', language: 'c')
 	add_project_arguments('-std=c++17', language: 'cpp')
@@ -146,6 +171,7 @@ else
 	])

 	all_deps = [ mpfr_dep, libffi_dep, llvm_dep ]
+
 endif


@@ -228,6 +254,7 @@ source_files = files([
 	'source/typecheck/resolver/driver.cpp',
 	'source/typecheck/resolver/resolver.cpp',

+	'source/codegen/raii.cpp',
 	'source/codegen/misc.cpp',
 	'source/codegen/call.cpp',
 	'source/codegen/loops.cpp',
@@ -320,7 +347,8 @@ tinyproclib_dep = declare_dependency(include_directories: include_directories('e

 executable('flaxc', source_files,
 	include_directories: include_directories([ 'source/include', 'external' ]),
-	dependencies: all_deps + [ tinyproclib_dep, utf8rewind_dep ]
+	dependencies: all_deps + [ tinyproclib_dep, utf8rewind_dep ],
+	cpp_pch: 'source/include/precompile.h'
 )


diff --git a/source/backend/llvm/linker.cpp b/source/backend/llvm/linker.cpp
index 745ca5563..585fc0d60 100644
--- a/source/backend/llvm/linker.cpp
+++ b/source/backend/llvm/linker.cpp
@@ -12,12 +12,13 @@
 #define __STDC_LIMIT_MACROS
 #endif

-
 #include <fstream>

+
 #ifdef _MSC_VER
 	#pragma warning(push, 0)
 	#pragma warning(disable: 4267)
+	#pragma warning(disable: 4244)
 #endif

 #include "llvm/IR/Verifier.h"
diff --git a/source/backend/llvm/translator.cpp b/source/backend/llvm/translator.cpp
index 99b01897d..09667d274 100644
--- a/source/backend/llvm/translator.cpp
+++ b/source/backend/llvm/translator.cpp
@@ -562,7 +562,7 @@ namespace backend


 		auto decay = [&builder](fir::Value* fv, llvm::Value* lv) -> llvm::Value* {
-			if(fv->islorclvalue())
+			if(fv->islvalue())
 				return builder.CreateLoad(lv);

 			else
diff --git a/source/codegen/alloc.cpp b/source/codegen/alloc.cpp
index 6d9edaca8..77b946335 100644
--- a/source/codegen/alloc.cpp
+++ b/source/codegen/alloc.cpp
@@ -61,71 +61,63 @@ static fir::Value* performAllocation(cgn::CodegenState* cs, sst::AllocOp* alloc,
 			iceAssert(alloc->initBlockVar);

 			// ok, then. create the variables:
-			cs->addVariableUsingStorage(alloc->initBlockIdx, idxp, CGResult(0));
-			cs->addVariableUsingStorage(alloc->initBlockVar, elmp, CGResult(0));
+			cs->addVariableUsingStorage(alloc->initBlockIdx, idxp);
+			cs->addVariableUsingStorage(alloc->initBlockVar, elmp);

 			alloc->initBlock->codegen(cs);
 		};



-		{
-			auto arrp = ptr;
-			auto ctrp = cs->irb.CreateLValue(fir::Type::getNativeWord());
-
-			auto actuallyStore = [cs, type, alloc](fir::Value* ptr) -> void {
-
-				if(type->isClassType())
-				{
-					auto constr = dcast(sst::FunctionDefn, alloc->constructor);
-					iceAssert(constr);
-
-					//! here, the arguments are called once per element.
-					cs->constructClassWithArguments(type->toClassType(), constr, ptr, alloc->arguments, true);
-				}
-				else if(type->isStructType())
-				{
-					auto value = cs->getConstructedStructValue(type->toStructType(), alloc->arguments);
-					cs->autoAssignRefCountedValue(ptr, value, true, true);
-				}
-				else
-				{
-					//! ACHTUNG !
-					//* hack: the only reason to add to the refcount table is so we can remove it later
-					//* when we move-assign below.

-					auto value = cs->getDefaultValue(type);
+		auto arrp = ptr;
+		auto ctrp = cs->irb.CreateLValue(fir::Type::getNativeWord());

-					if(fir::isRefCountedType(type))
-						cs->addRefCountedValue(value);
-
-					cs->autoAssignRefCountedValue(ptr, value, true, true);
-				}
-			};
+		auto actuallyStore = [cs, type, alloc](fir::Value* ptr) -> void {

+			if(type->isClassType())
+			{
+				auto constr = dcast(sst::FunctionDefn, alloc->constructor);
+				iceAssert(constr);

-			if(alloc->counts.empty())
+				//! here, the arguments are called once per element.
+				auto value = cs->constructClassWithArguments(type->toClassType(), constr, alloc->arguments);
+				cs->autoAssignRefCountedValue(cs->irb.Dereference(ptr), value, true);
+			}
+			else if(type->isStructType())
 			{
-				actuallyStore(arrp);
+				auto value = cs->getConstructedStructValue(type->toStructType(), alloc->arguments);
+				cs->autoAssignRefCountedValue(cs->irb.Dereference(ptr), value, true);
 			}
 			else
 			{
-				cs->createWhileLoop([cs, ctrp, count](auto pass, auto fail) {
-					auto cond = cs->irb.ICmpLT(ctrp, count);
-					cs->irb.CondBranch(cond, pass, fail);
-				},
-				[cs, callUserCode, actuallyStore, alloc, ctrp, arrp]() {
+				auto value = cs->getDefaultValue(type);
+				cs->autoAssignRefCountedValue(cs->irb.Dereference(ptr), value, true);
+			}
+		};

-					auto ptr = cs->irb.GetPointer(arrp, ctrp);

-					actuallyStore(ptr);
+		if(alloc->counts.empty())
+		{
+			actuallyStore(arrp);
+		}
+		else
+		{
+			cs->createWhileLoop([cs, ctrp, count](auto pass, auto fail) {
+				auto cond = cs->irb.ICmpLT(ctrp, count);
+				cs->irb.CondBranch(cond, pass, fail);
+			},
+			[cs, callUserCode, actuallyStore, alloc, ctrp, arrp]() {

-					if(alloc->initBlock)
-						callUserCode(cs->irb.Dereference(ptr), ctrp);
+				auto ptr = cs->irb.GetPointer(arrp, ctrp);

-					cs->irb.Store(cs->irb.Add(ctrp, fir::ConstantInt::getNative(1)), ctrp);
-				});
-			}
+				actuallyStore(ptr);
+
+				if(alloc->initBlock)
+					callUserCode(cs->irb.Dereference(ptr), ctrp);
+
+				cs->irb.Store(cs->irb.Add(ctrp, fir::ConstantInt::getNative(1)), ctrp);
+			});
 		}
 	};

diff --git a/source/codegen/arithmetic.cpp b/source/codegen/arithmetic.cpp
index ae14b6b69..b4120deb4 100644
--- a/source/codegen/arithmetic.cpp
+++ b/source/codegen/arithmetic.cpp
@@ -241,7 +241,7 @@ namespace sst
 		}
 		else if(this->op == Operator::AddressOf)
 		{
-			if(!val->islorclvalue())
+			if(!val->islvalue())
 				error(this, "cannot take address of a non-lvalue");

 			else if(val->getType()->isFunctionType())
diff --git a/source/codegen/assign.cpp b/source/codegen/assign.cpp
index c985e73f4..f663e53fa 100644
--- a/source/codegen/assign.cpp
+++ b/source/codegen/assign.cpp
@@ -18,13 +18,13 @@ CGResult sst::AssignOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	auto lr = this->left->codegen(cs).value;
 	auto lt = lr->getType();

-	if(!lr->islorclvalue())
+	if(!lr->islvalue())
 	{
 		SpanError::make(SimpleError::make(this->loc, "cannot assign to non-lvalue (most likely a temporary) expression"))
 			->add(util::ESpan(this->left->loc, "here"))
 			->postAndQuit();
 	}
-	else if(lr->isclvalue())
+	else if(lr->isConst())
 	{
 		SpanError::make(SimpleError::make(this->loc, "cannot assign to immutable expression"))
 			->add(util::ESpan(this->left->loc, "here"))
@@ -124,7 +124,7 @@ CGResult sst::AssignOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	if(lt != rr->getType())
 		error(this, "what? left = %s, right = %s", lt, rr->getType());

-	cs->autoAssignRefCountedValue(lr, rr, /* isInitial: */ false, /* performStore: */ true);
+	cs->autoAssignRefCountedValue(lr, rr, /* isInitial: */ false);
 	return CGResult(0);
 }

@@ -168,7 +168,7 @@ CGResult sst::TupleAssignOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 				val->getType(), lr.value->getType());
 		}

-		cs->autoAssignRefCountedValue(lr.value, rr, /* isInitial: */ false, /* performStore: */ true);
+		cs->autoAssignRefCountedValue(lr.value, rr, /* isInitial: */ false);
 	}

 	return CGResult(0);
diff --git a/source/codegen/autocasting.cpp b/source/codegen/autocasting.cpp
index 2549fd9a3..56b40f427 100644
--- a/source/codegen/autocasting.cpp
+++ b/source/codegen/autocasting.cpp
@@ -235,11 +235,7 @@ namespace cgn

 		if(!result)
 		{
-			// nope.
-			//! ACHTUNG !
-			//* ew, goto.
 			error(this->loc(), "unsupported autocast of '%s' -> '%s'", fromType, target);
-			return 0;
 		}
 		else
 		{
diff --git a/source/codegen/call.cpp b/source/codegen/call.cpp
index 4a799f5b0..e462ce2d0 100644
--- a/source/codegen/call.cpp
+++ b/source/codegen/call.cpp
@@ -79,7 +79,8 @@ static std::vector<fir::Value*> _codegenAndArrangeFunctionCallArguments(cgn::Cod
 		if(argExprs.find(i) == argExprs.end())
 		{
 			auto it = defaultArgumentValues.find(i);
-			iceAssert(it != defaultArgumentValues.end());
+			if(it == defaultArgumentValues.end())
+				error(cs->loc(), "missing value for argument %d", i);

 			argExprs[i] = it->second;
 			revArgExprs[it->second] = i;
@@ -130,6 +131,12 @@ static std::vector<fir::Value*> _codegenAndArrangeFunctionCallArguments(cgn::Cod
 			auto infer = ft->getArgumentN(k);
 			auto val = arg->codegen(cs, infer).value;

+			//! RAII: COPY CONSTRUCTOR CALL
+			//? the copy constructor is called when passed as an argument to a function call
+			//* copyRAIIValue will just return 'val' if it is not a class type, so we don't check it here!
+			val = cs->copyRAIIValue(val);
+
+
 			//* arguments are added to the refcounting list in the function,
 			//* so we need to "pre-increment" the refcount here, so it does not
 			//* get freed when the function returns.
@@ -305,13 +312,6 @@ CGResult sst::FunctionCall::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	}

 	size_t numArgs = ft->getArgumentCount();
-	/* if(!ft->isCStyleVarArg() && !ft->isVariadicFunc() && this->arguments.size() != numArgs)
-	{
-		error(this, "mismatch in number of arguments in call to '%s'; %zu %s provided, but %zu %s expected",
-			this->name, this->arguments.size(), this->arguments.size() == 1 ? "was" : "were", numArgs,
-			numArgs == 1 ? "was" : "were");
-	}
-	else if((ft->isCStyleVarArg() || !ft->isVariadicFunc()) && this->arguments.size() < numArgs) */
 	if(ft->isCStyleVarArg() && this->arguments.size() < numArgs)
 	{
 		error(this, "need at least %zu arguments to call variadic function '%s', only have %zu",
@@ -343,6 +343,9 @@ CGResult sst::FunctionCall::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	if(fir::isRefCountedType(ret->getType()))
 		cs->addRefCountedValue(ret);

+	if(ret->getType()->isClassType())
+		cs->addRAIIValue(ret);
+
 	return CGResult(ret);
 }

@@ -414,7 +417,6 @@ CGResult sst::ExprCall::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	if(auto te = dcast(sst::TypeExpr, this->callee))
 		return callBuiltinTypeConstructor(cs, te->type, this->arguments);

-
 	fir::Value* fn = this->callee->codegen(cs).value;
 	iceAssert(fn->getType()->isFunctionType());

@@ -436,6 +438,13 @@ CGResult sst::ExprCall::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	std::vector<fir::Value*> args = cs->codegenAndArrangeFunctionCallArguments(/* targetDefn: */ nullptr, ft, fcas);

 	auto ret = cs->irb.CallToFunctionPointer(fn, ft, args);
+
+	if(fir::isRefCountedType(ret->getType()))
+		cs->addRefCountedValue(ret);
+
+	if(ret->getType()->isClassType())
+		cs->addRAIIValue(ret);
+
 	return CGResult(ret);
 }

diff --git a/source/codegen/classes.cpp b/source/codegen/classes.cpp
index 43b40cadd..f63b4f4ad 100644
--- a/source/codegen/classes.cpp
+++ b/source/codegen/classes.cpp
@@ -37,14 +37,14 @@ CGResult sst::ClassDefn::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		auto f = dcast(fir::Function, res.value);
 		meths.push_back(f);

-		if(method->id.name == "init")
-			inits.push_back(f);
-
 		if(method->isVirtual)
 			clsty->addVirtualMethod(f);
-	}
-

+		if(method->id.name == "init")   inits.push_back(f);
+		if(method->id.name == "deinit") clsty->setDestructor(f);
+		if(method->id.name == "copy")   clsty->setCopyConstructor(f);
+		if(method->id.name == "move")   clsty->setMoveConstructor(f);
+	}

 	clsty->setMethods(meths);
 	clsty->setInitialiserFunctions(inits);
@@ -60,8 +60,11 @@ CGResult sst::ClassDefn::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		nt->codegen(cs);


-	// basically we make a function.
 	auto restore = cs->irb.getCurrentBlock();
+
+
+
+	// make the inline initialiser
 	{
 		fir::Function* func = cs->module->getOrCreateFunction(Identifier(this->id.mangled() + "_inline_init", IdKind::Name),
 			fir::FunctionType::get({ this->type->getMutablePointerTo() }, fir::Type::getVoid()),
@@ -95,20 +98,55 @@ CGResult sst::ClassDefn::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 				auto res = fd->init->codegen(cs, fd->type).value;
 				auto elmptr = cs->irb.GetStructMember(self, fd->id.name);

-				cs->autoAssignRefCountedValue(elmptr, res, true, true);
+				cs->autoAssignRefCountedValue(elmptr, res, true);
 			}
 			else
 			{
 				auto elmptr = cs->irb.GetStructMember(self, fd->id.name);
-				cs->autoAssignRefCountedValue(elmptr, cs->getDefaultValue(fd->type), true, true);
+				cs->autoAssignRefCountedValue(elmptr, cs->getDefaultValue(fd->type), true);
 			}
 		}

 		cs->irb.ReturnVoid();
-		this->inlineInitFunction = func;
-
 		clsty->setInlineInitialiser(func);
 	}
+
+	// this is the inline destructor
+	{
+		fir::Function* func = cs->module->getOrCreateFunction(Identifier(this->id.mangled() + "_inline_deinit", IdKind::Name),
+			fir::FunctionType::get({ this->type->getMutablePointerTo() }, fir::Type::getVoid()),
+			fir::LinkageType::Internal);
+
+		fir::IRBlock* entry = cs->irb.addNewBlockInFunction("entry", func);
+		cs->irb.setCurrentBlock(entry);
+
+		auto selfptr = func->getArguments()[0];
+		auto self = cs->irb.Dereference(selfptr, "this");
+
+		for(auto f : this->fields)
+		{
+			if(f->type->isClassType())
+			{
+				auto fld = cs->irb.GetStructMember(self, f->id.name);
+				cs->callDestructor(fld);
+			}
+		}
+
+		// ok, now that we have destroyed our own fields, call the base class destructor, followed by the base class inline destructor!
+		if(auto base = clsty->getBaseClass(); base)
+		{
+			auto baseptr = cs->irb.PointerTypeCast(selfptr, base->getMutablePointerTo());
+
+			if(auto des = base->getDestructor(); des)
+				cs->irb.Call(des, baseptr);
+
+			cs->irb.Call(base->getInlineDestructor(), baseptr);
+		}
+
+		cs->irb.ReturnVoid();
+		clsty->setInlineDestructor(func);
+	}
+
 	cs->irb.setCurrentBlock(restore);


@@ -132,7 +170,7 @@ fir::Value* cgn::CodegenState::callVirtualMethod(sst::FunctionCall* call)
 		iceAssert(this->isInMethodBody() && fd->parentTypeForMethod);

 		auto fake = util::pool<sst::RawValueExpr>(call->loc, fd->parentTypeForMethod->getPointerTo());
-		fake->rawValue = CGResult(this->getMethodSelf());
+		fake->rawValue = CGResult(this->irb.AddressOf(this->getMethodSelf(), /* mutable: */ true));

 		//! SELF HANDLING (INSERTION) (CODEGEN)
 		call->arguments.insert(call->arguments.begin(), FnCallArgument(call->loc, "this", fake, 0));
diff --git a/source/codegen/codegenstate.cpp b/source/codegen/codegenstate.cpp
index 478cb34fe..4ad845fc2 100644
--- a/source/codegen/codegenstate.cpp
+++ b/source/codegen/codegenstate.cpp
@@ -14,8 +14,6 @@ namespace cgn
 	{
 		this->methodSelfStack.push_back(self);

-		iceAssert(self->islorclvalue());
-
 		auto ty = self->getType();
 		iceAssert(ty->isClassType() || ty->isStructType());

@@ -211,7 +209,10 @@ namespace cgn
 		}
 		else if(type->isClassType())
 		{
-			auto clsdef = this->typeDefnMap[type];
+			// TODO
+			//! use constructClassWithArguments!!!
+
+			auto clsdef = dcast(sst::ClassDefn, this->typeDefnMap[type]);
 			iceAssert(clsdef);

 			clsdef->codegen(this);
@@ -219,11 +220,11 @@ namespace cgn
 			// first need to check if we have any initialisers with 0 parameters.
 			auto cls = type->toClassType();

-			fir::Function* ifn = 0;
-			for(auto init : cls->getInitialiserFunctions())
+			sst::FunctionDefn* ifn = 0;
+			for(auto init : clsdef->initialisers)
 			{
 				//* note: count == 1 because of 'self'
-				if(init->getArgumentCount() == 1)
+				if(init->arguments.size() == 1)
 				{
 					ifn = init;
 					break;
@@ -237,20 +238,17 @@ namespace cgn
 					->postAndQuit();
 			}

-			// ok, we call it.
-			auto self = this->irb.StackAlloc(cls);
-
-			this->irb.Call(cls->getInlineInitialiser(), self);
-			this->irb.Call(ifn, self);
-
-			ret = this->irb.ReadPtr(self);
+			ret = this->constructClassWithArguments(cls, ifn, { });
 		}
 		else
 		{
 			ret = fir::ConstantValue::getZeroValue(type);
 		}

-		ret->setKind(fir::Value::Kind::literal);
+		if(fir::isRefCountedType(type))
+			this->addRefCountedValue(ret);
+
+		ret->setKind(fir::Value::Kind::prvalue);
 		return ret;
 	}

diff --git a/source/codegen/constructor.cpp b/source/codegen/constructor.cpp
index 7916e05d4..878db30fb 100644
--- a/source/codegen/constructor.cpp
+++ b/source/codegen/constructor.cpp
@@ -36,8 +36,6 @@ fir::Value* cgn::CodegenState::getConstructedStructValue(fir::StructType* str, c

 			i++;
 		}
-
-		// if(names) iceAssert(i == str->getElementCount());
 	}

 	if(fir::isRefCountedType(str))
@@ -48,8 +46,7 @@ fir::Value* cgn::CodegenState::getConstructedStructValue(fir::StructType* str, c



-void cgn::CodegenState::constructClassWithArguments(fir::ClassType* cls, sst::FunctionDefn* constr,
-	fir::Value* selfptr, const std::vector<FnCallArgument>& args, bool callInlineInit)
+fir::Value* cgn::CodegenState::constructClassWithArguments(fir::ClassType* cls, sst::FunctionDefn* constr, const std::vector<FnCallArgument>& args)
 {
 	if(auto c = this->typeDefnMap[cls])
 		c->codegen(this);
@@ -60,31 +57,76 @@ void cgn::CodegenState::constructClassWithArguments(fir::ClassType* cls, sst::Fu
 	auto constrfn = dcast(fir::Function, constr->codegen(this, cls).value);
 	iceAssert(constrfn);

-	// make a copy
-	auto arguments = args;
+	// this is dirty, very fucking dirty!!!
+	std::vector<fir::Value*> vargs;
 	{
-		auto fake = util::pool<sst::RawValueExpr>(this->loc(), cls->getPointerTo());
-		fake->rawValue = CGResult(selfptr);
+		auto copy = args;
+		auto fake = util::pool<sst::RawValueExpr>(this->loc(), cls->getMutablePointerTo());
+		fake->rawValue = CGResult(fir::ConstantValue::getZeroValue(cls->getMutablePointerTo()));
+
+		//? what we are doing here is inserting a fake argument to placate `codegenAndArrangeFunctionCallArguments`, so that
+		//? it does not error. this just allows us to get *THE REST* of the values in the correct order and generated appropriately,
+		//? so that we can use their values and get their types below.
+
+		copy.insert(copy.begin(), FnCallArgument(this->loc(), "this", fake, 0));
+		vargs = this->codegenAndArrangeFunctionCallArguments(constr, constrfn->getType(), copy);
+
+		// for sanity, assert that it did not change. We should not have to cast anything, and "this" is always the first
+		// argument in a constructor anyway!
+		iceAssert(vargs[0] == fake->rawValue.value);

-		//! SELF HANDLING (INSERTION) (CODEGEN)
-		arguments.insert(arguments.begin(), FnCallArgument(this->loc(), "this", fake, 0));
+		// after we are done with that shennanigans, erase the first thing, which is the 'this', which doesn't really
+		// exist here!
+		vargs.erase(vargs.begin());
 	}


-	if(arguments.size() != constrfn->getArgumentCount())
+	// make a wrapper...
+	auto fname = util::obfuscateIdentifier("init_wrapper", constr->id.str());
+	fir::Function* wrapper_func = this->module->getFunction(fname);
+
+	if(!wrapper_func)
+	{
+		auto restore = this->irb.getCurrentBlock();
+
+		auto arglist = util::map(vargs, [](fir::Value* v) -> auto {
+			return v->getType();
+		});
+
+		wrapper_func = this->module->getOrCreateFunction(fname, fir::FunctionType::get(arglist, cls), fir::LinkageType::Internal);
+
+		fir::IRBlock* entry = this->irb.addNewBlockInFunction("entry", wrapper_func);
+		this->irb.setCurrentBlock(entry);
+
+		// make the self:
+		auto selfptr = this->irb.StackAlloc(cls, "self");
+
+		std::vector<fir::Value*> argvals = util::map(wrapper_func->getArguments(), [](auto a) -> fir::Value* {
+			return a;
+		});
+
+		argvals.insert(argvals.begin(), selfptr);
+
+		this->irb.Call(initfn, selfptr);
+
+		this->irb.Call(constrfn, argvals);
+		this->irb.Return(this->irb.ReadPtr(selfptr));
+
+		this->irb.setCurrentBlock(restore);
+	}
+
+	if(vargs.size() != wrapper_func->getArgumentCount())
 	{
 		SimpleError::make(this->loc(), "mismatched number of arguments in constructor call to class '%s'; expected %d, found %d instead",
-			(fir::Type*) cls, constrfn->getArgumentCount(), arguments.size())
+			(fir::Type*) cls, constrfn->getArgumentCount(), vargs.size())
 			->append(SimpleError::make(MsgType::Note, constr->loc, "constructor was defined here:"))
 			->postAndQuit();
 	}

-	std::vector<fir::Value*> vargs = this->codegenAndArrangeFunctionCallArguments(constr, constrfn->getType(), arguments);
+	auto ret = this->irb.Call(wrapper_func, vargs);
+	this->addRAIIValue(ret);

-	if(callInlineInit)
-		this->irb.Call(initfn, selfptr);
-
-	this->irb.Call(constrfn, vargs);
+	return ret;
 }


@@ -124,16 +166,13 @@ CGResult sst::ClassConstructorCall::_codegen(cgn::CodegenState* cs, fir::Type* i

 	this->classty->codegen(cs);

-	auto cls = this->classty->type;
-	auto self = cs->irb.CreateLValue(cls);
+	auto cls = this->classty->type->toClassType();
+	auto ret = cs->constructClassWithArguments(cls, this->target, this->arguments);

-	cs->constructClassWithArguments(cls->toClassType(), this->target, cs->irb.AddressOf(self, true), this->arguments, true);
-
-	// auto value = cs->irb.Dereference(self);
 	if(fir::isRefCountedType(cls))
-		cs->addRefCountedValue(self);
+		cs->addRefCountedValue(ret);

-	return CGResult(self);
+	return CGResult(ret);
 }


@@ -146,19 +185,34 @@ CGResult sst::BaseClassConstructorCall::_codegen(cgn::CodegenState* cs, fir::Typ
 	this->classty->codegen(cs);

 	auto cls = this->classty->type;
-	auto self = cs->irb.AddressOf(cs->getMethodSelf(), true);
+	auto self = cs->getMethodSelf();

-	iceAssert(self->getType()->isPointerType() && self->getType()->getPointerElementType()->isClassType());
+	iceAssert(self->getType()->isClassType());

-	auto selfty = self->getType()->getPointerElementType()->toClassType();
+	auto selfty = self->getType()->toClassType();
 	iceAssert(selfty->getBaseClass());

-	selfty = selfty->getBaseClass();
-	self = cs->irb.PointerTypeCast(self, selfty->getPointerTo());
+	auto basety = selfty->getBaseClass();
+
+	// just do it manually here: since we already have a self pointer, we can call the base class constructor function
+	// directly. plus, we are not calling the inline initialiser also.
+	{
+		auto constrfn = dcast(fir::Function, this->target->codegen(cs, cls).value);
+		iceAssert(constrfn);
+
+		auto copy = this->arguments;
+		auto selfptr = util::pool<RawValueExpr>(this->loc, selfty->getMutablePointerTo());
+		selfptr->rawValue = CGResult(cs->irb.PointerTypeCast(cs->irb.AddressOf(cs->getMethodSelf(), /* mutable: */ true),
+			basety->getMutablePointerTo()));
+
+		copy.insert(copy.begin(), FnCallArgument(this->loc, "this", selfptr, 0));
+
+		std::vector<fir::Value*> vargs = cs->codegenAndArrangeFunctionCallArguments(this->target, constrfn->getType(), copy);

-	//* note: we don't call the inline initialiser of the base class, because the inline initialiser of our own class would've already called it.
-	cs->constructClassWithArguments(cls->toClassType(), this->target, self, this->arguments, false);
-	return CGResult(self);
+		cs->irb.Call(constrfn, vargs);
+	}
+
+	return CGResult(0);
 }


@@ -171,3 +225,28 @@ CGResult sst::BaseClassConstructorCall::_codegen(cgn::CodegenState* cs, fir::Typ



+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/source/codegen/controlflow.cpp b/source/codegen/controlflow.cpp
index d660b6906..4bbbe74b5 100644
--- a/source/codegen/controlflow.cpp
+++ b/source/codegen/controlflow.cpp
@@ -183,13 +183,12 @@ static void doBlockEndThings(cgn::CodegenState* cs, const cgn::ControlFlowPoint&
 	for(auto stmt : cfp.block->deferred)
 		stmt->codegen(cs);

+	for(auto c : bp.raiiValues)
+		cs->callDestructor(c);
+
 	for(auto v : bp.refCountedValues)
 		cs->decrementRefCount(v);

-	for(auto p : bp.refCountedPointers)
-		cs->decrementRefCount(cs->irb.ReadPtr(p));
-
-
 	#if DEBUG_ARRAY_REFCOUNTING | DEBUG_STRING_REFCOUNTING
 	{
 		cs->popIRDebugIndentation();
@@ -241,11 +240,16 @@ CGResult sst::ReturnStmt::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		if(fir::isRefCountedType(v->getType()))
 			cs->incrementRefCount(v);

-		doBlockEndThings(cs, cs->getCurrentCFPoint(), cs->getCurrentBlockPoint());
-
 		if(v->getType() != this->expectedType)
 			v = cs->oneWayAutocast(v, this->expectedType);

+		//! RAII: COPY CONSTRUCTOR CALL
+		//? the copy constructor is called when a function returns an object by value
+		if(v->getType()->isClassType())
+			v = cs->copyRAIIValue(v);
+
+		doBlockEndThings(cs, cs->getCurrentCFPoint(), cs->getCurrentBlockPoint());
+
 		cs->irb.Return(v);
 	}
 	else
@@ -289,7 +293,6 @@ CGResult sst::Block::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	if(this->postBodyCode)
 		this->postBodyCode();

-
 	if(!broke)
 	{
 		#if DEBUG_ARRAY_REFCOUNTING | DEBUG_STRING_REFCOUNTING
@@ -299,17 +302,16 @@ CGResult sst::Block::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		}
 		#endif

+		//* this duplicates stuff from doBlockEndThings!!
 		for(auto it = this->deferred.rbegin(); it != this->deferred.rend(); it++)
 			(*it)->codegen(cs);

-		// then decrement all the refcounts
+		for(auto c : cs->getCurrentBlockPoint().raiiValues)
+			cs->callDestructor(c);
+
 		for(auto v : cs->getRefCountedValues())
 			cs->decrementRefCount(v);

-		for(auto p : cs->getRefCountedPointers())
-			cs->decrementRefCount(cs->irb.ReadPtr(p));
-
-
 		#if DEBUG_ARRAY_REFCOUNTING | DEBUG_STRING_REFCOUNTING
 		{
 			cs->popIRDebugIndentation();
diff --git a/source/codegen/destructure.cpp b/source/codegen/destructure.cpp
index 15cf65fbc..037fe84ec 100644
--- a/source/codegen/destructure.cpp
+++ b/source/codegen/destructure.cpp
@@ -62,7 +62,7 @@ static void checkTuple(cgn::CodegenState* cs, const DecompMapping& bind, CGResul
 	{
 		CGResult v;

-		if(rhs->islorclvalue())
+		if(rhs->islvalue())
 		{
 			auto gep = cs->irb.StructGEP(rhs.value, i);
 			v = CGResult(gep);
@@ -161,7 +161,7 @@ static void checkArray(cgn::CodegenState* cs, const DecompMapping& bind, CGResul
 		}

 		// # if 0
-		if(!rhs->islorclvalue() && rt->isArrayType())
+		if(!rhs->islvalue() && rt->isArrayType())
 		{
 			//* because of the way LLVM is designed, and hence by extension how we are designed,
 			//* fixed-sized arrays are kinda dumb. If we don't have a pointer to the array (for whatever reason???),
diff --git a/source/codegen/dotop.cpp b/source/codegen/dotop.cpp
index 5454b4c5b..7006b0a02 100644
--- a/source/codegen/dotop.cpp
+++ b/source/codegen/dotop.cpp
@@ -101,7 +101,7 @@ CGResult sst::FieldDotOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		if(this->lhs->type->isRawUnionType())
 		{
 			fir::Value* field = 0;
-			if(res->islorclvalue())
+			if(res->islvalue())
 			{
 				field = cs->irb.GetRawUnionFieldByType(res.value, this->type);
 			}
@@ -115,7 +115,7 @@ CGResult sst::FieldDotOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		}
 		else
 		{
-			if(res->islorclvalue())
+			if(res->islvalue())
 			{
 				// ok, at this point it's just a normal, instance field.
 				return CGResult(cs->irb.StructGEP(res.value, this->indexOfTransparentField));
@@ -132,7 +132,7 @@ CGResult sst::FieldDotOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		if(this->lhs->type->isRawUnionType())
 		{
 			fir::Value* field = 0;
-			if(res->islorclvalue())
+			if(res->islvalue())
 			{
 				field = cs->irb.GetRawUnionField(res.value, this->rhsIdent);
 			}
@@ -146,7 +146,7 @@ CGResult sst::FieldDotOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		}
 		else
 		{
-			if(res->islorclvalue())
+			if(res->islvalue())
 			{
 				// ok, at this point it's just a normal, instance field.
 				return CGResult(cs->irb.GetStructMember(res.value, this->rhsIdent));
@@ -178,7 +178,7 @@ CGResult sst::TupleDotOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)

 	// ok, if we have a pointer, then return an lvalue
 	// if not, return an rvalue
-	if(res->islorclvalue())
+	if(res->islvalue())
 	{
 		return CGResult(cs->irb.StructGEP(res.value, this->index));
 	}
diff --git a/source/codegen/function.cpp b/source/codegen/function.cpp
index 0a3623da2..b7a7b503f 100644
--- a/source/codegen/function.cpp
+++ b/source/codegen/function.cpp
@@ -145,10 +145,16 @@ CGResult sst::ArgumentDefn::_codegen(cgn::CodegenState* cs, fir::Type* infer)

 	auto fn = cs->getCurrentFunction();

-	auto arg = cs->irb.CreateConstLValue(fn->getArgumentWithName(this->id.name), this->id.name);
+	auto arg = cs->irb.CreateLValue(this->type, this->id.name);
+	cs->irb.Store(fn->getArgumentWithName(this->id.name), arg);
+	arg->makeConst();
+
 	if(fir::isRefCountedType(arg->getType()))
 		cs->addRefCountedValue(arg);

+	if(arg->getType()->isClassType())
+		cs->addRAIIValue(arg);
+
 	// ok...
 	cs->valueMap[this] = CGResult(arg);
 	return CGResult(arg);
diff --git a/source/codegen/glue/arrays.cpp b/source/codegen/glue/arrays.cpp
index c27135263..33d29c5f6 100644
--- a/source/codegen/glue/arrays.cpp
+++ b/source/codegen/glue/arrays.cpp
@@ -91,7 +91,10 @@ namespace array
 				auto ctr = cs->irb.ReadPtr(ctrptr);
 				auto ptr = cs->irb.GetPointer(arrdata, ctr);

-				cs->constructClassWithArguments(cls, constr, ptr, args, true);
+				auto val = cs->constructClassWithArguments(cls, constr, args);
+
+				// TODO: this is a bit dubious??
+				cs->irb.WritePtr(val, ptr);

 				cs->irb.WritePtr(cs->irb.Add(ctr, fir::ConstantInt::getNative(1)), ctrptr);

@@ -155,7 +158,7 @@ namespace array
 				auto ctr = cs->irb.ReadPtr(ctrptr);
 				auto ptr = cs->irb.GetPointer(arrdata, ctr);

-				cs->autoAssignRefCountedValue(ptr, value, true, true);
+				cs->autoAssignRefCountedValue(ptr, value, true);

 				cs->irb.WritePtr(cs->irb.Add(ctr, fir::ConstantInt::getNative(1)), ctrptr);

diff --git a/source/codegen/glue/saa_common.cpp b/source/codegen/glue/saa_common.cpp
index 2d83081dc..da0604762 100644
--- a/source/codegen/glue/saa_common.cpp
+++ b/source/codegen/glue/saa_common.cpp
@@ -679,6 +679,13 @@ namespace saa_common
 					if(saa->isStringType())
 						newbytecount = cs->irb.Add(newbytecount, getCI(1));

+					// for "default" or empty strings, the buffer points to constant memory that did not come from the heap!!
+					// so, we cannot call realloc with oldbuf, and call it with NULL instead. we do this if the capacity was 0!
+					{
+						auto isfake = cs->irb.ICmpEQ(oldcap, getCI(0));
+						oldbuf = cs->irb.Select(isfake, fir::ConstantValue::getZeroValue(fir::Type::getMutInt8Ptr()), oldbuf);
+					}
+
 					auto newbuf = cs->irb.Call(cs->getOrDeclareLibCFunction(REALLOCATE_MEMORY_FUNC), oldbuf, newbytecount, "newbuf");
 					newbuf = castRawBufToElmPtr(cs, saa, newbuf);

diff --git a/source/codegen/glue/strings.cpp b/source/codegen/glue/strings.cpp
index 6289251bc..5f0e8ea77 100644
--- a/source/codegen/glue/strings.cpp
+++ b/source/codegen/glue/strings.cpp
@@ -333,8 +333,8 @@ namespace string
 				// if statement
 				auto ch = cs->irb.ReadPtr(cs->irb.ReadPtr(ptrp));

-				auto mask = cs->irb.BitwiseAND(ch, fir::ConstantInt::getInt8((int8_t) 0xC0));
-				auto isch = cs->irb.ICmpNEQ(mask, fir::ConstantInt::getInt8((int8_t) 0x80));
+				auto mask = cs->irb.BitwiseAND(ch, cs->irb.IntSizeCast(fir::ConstantInt::getUint8(0xC0), fir::Type::getInt8()));
+				auto isch = cs->irb.ICmpNEQ(mask, cs->irb.IntSizeCast(fir::ConstantInt::getUint8(0x80), fir::Type::getInt8()));

 				fir::IRBlock* incr = cs->irb.addNewBlockInFunction("incr", func);
 				fir::IRBlock* skip = cs->irb.addNewBlockInFunction("skip", func);
diff --git a/source/codegen/loops.cpp b/source/codegen/loops.cpp
index 9f306a526..a3f6e9d25 100644
--- a/source/codegen/loops.cpp
+++ b/source/codegen/loops.cpp
@@ -243,8 +243,16 @@ CGResult sst::ForeachLoop::_codegen(cgn::CodegenState* cs, fir::Type* inferred)
 		else if(array->getType()->isArrayType())
 		{
 			fir::Value* arrptr = 0;
-			if(array->islorclvalue())   arrptr = cs->irb.AddressOf(array, false);
-			else                        arrptr = cs->irb.CreateConstLValue(array);
+			if(array->islvalue())
+			{
+				arrptr = cs->irb.AddressOf(array, false);
+			}
+			else
+			{
+				arrptr = cs->irb.CreateLValue(array->getType());
+				cs->irb.Store(array, arrptr);
+				arrptr->makeConst();
+			}

 			theptr = cs->irb.GetPointer(cs->irb.ConstGEP2(arrptr, 0, 0), cs->irb.ReadPtr(idxptr));
 		}
diff --git a/source/codegen/raii.cpp b/source/codegen/raii.cpp
new file mode 100644
index 000000000..eedba8369
--- /dev/null
+++ b/source/codegen/raii.cpp
@@ -0,0 +1,243 @@
+// raii.cpp
+// Copyright (c) 2019, zhiayang
+// Licensed under the Apache License Version 2.0.
+
+#include "sst.h"
+#include "codegen.h"
+#include "gluecode.h"
+
+namespace cgn
+{
+	void CodegenState::addRAIIValue(fir::Value* val)
+	{
+		if(!val->getType()->isClassType())
+			error("val is not a class type! '%s'", val->getType());
+
+		auto list = &this->blockPointStack.back().raiiValues;
+		if(auto it = std::find(list->begin(), list->end(), val); it == list->end())
+		{
+			list->push_back(val);
+		}
+		else
+		{
+			error("adding duplicate raii value (ptr = %p, type = '%s')", val, val->getType());
+		}
+	}
+
+	void CodegenState::removeRAIIValue(fir::Value* val)
+	{
+		if(!val->getType()->isClassType())
+			error("val is not a class type! '%s'", val->getType());
+
+		auto list = &this->blockPointStack.back().raiiValues;
+		if(auto it = std::find(list->begin(), list->end(), val); it != list->end())
+		{
+			list->erase(it);
+		}
+		else
+		{
+			error("removing non-existent raii value (ptr = %p, type = '%s')", val, val->getType());
+		}
+	}
+
+	std::vector<fir::Value*> CodegenState::getRAIIValues()
+	{
+		return this->blockPointStack.back().raiiValues;
+	}
+
+	static fir::Value* getAddressOfOrMakeTemporaryLValue(CodegenState* cs, fir::Value* val, bool mut)
+	{
+		if(val->islvalue())
+		{
+			return cs->irb.AddressOf(val, mut);
+		}
+		else
+		{
+			auto tmp = cs->irb.CreateLValue(val->getType());
+			cs->irb.Store(val, tmp);
+
+			return cs->irb.AddressOf(tmp, mut);
+		}
+	}
+
+
+
+	void CodegenState::callDestructor(fir::Value* val)
+	{
+		if(!val->getType()->isClassType())
+			error("val is not a class type! '%s'", val->getType());
+
+		fir::Value* selfptr = getAddressOfOrMakeTemporaryLValue(this, val, /* mutable: */ true);
+
+		auto cls = val->getType()->toClassType();
+
+		// call the user-defined one first, if any:
+		if(auto des = cls->getDestructor(); des)
+			this->irb.Call(des, selfptr);
+
+		// call the auto one. this will handle calling base class destructors for us!
+		this->irb.Call(cls->getInlineDestructor(), selfptr);
+	}
+
+
+
+
+	static fir::ClassType* doChecks(CodegenState* cs, fir::Value* from, fir::Value* target)
+	{
+   	// this cleans up the callsites so we can just unconditionally call this.
+		if(!from->getType()->isClassType())
+		{
+			cs->irb.Store(from, target);
+			return 0;
+		}
+
+		auto clsty = from->getType()->toClassType();
+
+		if(!target->islvalue())
+			error("invalid constructor on non-lvalue");
+
+		return clsty;
+	}
+
+	static void doMemberWiseStuffIfNecessary(CodegenState* cs, fir::ClassType* clsty, fir::Value* from, fir::Value* target, bool move)
+	{
+		// check if there are even any class types inside. if not, do the simple thing!
+		bool needSpecial = false;
+
+		for(auto m : clsty->getElements())
+		{
+			if(m->isClassType())
+			{
+				needSpecial = true;
+				break;
+			}
+		}
+
+		if(needSpecial)
+		{
+			auto selfptr = getAddressOfOrMakeTemporaryLValue(cs, target, true);
+			auto otherptr = getAddressOfOrMakeTemporaryLValue(cs, from, true);
+
+			// assign `lhs = rhs`
+			auto pairs = util::pairs(clsty->getElementNameMap());
+
+			for(size_t i = 0; i < clsty->getElementCount(); i++)
+			{
+				auto lhs = cs->irb.StructGEP(cs->irb.Dereference(selfptr), i);
+				auto rhs = cs->irb.StructGEP(cs->irb.Dereference(otherptr), i);
+
+				if(move)    cs->moveRAIIValue(rhs, lhs);
+				else        cs->copyRAIIValue(rhs, lhs);
+			}
+		}
+		else
+		{
+			cs->irb.Store(from, target);
+		}
+	}
+
+
+
+
+
+
+	fir::Value* CodegenState::copyRAIIValue(fir::Value* value)
+	{
+		if(!value->getType()->isClassType())
+			return value;
+
+		// this will zero-initialise!
+		auto ret = this->irb.CreateLValue(value->getType());
+
+		this->copyRAIIValue(value, ret, /* enableMoving: */ false);
+		return ret;
+	}
+
+
+
+	void CodegenState::copyRAIIValue(fir::Value* from, fir::Value* target, bool enableMoving)
+	{
+		iceAssert(from->getType() == target->getType());
+
+		auto clsty = doChecks(this, from, target);
+		if(!clsty) return;
+
+		if(!from->islvalue() && enableMoving)
+		{
+			this->moveRAIIValue(from, target);
+			return;
+		}
+
+		// if there is a copy-constructor, then we will call the copy constructor.
+		if(auto copycon = clsty->getCopyConstructor(); copycon)
+		{
+			auto selfptr = getAddressOfOrMakeTemporaryLValue(this, target, true);
+			auto otherptr = getAddressOfOrMakeTemporaryLValue(this, from, true);
+
+			this->irb.Call(copycon, selfptr, otherptr);
+		}
+		else
+		{
+			doMemberWiseStuffIfNecessary(this, clsty, from, target, /* move: */ false);
+		}
+	}
+
+	void CodegenState::moveRAIIValue(fir::Value* from, fir::Value* target)
+	{
+		iceAssert(from->getType() == target->getType());
+
+		auto clsty = doChecks(this, from, target);
+		if(!clsty) return;
+
+		if(from->islvalue())
+		{
+			// you can't move from lvalues!
+			this->copyRAIIValue(from, target);
+			return;
+		}
+
+
+		if(auto movecon = clsty->getMoveConstructor(); movecon)
+		{
+			auto selfptr = getAddressOfOrMakeTemporaryLValue(this, target, true);
+			auto otherptr = getAddressOfOrMakeTemporaryLValue(this, from, true);
+
+			this->irb.Call(movecon, selfptr, otherptr);
+		}
+		else
+		{
+			doMemberWiseStuffIfNecessary(this, clsty, from, target, /* move: */ true);
+		}
+
+		this->removeRAIIValue(from);
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/source/codegen/refcounting.cpp b/source/codegen/refcounting.cpp
index 651d212a1..0136dd047 100644
--- a/source/codegen/refcounting.cpp
+++ b/source/codegen/refcounting.cpp
@@ -8,140 +8,56 @@

 namespace cgn
 {
-	static void _addRC(const Location& l, fir::Value* v, std::vector<fir::Value*>* list, std::string kind)
-	{
-		if(auto it = std::find(list->begin(), list->end(), v); it == list->end())
-			list->push_back(v);
-
-		else
-			error(l, "adding duplicate refcounted %s (ptr = %p, type = '%s')", kind, v, v->getType());
-	}
-
-	static void _removeRC(const Location& l, fir::Value* v, std::vector<fir::Value*>* list, std::string kind, bool ignore)
-	{
-		if(auto it = std::find(list->begin(), list->end(), v); it != list->end())
-			list->erase(it);
-
-		else if(!ignore)
-			error(l, "removing non-existent refcounted %s (ptr = %p, type = '%s')", kind, v, v->getType());
-	}
-
-
-
 	void CodegenState::addRefCountedValue(fir::Value* val)
 	{
-		// warn(this->loc(), "add id %d", val->id);
-		_addRC(this->loc(), val, &this->blockPointStack.back().refCountedValues, "value");
-	}
+		auto list = &this->blockPointStack.back().refCountedValues;

-	void CodegenState::removeRefCountedValue(fir::Value* val, bool ignore)
-	{
-		// warn(this->loc(), "remove id %d", val->id);
-		_removeRC(this->loc(), val, &this->blockPointStack.back().refCountedValues, "value", ignore);
+		if(auto it = std::find(list->begin(), list->end(), val); it == list->end())
+			list->push_back(val);
+		else
+			error(this->loc(), "adding duplicate refcounted value (ptr = %p, type = '%s')", val, val->getType());
 	}

-	void CodegenState::addRefCountedPointer(fir::Value* val)
+	void CodegenState::removeRefCountedValue(fir::Value* val)
 	{
-		_addRC(this->loc(), val, &this->blockPointStack.back().refCountedPointers, "pointer");
-	}
+		auto list = &this->blockPointStack.back().refCountedValues;

-	void CodegenState::removeRefCountedPointer(fir::Value* val, bool ignore)
-	{
-		_removeRC(this->loc(), val, &this->blockPointStack.back().refCountedPointers, "pointer", ignore);
+		if(auto it = std::find(list->begin(), list->end(), val); it != list->end())
+			list->erase(it);
+		else
+			error(this->loc(), "removing non-existent refcounted value (ptr = %p, type = '%s')", val, val->getType());
 	}

-
-
-
 	std::vector<fir::Value*> CodegenState::getRefCountedValues()
 	{
 		return this->blockPointStack.back().refCountedValues;
 	}

-	std::vector<fir::Value*> CodegenState::getRefCountedPointers()
-	{
-		return this->blockPointStack.back().refCountedPointers;
-	}
-

-	void CodegenState::moveRefCountedValue(fir::Value* lhs, fir::Value* rhs, bool initial)
+	void CodegenState::autoAssignRefCountedValue(fir::Value* lhs, fir::Value* rhs, bool isinit)
 	{
-		// decrement the lhs refcount (only if not initial)
 		iceAssert(lhs && rhs);
-		if(!lhs->islorclvalue())
-			error("assignment (move) to non-lvalue (type '%s')", lhs->getType());

-		if(!initial)
-		{
-			this->decrementRefCount(lhs);
-
-			// then do the store
-			this->irb.Store(rhs, lhs);
-		}
+		if(!lhs->islvalue())
+			error(this->loc(), "assignment (move) to non-lvalue and non-pointer (type '%s')", lhs->getType());

-		// then, remove the rhs from any refcounting table
-		// but don't change the refcount itself.
-		if(!rhs->isLiteral())
-			this->removeRefCountedValue(rhs);
-	}
-
-	void CodegenState::performRefCountingAssignment(fir::Value* lhs, fir::Value* rhs, bool initial)
-	{
-		// ok, increment the rhs refcount;
-		// and decrement the lhs refcount (only if not initial)
-		iceAssert(lhs && rhs);
-		if(!lhs->islorclvalue())
-			error("assignment (move) to non-lvalue (type '%s')", lhs->getType());
-
-
-		this->incrementRefCount(rhs);
-
-		if(!initial)
+		if(fir::isRefCountedType(rhs->getType()))
 		{
-			this->decrementRefCount(lhs);
-
-			// do the store -- if not initial.
-			// avoids immut shenanigans
-			this->irb.Store(rhs, lhs);
-		}
-	}
-
-	void CodegenState::autoAssignRefCountedValue(fir::Value* lhs, fir::Value* rhs, bool isinit, bool performstore)
-	{
-		iceAssert(lhs && rhs);
-		bool isPointer = false;
+			if(!isinit)
+				this->decrementRefCount(lhs);

-		if(!lhs->islorclvalue())
-		{
-			if(lhs->getType()->isPointerType())
+			if(rhs->canmove())
 			{
-				if(rhs->getType() != lhs->getType()->getPointerElementType())
-					error(this->loc(), "mismatched types in assignment (move); cannot store value '%s' in '%s'", rhs->getType(), lhs->getType());
-
-				lhs = this->irb.Dereference(lhs);
+				this->removeRefCountedValue(rhs);
 			}
 			else
 			{
-				error(this->loc(), "assignment (move) to non-lvalue and non-pointer (type '%s')", lhs->getType());
+				this->incrementRefCount(rhs);
 			}
 		}

-		// warn(this->loc(), "hi (%d)", rhs->islorclvalue());
-
-		if(fir::isRefCountedType(rhs->getType()))
-		{
-			if(rhs->islorclvalue())
-				this->performRefCountingAssignment(lhs, rhs, isinit);
-
-			else
-				this->moveRefCountedValue(lhs, rhs, isinit);
-		}
-
-		if(performstore)
-		{
-			if(isPointer)   this->irb.WritePtr(rhs, lhs);
-			else            this->irb.Store(rhs, lhs);
-		}
+		// copy will do the right thing in all cases (handle non-RAII, and call move if possible)
+		this->copyRAIIValue(rhs, lhs);
 	}


@@ -237,8 +153,6 @@ namespace cgn
 		}
 	}

-
-
 	void CodegenState::incrementRefCount(fir::Value* val)
 	{
 		iceAssert(fir::isRefCountedType(val->getType()));
diff --git a/source/codegen/subscript.cpp b/source/codegen/subscript.cpp
index 213ca26df..0ca7238b3 100644
--- a/source/codegen/subscript.cpp
+++ b/source/codegen/subscript.cpp
@@ -32,7 +32,7 @@ CGResult sst::SubscriptOp::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	else if(lt->isArrayType())
 	{
 		// TODO: LVALUE HOLE
-		if(lr->islorclvalue())
+		if(lr->islvalue())
 		{
 			datapointer = cs->irb.GEP2(cs->irb.AddressOf(lr.value, true), fir::ConstantInt::getNative(0),
 				fir::ConstantInt::getNative(0));
diff --git a/source/codegen/variable.cpp b/source/codegen/variable.cpp
index 1fbc07e70..656e3bcae 100644
--- a/source/codegen/variable.cpp
+++ b/source/codegen/variable.cpp
@@ -53,7 +53,7 @@ CGResult sst::VarDefn::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 		else
 		{
 			res = checkStore(res);
-			cs->autoAssignRefCountedValue(glob, res, true, true);
+			cs->autoAssignRefCountedValue(glob, res, true);
 		}

 		// go and fix the thing.
@@ -68,50 +68,40 @@ CGResult sst::VarDefn::_codegen(cgn::CodegenState* cs, fir::Type* infer)
 	else
 	{
 		fir::Value* val = 0;
-		fir::Value* alloc = 0;

-		fir::Value* res = 0;
 		if(this->init)
 		{
-			res = this->init->codegen(cs, this->type).value;
-			res = cs->oneWayAutocast(res, this->type);
-
-			val = res;
-		}
-
-		if(!val) val = cs->getDefaultValue(this->type);
-
-
-		val = checkStore(val);
-
-		if(this->immutable)
-		{
-			iceAssert(val);
-			alloc = cs->irb.CreateConstLValue(val, this->id.name);
+			val = this->init->codegen(cs, this->type).value;
+			val = cs->oneWayAutocast(val, this->type);
 		}
 		else
 		{
-			alloc = cs->irb.CreateLValue(this->type, this->id.name);
+			val = cs->getDefaultValue(this->type);
+			val = checkStore(val);
 		}

-		iceAssert(alloc);
+		auto alloc = cs->irb.CreateLValue(this->type, this->id.name);
+		cs->autoAssignRefCountedValue(alloc, val, /* isInitial: */ true);
+
+		if(this->immutable)
+			alloc->makeConst();

-		cs->addVariableUsingStorage(this, alloc, CGResult(res));
+		cs->addVariableUsingStorage(this, alloc);

 		return CGResult(alloc);
 	}
 }

-void cgn::CodegenState::addVariableUsingStorage(sst::VarDefn* var, fir::Value* alloc, CGResult val)
+void cgn::CodegenState::addVariableUsingStorage(sst::VarDefn* var, fir::Value* alloc)
 {
 	iceAssert(alloc);
 	this->valueMap[var] = CGResult(alloc);

-	if(val.value)
-		this->autoAssignRefCountedValue(alloc, val.value, /* isInitial: */ true, /* performStore: */ !var->immutable);
-
 	if(fir::isRefCountedType(var->type))
 		this->addRefCountedValue(alloc);
+
+	if(var->type->isClassType())
+		this->addRAIIValue(alloc);
 }


diff --git a/source/fir/ConstantValue.cpp b/source/fir/ConstantValue.cpp
index a99f67330..0ef5f29b5 100644
--- a/source/fir/ConstantValue.cpp
+++ b/source/fir/ConstantValue.cpp
@@ -13,7 +13,7 @@ namespace fir
 {
 	ConstantValue::ConstantValue(Type* t) : Value(t)
 	{
-		this->kind = Kind::literal;
+		this->kind = Kind::prvalue;
 	}

 	ConstantValue* ConstantValue::getZeroValue(Type* type)
@@ -187,12 +187,12 @@ namespace fir

 	ConstantFP::ConstantFP(Type* type, float val) : fir::ConstantValue(type)
 	{
-		this->value = (long double) val;
+		this->value = (double) val;
 	}

 	ConstantFP::ConstantFP(Type* type, double val) : fir::ConstantValue(type)
 	{
-		this->value = (long double) val;
+		this->value = val;
 	}

 	double ConstantFP::getValue()
diff --git a/source/fir/Function.cpp b/source/fir/Function.cpp
index 7f41cf3bd..5a3c224f6 100644
--- a/source/fir/Function.cpp
+++ b/source/fir/Function.cpp
@@ -76,7 +76,7 @@ namespace fir
 		return this->fnArguments.size();
 	}

-	std::vector<Argument*> Function::getArguments()
+	const std::vector<Argument*>& Function::getArguments()
 	{
 		return this->fnArguments;
 	}
@@ -128,7 +128,7 @@ namespace fir
 		this->stackAllocs.push_back(ty);
 	}

-	std::vector<Type*> Function::getStackAllocations()
+	const std::vector<Type*>& Function::getStackAllocations()
 	{
 		return this->stackAllocs;
 	}
diff --git a/source/fir/GlobalValue.cpp b/source/fir/GlobalValue.cpp
index 7df747ff3..419b7b7cf 100644
--- a/source/fir/GlobalValue.cpp
+++ b/source/fir/GlobalValue.cpp
@@ -17,7 +17,7 @@ namespace fir
 		//* not a typo; only variables deserve to be 'lvalue', global values (eg. functions)
 		//* should just be rvalues.
 		if(mut) this->kind = Kind::lvalue;
-		else    this->kind = Kind::rvalue;
+		else    this->kind = Kind::prvalue;
 	}


@@ -27,10 +27,8 @@ namespace fir
 		this->ident = name;
 		this->initValue = initValue;

-		if(!immutable)  this->kind = Kind::lvalue;
-		else            this->kind = Kind::clvalue;
-
-		// module->globals[this->ident] = this;
+		this->kind = Kind::lvalue;
+		this->isconst = immutable;
 	}

 	void GlobalVariable::setInitialValue(ConstantValue* constVal)
diff --git a/source/fir/IRBuilder.cpp b/source/fir/IRBuilder.cpp
index 5308e65e5..2461f9007 100644
--- a/source/fir/IRBuilder.cpp
+++ b/source/fir/IRBuilder.cpp
@@ -75,10 +75,10 @@ namespace fir
 	}

 	static util::MemoryPool<Instruction> instr_pool(65536);
-	static Instruction* make_instr(OpKind kind, bool sideEffects, IRBlock* parent, Type* out, const std::vector<Value*>& vals,
-		Value::Kind k = Value::Kind::rvalue)
+	static Instruction* make_instr(OpKind kind, bool sideEffects, Type* out, const std::vector<Value*>& vals,
+		Value::Kind k = Value::Kind::prvalue)
 	{
-		return instr_pool.construct(kind, sideEffects, parent, out, vals, k);
+		return instr_pool.construct(kind, sideEffects, out, vals, k);
 	}

 	Value* IRBuilder::addInstruction(Instruction* instr, const std::string& vname)
@@ -299,7 +299,7 @@ namespace fir
 			return 0;
 		}

-		return make_instr(op, false, parent, out, { vlhs, vrhs });
+		return make_instr(op, false, out, { vlhs, vrhs });
 	}

 	Value* IRBuilder::BinaryOp(std::string ao, Value* a, Value* b, const std::string& vname)
@@ -346,7 +346,7 @@ namespace fir
 		iceAssert((a->getType()->isFloatingPointType() || a->getType()->toPrimitiveType()->isSigned()) && "cannot negate unsigned type");

 		Instruction* instr = make_instr(a->getType()->isFloatingPointType() ? OpKind::Floating_Neg : OpKind::Signed_Neg,
-			false, this->currentBlock, a->getType(), { a });
+			false, a->getType(), { a });

 		return this->addInstruction(instr, vname);
 	}
@@ -362,7 +362,7 @@ namespace fir
 		else ok = OpKind::Floating_Add;


-		Instruction* instr = make_instr(ok, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(ok, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -376,7 +376,7 @@ namespace fir
 		else if(a->getType()->isIntegerType()) ok = OpKind::Unsigned_Sub;
 		else ok = OpKind::Floating_Sub;

-		Instruction* instr = make_instr(ok, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(ok, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -390,7 +390,7 @@ namespace fir
 		else if(a->getType()->isIntegerType()) ok = OpKind::Unsigned_Mul;
 		else ok = OpKind::Floating_Mul;

-		Instruction* instr = make_instr(ok, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(ok, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -405,7 +405,7 @@ namespace fir
 		else if(a->getType()->isIntegerType()) ok = OpKind::Unsigned_Div;
 		else ok = OpKind::Floating_Div;

-		Instruction* instr = make_instr(ok, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(ok, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -419,14 +419,14 @@ namespace fir
 		else if(a->getType()->isIntegerType()) ok = OpKind::Unsigned_Mod;
 		else ok = OpKind::Floating_Mod;

-		Instruction* instr = make_instr(ok, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(ok, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::FTruncate(Value* v, Type* targetType, const std::string& vname)
 	{
 		iceAssert(v->getType()->isFloatingPointType() && targetType->isFloatingPointType() && "not floating point type");
-		Instruction* instr = make_instr(OpKind::Floating_Truncate, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Floating_Truncate, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -435,7 +435,7 @@ namespace fir
 	Value* IRBuilder::FExtend(Value* v, Type* targetType, const std::string& vname)
 	{
 		iceAssert(v->getType()->isFloatingPointType() && targetType->isFloatingPointType() && "not floating point type");
-		Instruction* instr = make_instr(OpKind::Floating_Extend, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Floating_Extend, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -454,7 +454,7 @@ namespace fir
 			error("irbuilder: creating icmp eq instruction with non-equal types");
 		}

-		Instruction* instr = make_instr(OpKind::ICompare_Equal, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::ICompare_Equal, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -468,7 +468,7 @@ namespace fir
 			error("irbuilder: creating icmp neq instruction with non-equal types");
 		}

-		Instruction* instr = make_instr(OpKind::ICompare_NotEqual, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::ICompare_NotEqual, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -482,7 +482,7 @@ namespace fir
 			error("irbuilder: creating icmp gt instruction with non-equal types");
 		}

-		Instruction* instr = make_instr(OpKind::ICompare_Greater, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::ICompare_Greater, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -496,7 +496,7 @@ namespace fir
 			error("irbuilder: creating icmp lt instruction with non-equal types");
 		}

-		Instruction* instr = make_instr(OpKind::ICompare_Less, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::ICompare_Less, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -510,7 +510,7 @@ namespace fir
 			error("irbuilder: creating icmp geq instruction with non-equal types");
 		}

-		Instruction* instr = make_instr(OpKind::ICompare_GreaterEqual, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::ICompare_GreaterEqual, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -524,7 +524,7 @@ namespace fir
 			error("irbuilder: creating icmp leq instruction with non-equal types");
 		}

-		Instruction* instr = make_instr(OpKind::ICompare_LessEqual, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::ICompare_LessEqual, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -537,7 +537,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp eq_ord instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Equal_ORD, false, this->currentBlock, fir::Type::getBool(),
+		Instruction* instr = make_instr(OpKind::FCompare_Equal_ORD, false, fir::Type::getBool(),
 			{ a, b });
 		return this->addInstruction(instr, vname);
 	}
@@ -546,8 +546,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp eq_uord instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Equal_UNORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_Equal_UNORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -555,8 +554,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp neq_ord instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_NotEqual_ORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_NotEqual_ORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -564,8 +562,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp neq_uord instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_NotEqual_UNORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_NotEqual_UNORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -573,8 +570,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp gt instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Greater_ORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_Greater_ORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -582,8 +578,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp gt instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Greater_UNORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_Greater_UNORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -591,8 +586,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp lt instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Less_ORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_Less_ORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -600,8 +594,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp lt instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Less_UNORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_Less_UNORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -609,8 +602,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp geq instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_GreaterEqual_ORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_GreaterEqual_ORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -618,8 +610,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp geq instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_GreaterEqual_UNORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_GreaterEqual_UNORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -627,8 +618,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp leq instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_LessEqual_ORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_LessEqual_ORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -636,8 +626,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp leq instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_LessEqual_UNORD, false, this->currentBlock,
-			fir::Type::getBool(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_LessEqual_UNORD, false, fir::Type::getBool(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -647,8 +636,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating icmp multi instruction with non-equal types");
 		// iceAssert(a->getType()->isIntegerType() && "creating icmp multi instruction with non-integer type");
-		Instruction* instr = make_instr(OpKind::ICompare_Multi, false, this->currentBlock,
-			fir::Type::getNativeWord(), { a, b });
+		Instruction* instr = make_instr(OpKind::ICompare_Multi, false, fir::Type::getNativeWord(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -656,8 +644,7 @@ namespace fir
 	{
 		iceAssert(a->getType() == b->getType() && "creating cmp leq instruction with non-equal types");
 		iceAssert(a->getType()->isFloatingPointType() && "creating fcmp instruction with non floating-point types");
-		Instruction* instr = make_instr(OpKind::FCompare_Multi, false, this->currentBlock,
-			fir::Type::getNativeWord(), { a, b });
+		Instruction* instr = make_instr(OpKind::FCompare_Multi, false, fir::Type::getNativeWord(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

@@ -673,54 +660,54 @@ namespace fir
 	Value* IRBuilder::BitwiseXOR(Value* a, Value* b, const std::string& vname)
 	{
 		iceAssert(a->getType() == b->getType() && "creating bitwise xor instruction with non-equal types");
-		Instruction* instr = make_instr(OpKind::Bitwise_Xor, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(OpKind::Bitwise_Xor, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::BitwiseLogicalSHR(Value* a, Value* b, const std::string& vname)
 	{
 		iceAssert(a->getType() == b->getType() && "creating bitwise lshl instruction with non-equal types");
-		Instruction* instr = make_instr(OpKind::Bitwise_Logical_Shr, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(OpKind::Bitwise_Logical_Shr, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::BitwiseArithmeticSHR(Value* a, Value* b, const std::string& vname)
 	{
 		iceAssert(a->getType() == b->getType() && "creating bitwise ashl instruction with non-equal types");
-		Instruction* instr = make_instr(OpKind::Bitwise_Arithmetic_Shr, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(OpKind::Bitwise_Arithmetic_Shr, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::BitwiseSHL(Value* a, Value* b, const std::string& vname)
 	{
 		iceAssert(a->getType() == b->getType() && "creating bitwise shr instruction with non-equal types");
-		Instruction* instr = make_instr(OpKind::Bitwise_Shl, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(OpKind::Bitwise_Shl, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::BitwiseAND(Value* a, Value* b, const std::string& vname)
 	{
 		iceAssert(a->getType() == b->getType() && "creating bitwise and instruction with non-equal types");
-		Instruction* instr = make_instr(OpKind::Bitwise_And, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(OpKind::Bitwise_And, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::BitwiseOR(Value* a, Value* b, const std::string& vname)
 	{
 		iceAssert(a->getType() == b->getType() && "creating bitwise or instruction with non-equal types");
-		Instruction* instr = make_instr(OpKind::Bitwise_Or, false, this->currentBlock, a->getType(), { a, b });
+		Instruction* instr = make_instr(OpKind::Bitwise_Or, false, a->getType(), { a, b });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::BitwiseNOT(Value* a, const std::string& vname)
 	{
-		Instruction* instr = make_instr(OpKind::Bitwise_Not, false, this->currentBlock, a->getType(), { a });
+		Instruction* instr = make_instr(OpKind::Bitwise_Not, false, a->getType(), { a });
 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::Bitcast(Value* v, Type* targetType, const std::string& vname)
 	{
-		Instruction* instr = make_instr(OpKind::Cast_Bitcast, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_Bitcast, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });
 		return this->addInstruction(instr, vname);
 	}
@@ -736,7 +723,7 @@ namespace fir
 			return ConstantInt::get(targetType, ci->getSignedValue());
 		}

-		Instruction* instr = make_instr(OpKind::Cast_IntSize, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_IntSize, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -757,7 +744,7 @@ namespace fir
 				return ConstantInt::get(targetType, ci->getUnsignedValue());
 		}

-		Instruction* instr = make_instr(OpKind::Cast_IntSignedness, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_IntSignedness, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -779,7 +766,7 @@ namespace fir
 			return ConstantInt::get(targetType, (size_t) cfp->getValue());
 		}

-		Instruction* instr = make_instr(OpKind::Cast_FloatToInt, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_FloatToInt, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -813,7 +800,7 @@ namespace fir
 			return ret;
 		}

-		Instruction* instr = make_instr(OpKind::Cast_IntToFloat, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_IntToFloat, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -824,7 +811,7 @@ namespace fir
 		iceAssert((v->getType()->isPointerType() || v->getType()->isNullType()) && "value is not pointer type");
 		iceAssert((targetType->isPointerType() || targetType->isNullType()) && "target is not pointer type");

-		Instruction* instr = make_instr(OpKind::Cast_PointerType, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_PointerType, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });

 		return this->addInstruction(instr, vname);
@@ -835,7 +822,7 @@ namespace fir
 		iceAssert(v->getType()->isPointerType() && "value is not pointer type");
 		iceAssert(targetType->isIntegerType() && "target is not integer type");

-		Instruction* instr = make_instr(OpKind::Cast_PointerToInt, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_PointerToInt, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });
 		return this->addInstruction(instr, vname);
 	}
@@ -845,7 +832,7 @@ namespace fir
 		iceAssert(v->getType()->isIntegerType() && "value is not integer type");
 		iceAssert(targetType->isPointerType() && "target is not pointer type");

-		Instruction* instr = make_instr(OpKind::Cast_IntToPointer, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Cast_IntToPointer, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });
 		return this->addInstruction(instr, vname);
 	}
@@ -856,7 +843,7 @@ namespace fir
 		iceAssert(v->getType()->isIntegerType() && "value is not integer type");
 		iceAssert(targetType->isIntegerType() && "target is not integer type");

-		Instruction* instr = make_instr(OpKind::Integer_Truncate, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Integer_Truncate, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });
 		return this->addInstruction(instr, vname);
 	}
@@ -866,7 +853,7 @@ namespace fir
 		iceAssert((v->getType()->isIntegerType() || v->getType()->isBoolType()) && "value is not integer type");
 		iceAssert(targetType->isIntegerType() && "target is not integer type");

-		Instruction* instr = make_instr(OpKind::Integer_ZeroExt, false, this->currentBlock, targetType,
+		Instruction* instr = make_instr(OpKind::Integer_ZeroExt, false, targetType,
 			{ v, ConstantValue::getZeroValue(targetType) });
 		return this->addInstruction(instr, vname);
 	}
@@ -1069,7 +1056,7 @@ namespace fir

 		out.insert(out.begin(), fn);

-		Instruction* instr = make_instr(OpKind::Value_CallFunction, true, this->currentBlock, fn->getType()->getReturnType(), out);
+		Instruction* instr = make_instr(OpKind::Value_CallFunction, true, fn->getType()->getReturnType(), out);
 		return this->addInstruction(instr, vname);
 	}

@@ -1087,7 +1074,7 @@ namespace fir
 		//* note: we're using our operator overload here for T + VEC<T>
 		auto out = fn + args;

-		Instruction* instr = make_instr(OpKind::Value_CallFunctionPointer, true, this->currentBlock, ft->getReturnType(), out);
+		Instruction* instr = make_instr(OpKind::Value_CallFunctionPointer, true, ft->getReturnType(), out);
 		return this->addInstruction(instr, vname);
 	}

@@ -1100,7 +1087,7 @@ namespace fir
 		auto self = ty->getPointerElementType()->toClassType();
 		iceAssert(self && self == cls);

-		Instruction* instr = make_instr(OpKind::Value_CallVirtualMethod, true, this->currentBlock, ft->getReturnType(),
+		Instruction* instr = make_instr(OpKind::Value_CallVirtualMethod, true, ft->getReturnType(),
 			(Value*) ConstantValue::getZeroValue(cls) + ((Value*) ConstantInt::getNative(index) + ((Value*) ConstantValue::getZeroValue(ft) + args)));

 		return this->addInstruction(instr, vname);
@@ -1127,27 +1114,27 @@ namespace fir

 	Value* IRBuilder::Return(Value* v)
 	{
-		Instruction* instr = make_instr(OpKind::Value_Return, true, this->currentBlock, Type::getVoid(), { v });
+		Instruction* instr = make_instr(OpKind::Value_Return, true, Type::getVoid(), { v });
 		return this->addInstruction(instr, "");
 	}

 	Value* IRBuilder::ReturnVoid()
 	{
-		Instruction* instr = make_instr(OpKind::Value_Return, true, this->currentBlock, Type::getVoid(), { });
+		Instruction* instr = make_instr(OpKind::Value_Return, true, Type::getVoid(), { });
 		return this->addInstruction(instr, "");
 	}


 	Value* IRBuilder::LogicalNot(Value* v, const std::string& vname)
 	{
-		Instruction* instr = make_instr(OpKind::Logical_Not, false, this->currentBlock, Type::getBool(), { v });
+		Instruction* instr = make_instr(OpKind::Logical_Not, false, Type::getBool(), { v });
 		return this->addInstruction(instr, vname);
 	}


 	PHINode* IRBuilder::CreatePHINode(Type* type, const std::string& vname)
 	{
-		Instruction* instr = make_instr(OpKind::Value_CreatePHI, false, this->currentBlock, type->getPointerTo(),
+		Instruction* instr = make_instr(OpKind::Value_CreatePHI, false, type->getPointerTo(),
 			{ ConstantValue::getZeroValue(type) });

 		// we need to 'lift' (hoist) the allocation up to make it the first in the block
@@ -1166,7 +1153,7 @@ namespace fir

 	Value* IRBuilder::StackAlloc(Type* type, const std::string& vname)
 	{
-		Instruction* instr = make_instr(OpKind::Value_StackAlloc, false, this->currentBlock, type->getMutablePointerTo(),
+		Instruction* instr = make_instr(OpKind::Value_StackAlloc, false, type->getMutablePointerTo(),
 			{ ConstantValue::getZeroValue(type) });

 		// we need to 'lift' (hoist) the allocation up to the entry block of the function
@@ -1224,14 +1211,14 @@ namespace fir

 	void IRBuilder::CondBranch(Value* condition, IRBlock* trueB, IRBlock* falseB)
 	{
-		Instruction* instr = make_instr(OpKind::Branch_Cond, true, this->currentBlock, Type::getVoid(),
+		Instruction* instr = make_instr(OpKind::Branch_Cond, true, Type::getVoid(),
 			{ condition, trueB, falseB });
 		this->addInstruction(instr, "");
 	}

 	void IRBuilder::UnCondBranch(IRBlock* target)
 	{
-		Instruction* instr = make_instr(OpKind::Branch_UnCond, true, this->currentBlock, Type::getVoid(),
+		Instruction* instr = make_instr(OpKind::Branch_UnCond, true, Type::getVoid(),
 			{ target });
 		this->addInstruction(instr, "");
 	}
@@ -1239,13 +1226,13 @@ namespace fir

 	Value* IRBuilder::GetRawUnionFieldByType(Value* lval, Type* type, const std::string& vname)
 	{
-		if(!lval->islorclvalue())
+		if(!lval->islvalue())
 			error("irbuilder: cannot do raw union ops on non-lvalue");

 		if(!lval->getType()->isRawUnionType())
 			error("irbuilder: '%s' is not a raw union type!", lval->getType());

-		Instruction* instr = make_instr(OpKind::RawUnion_GEP, false, this->currentBlock, type, { lval, ConstantValue::getZeroValue(type) });
+		Instruction* instr = make_instr(OpKind::RawUnion_GEP, false, type, { lval, ConstantValue::getZeroValue(type) });

 		auto ret = this->addInstruction(instr, "");
 		ret->setKind(lval->kind);
@@ -1255,7 +1242,7 @@ namespace fir

 	Value* IRBuilder::GetRawUnionField(Value* lval, const std::string& field, const std::string& vname)
 	{
-		if(!lval->islorclvalue())
+		if(!lval->islvalue())
 			error("irbuilder: cannot do raw union ops on non-lvalue");

 		if(!lval->getType()->isRawUnionType())
@@ -1272,14 +1259,14 @@ namespace fir


 	template <typename T>
-	static Instruction* doGEPOnCompoundType(IRBlock* parent, T* type, Value* structPtr, size_t memberIndex)
+	static Instruction* doGEPOnCompoundType(T* type, Value* structPtr, size_t memberIndex)
 	{
-		if(!structPtr->islorclvalue())
+		if(!structPtr->islvalue())
 			error("irbuilder: cannot do GEP on non-lvalue");

 		iceAssert(type->getElementCount() > memberIndex && "struct does not have so many members");

-		Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, parent, type->getElementN(memberIndex),
+		Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, type->getElementN(memberIndex),
 			{ structPtr, ConstantInt::getUNative(memberIndex) }, Value::Kind::lvalue);

 		return instr;
@@ -1290,18 +1277,26 @@ namespace fir

 	Value* IRBuilder::StructGEP(Value* structPtr, size_t memberIndex, const std::string& vname)
 	{
-		if(!structPtr->islorclvalue())
+		if(!structPtr->islvalue())
 			error("irbuilder: cannot do GEP on non-lvalue");

-		//* note: we do not allow raw gep (by index) into classes, because V T A B L E
 		if(structPtr->getType()->isStructType())
 		{
-			return this->addInstruction(doGEPOnCompoundType(this->currentBlock, structPtr->getType()->toStructType(),
+			return this->addInstruction(doGEPOnCompoundType(structPtr->getType()->toStructType(),
+				structPtr, memberIndex), vname);
+		}
+		else if(structPtr->getType()->isClassType())
+		{
+			// to compensate for the vtable, we add one to the index if there is a vtable!
+			if(structPtr->getType()->toClassType()->getVirtualMethodCount() > 0)
+				memberIndex += 1;
+
+			return this->addInstruction(doGEPOnCompoundType(structPtr->getType()->toClassType(),
 				structPtr, memberIndex), vname);
 		}
 		else if(structPtr->getType()->isTupleType())
 		{
-			return this->addInstruction(doGEPOnCompoundType(this->currentBlock, structPtr->getType()->toTupleType(),
+			return this->addInstruction(doGEPOnCompoundType(structPtr->getType()->toTupleType(),
 				structPtr, memberIndex), vname);
 		}
 		else
@@ -1312,7 +1307,7 @@ namespace fir

 	Value* IRBuilder::GetStructMember(Value* ptr, const std::string& memberName)
 	{
-		if(!ptr->islorclvalue())
+		if(!ptr->islvalue())
 			error("irbuilder: cannot do GEP on non-lvalue");

 		if(ptr->getType()->isStructType())
@@ -1322,8 +1317,8 @@ namespace fir

 			iceAssert(st->hasElementWithName(memberName) && "no element with such name");

-			Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, this->currentBlock,
-				memt, { ptr, ConstantInt::getUNative(st->getElementIndex(memberName)) }, Value::Kind::lvalue);
+			Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, memt,
+				{ ptr, ConstantInt::getUNative(st->getElementIndex(memberName)) }, Value::Kind::lvalue);

 			return this->addInstruction(instr, memberName);
 		}
@@ -1339,8 +1334,8 @@ namespace fir
 			if(ct->getVirtualMethodCount() > 0)
 				vTableOfs = 1;

-			Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, this->currentBlock,
-				memt, { ptr, ConstantInt::getUNative(ct->getElementIndex(memberName) + vTableOfs) }, Value::Kind::lvalue);
+			Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, memt,
+				{ ptr, ConstantInt::getUNative(ct->getElementIndex(memberName) + vTableOfs) }, Value::Kind::lvalue);

 			return this->addInstruction(instr, memberName);
 		}
@@ -1354,15 +1349,14 @@ namespace fir

 	void IRBuilder::SetVtable(Value* ptr, Value* table, const std::string& vname)
 	{
-		if(!ptr->islorclvalue())
+		if(!ptr->islvalue())
 			error("irbuilder: cannot do set vtable on non-lvalue");

 		auto ty = ptr->getType();
 		if(!ty->isClassType()) error("irbuilder: '%s' is not a class type", ty);
 		if(table->getType() != fir::Type::getInt8Ptr()) error("irbuilder: expected i8* for vtable, got '%s'", table->getType());

-		Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, this->currentBlock,
-			fir::Type::getInt8Ptr(), { ptr, ConstantInt::getUNative(0) }, Value::Kind::lvalue);
+		Instruction* instr = make_instr(OpKind::Value_GetStructMember, false, 			fir::Type::getInt8Ptr(), { ptr, ConstantInt::getUNative(0) }, Value::Kind::lvalue);

 		auto gep = this->addInstruction(instr, vname);
 		this->Store(table, gep);
@@ -1402,7 +1396,7 @@ namespace fir
 		if(ptr->getType()->isMutablePointer())
 			retType = retType->getMutablePointerVersion();

-		Instruction* instr = make_instr(OpKind::Value_GetGEP2, false, this->currentBlock, retType, { ptr, ptrIndex, elmIndex });
+		Instruction* instr = make_instr(OpKind::Value_GetGEP2, false, retType, { ptr, ptrIndex, elmIndex });

 		return this->addInstruction(instr, vname);
 	}
@@ -1419,7 +1413,7 @@ namespace fir
 		if(ptr->getType()->getPointerElementType()->isClassType() || ptr->getType()->getPointerElementType()->isStructType())
 			error("irbuilder: use the other function for struct types");

-		Instruction* instr = make_instr(OpKind::Value_GetPointer, false, this->currentBlock, ptr->getType(), { ptr, ptrIndex });
+		Instruction* instr = make_instr(OpKind::Value_GetPointer, false, ptr->getType(), { ptr, ptrIndex });

 		return this->addInstruction(instr, vname);
 	}
@@ -1433,7 +1427,7 @@ namespace fir
 		if(one->getType() != two->getType())
 			error("irbuilder: non-identical types for operands (got '%s' and '%s')", one->getType(), two->getType());

-		Instruction* instr = make_instr(OpKind::Value_Select, false, this->currentBlock, one->getType(), { cond, one, two });
+		Instruction* instr = make_instr(OpKind::Value_Select, false, one->getType(), { cond, one, two });
 		return this->addInstruction(instr, vname);
 	}

@@ -1441,7 +1435,7 @@ namespace fir

 	Value* IRBuilder::Sizeof(Type* t, const std::string& vname)
 	{
-		Instruction* instr = make_instr(OpKind::Misc_Sizeof, false, this->currentBlock, Type::getNativeWord(),
+		Instruction* instr = make_instr(OpKind::Misc_Sizeof, false, Type::getNativeWord(),
 			{ ConstantValue::getZeroValue(t) });

 		return this->addInstruction(instr, vname);
@@ -1495,7 +1489,7 @@ namespace fir
 			args.push_back(fir::ConstantInt::getNative(id + ofs));

 		// note: no sideeffects, since we return a new aggregate
-		Instruction* instr = make_instr(OpKind::Value_InsertValue, false, this->currentBlock, t, args);
+		Instruction* instr = make_instr(OpKind::Value_InsertValue, false, t, args);
 		return this->addInstruction(instr, vname);
 	}

@@ -1526,7 +1520,7 @@ namespace fir
 			args.push_back(fir::ConstantInt::getNative(id + ofs));


-		Instruction* instr = make_instr(OpKind::Value_ExtractValue, false, this->currentBlock, et, args);
+		Instruction* instr = make_instr(OpKind::Value_ExtractValue, false, et, args);
 		return this->addInstruction(instr, vname);
 	}

@@ -1576,8 +1570,7 @@ namespace fir
 		if(!isSAAType(arr->getType()))
 			error("irbuilder: thing is not an SAA type (got '%s')", arr->getType());

-		Instruction* instr = make_instr(OpKind::SAA_GetData, false, this->currentBlock,
-			getSAAElmType(arr->getType())->getMutablePointerTo(), { arr });
+		Instruction* instr = make_instr(OpKind::SAA_GetData, false, getSAAElmType(arr->getType())->getMutablePointerTo(), { arr });

 		return this->addInstruction(instr, vname);
 	}
@@ -1594,8 +1587,7 @@ namespace fir
 				t->getMutablePointerTo(), val->getType());
 		}

-		Instruction* instr = make_instr(OpKind::SAA_SetData, true, this->currentBlock,
-			arr->getType(), { arr, val });
+		Instruction* instr = make_instr(OpKind::SAA_SetData, true, arr->getType(), { arr, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1607,8 +1599,7 @@ namespace fir
 		if(!isSAAType(arr->getType()))
 			error("irbuilder: thing is not an SAA type (got '%s')", arr->getType());

-		Instruction* instr = make_instr(OpKind::SAA_GetLength, false, this->currentBlock,
-			fir::Type::getNativeWord(), { arr });
+		Instruction* instr = make_instr(OpKind::SAA_GetLength, false, fir::Type::getNativeWord(), { arr });

 		return this->addInstruction(instr, vname);
 	}
@@ -1621,8 +1612,7 @@ namespace fir
 		if(val->getType() != fir::Type::getNativeWord())
 			error("irbuilder: val is not an int64");

-		Instruction* instr = make_instr(OpKind::SAA_SetLength, true, this->currentBlock,
-			arr->getType(), { arr, val });
+		Instruction* instr = make_instr(OpKind::SAA_SetLength, true, arr->getType(), { arr, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1634,8 +1624,7 @@ namespace fir
 		if(!isSAAType(arr->getType()))
 			error("irbuilder: thing is not an SAA type (got '%s')", arr->getType());

-		Instruction* instr = make_instr(OpKind::SAA_GetCapacity, false, this->currentBlock,
-			fir::Type::getNativeWord(), { arr });
+		Instruction* instr = make_instr(OpKind::SAA_GetCapacity, false, fir::Type::getNativeWord(), { arr });

 		return this->addInstruction(instr, vname);
 	}
@@ -1648,8 +1637,7 @@ namespace fir
 		if(val->getType() != fir::Type::getNativeWord())
 			error("irbuilder: val is not an int64");

-		Instruction* instr = make_instr(OpKind::SAA_SetCapacity, true, this->currentBlock,
-			arr->getType(), { arr, val });
+		Instruction* instr = make_instr(OpKind::SAA_SetCapacity, true, arr->getType(), { arr, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1661,8 +1649,7 @@ namespace fir
 		if(!isSAAType(arr->getType()))
 			error("irbuilder: thing is not an SAA type (got '%s')", arr->getType());

-		Instruction* instr = make_instr(OpKind::SAA_GetRefCountPtr, false, this->currentBlock,
-			fir::Type::getNativeWordPtr(), { arr });
+		Instruction* instr = make_instr(OpKind::SAA_GetRefCountPtr, false, fir::Type::getNativeWordPtr(), { arr });

 		return this->addInstruction(instr, vname);
 	}
@@ -1675,8 +1662,7 @@ namespace fir
 		if(val->getType() != fir::Type::getNativeWord()->getPointerTo())
 			error("irbuilder: val is not an int64 pointer");

-		Instruction* instr = make_instr(OpKind::SAA_SetRefCountPtr, true, this->currentBlock,
-			arr->getType(), { arr, val });
+		Instruction* instr = make_instr(OpKind::SAA_SetRefCountPtr, true, arr->getType(), { arr, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1725,8 +1711,7 @@ namespace fir
 		auto st = slc->getType()->toArraySliceType();
 		auto et = st->getElementType();

-		Instruction* instr = make_instr(OpKind::ArraySlice_GetData, false, this->currentBlock,
-			st->isMutable() ? et->getMutablePointerTo() : et->getPointerTo(), { slc });
+		Instruction* instr = make_instr(OpKind::ArraySlice_GetData, false, st->isMutable() ? et->getMutablePointerTo() : et->getPointerTo(), { slc });

 		return this->addInstruction(instr, vname);
 	}
@@ -1746,8 +1731,7 @@ namespace fir
 				error("irbuilder: val is not a pointer to elm type (need '%s', have '%s')", pt, val->getType());
 		}

-		Instruction* instr = make_instr(OpKind::ArraySlice_SetData, true, this->currentBlock,
-			slc->getType(), { slc, val });
+		Instruction* instr = make_instr(OpKind::ArraySlice_SetData, true, slc->getType(), { slc, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1758,8 +1742,7 @@ namespace fir
 		if(!slc->getType()->isArraySliceType())
 			error("irbuilder: slc is not an array slice type (got '%s')", slc->getType());

-		Instruction* instr = make_instr(OpKind::ArraySlice_GetLength, false, this->currentBlock,
-			fir::Type::getNativeWord(), { slc });
+		Instruction* instr = make_instr(OpKind::ArraySlice_GetLength, false, fir::Type::getNativeWord(), { slc });

 		return this->addInstruction(instr, vname);
 	}
@@ -1772,8 +1755,7 @@ namespace fir
 		if(val->getType() != fir::Type::getNativeWord())
 			error("irbuilder: val is not an int64");

-		Instruction* instr = make_instr(OpKind::ArraySlice_SetLength, true, this->currentBlock,
-			slc->getType(), { slc, val });
+		Instruction* instr = make_instr(OpKind::ArraySlice_SetLength, true, slc->getType(), { slc, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1790,7 +1772,7 @@ namespace fir
 		if(!any->getType()->isAnyType())
 			error("irbuilder: not any type (got '%s')", any->getType());

-		Instruction* instr = make_instr(OpKind::Any_GetTypeID, false, this->currentBlock, fir::Type::getNativeUWord(), { any });
+		Instruction* instr = make_instr(OpKind::Any_GetTypeID, false, fir::Type::getNativeUWord(), { any });

 		return this->addInstruction(instr, vname);
 	}
@@ -1803,7 +1785,7 @@ namespace fir
 		else if(val->getType() != fir::Type::getNativeUWord())
 			error("irbuilder: val is not a uint64");

-		Instruction* instr = make_instr(OpKind::Any_SetTypeID, true, this->currentBlock, fir::Type::getAny(), { any, val });
+		Instruction* instr = make_instr(OpKind::Any_SetTypeID, true, fir::Type::getAny(), { any, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1814,7 +1796,7 @@ namespace fir
 		if(!any->getType()->isAnyType())
 			error("irbuilder: not any type (got '%s')", any->getType());

-		Instruction* instr = make_instr(OpKind::Any_GetData, false, this->currentBlock, fir::ArrayType::get(fir::Type::getInt8(),
+		Instruction* instr = make_instr(OpKind::Any_GetData, false, fir::ArrayType::get(fir::Type::getInt8(),
 			BUILTIN_ANY_DATA_BYTECOUNT), { any });

 		return this->addInstruction(instr, vname);
@@ -1828,7 +1810,7 @@ namespace fir
 		else if(val->getType() != fir::ArrayType::get(fir::Type::getInt8(), BUILTIN_ANY_DATA_BYTECOUNT))
 			error("irbuilder: val is not array type (got '%s')", val->getType());

-		Instruction* instr = make_instr(OpKind::Any_SetData, true, this->currentBlock, fir::Type::getAny(), { any, val });
+		Instruction* instr = make_instr(OpKind::Any_SetData, true, fir::Type::getAny(), { any, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1839,7 +1821,7 @@ namespace fir
 		if(!arr->getType()->isAnyType())
 			error("irbuilder: arr is not an any type (got '%s')", arr->getType());

-		Instruction* instr = make_instr(OpKind::Any_GetRefCountPtr, false, this->currentBlock, fir::Type::getNativeWordPtr(), { arr });
+		Instruction* instr = make_instr(OpKind::Any_GetRefCountPtr, false, fir::Type::getNativeWordPtr(), { arr });

 		return this->addInstruction(instr, vname);
 	}
@@ -1852,7 +1834,7 @@ namespace fir
 		if(val->getType() != fir::Type::getNativeWord()->getPointerTo())
 			error("irbuilder: val is not an int64 pointer");

-		Instruction* instr = make_instr(OpKind::Any_SetRefCountPtr, true, this->currentBlock, arr->getType(), { arr, val });
+		Instruction* instr = make_instr(OpKind::Any_SetRefCountPtr, true, arr->getType(), { arr, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1892,8 +1874,7 @@ namespace fir
 		if(!range->getType()->isRangeType())
 			error("irbuilder: range is not a range type (have '%s')", range->getType());

-		Instruction* instr = make_instr(OpKind::Range_GetLower, false, this->currentBlock,
-			fir::Type::getNativeWord(), { range });
+		Instruction* instr = make_instr(OpKind::Range_GetLower, false, fir::Type::getNativeWord(), { range });

 		return this->addInstruction(instr, vname);
 	}
@@ -1906,8 +1887,7 @@ namespace fir
 		if(!val->getType()->isIntegerType())
 			error("irbuilder: val is not an integer type (got '%s')", val->getType());

-		Instruction* instr = make_instr(OpKind::Range_SetLower, true, this->currentBlock,
-			fir::Type::getRange(), { range, val });
+		Instruction* instr = make_instr(OpKind::Range_SetLower, true, fir::Type::getRange(), { range, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1917,8 +1897,7 @@ namespace fir
 		if(!range->getType()->isRangeType())
 			error("irbuilder: range is not a range type (have '%s')", range->getType());

-		Instruction* instr = make_instr(OpKind::Range_GetUpper, false, this->currentBlock,
-			fir::Type::getNativeWord(), { range });
+		Instruction* instr = make_instr(OpKind::Range_GetUpper, false, fir::Type::getNativeWord(), { range });

 		return this->addInstruction(instr, vname);
 	}
@@ -1931,8 +1910,7 @@ namespace fir
 		if(!val->getType()->isIntegerType())
 			error("irbuilder: val is not an integer type (got '%s')", val->getType());

-		Instruction* instr = make_instr(OpKind::Range_SetUpper, true, this->currentBlock,
-			fir::Type::getRange(), { range, val });
+		Instruction* instr = make_instr(OpKind::Range_SetUpper, true, fir::Type::getRange(), { range, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1942,8 +1920,7 @@ namespace fir
 		if(!range->getType()->isRangeType())
 			error("irbuilder: range is not a range type (have '%s')", range->getType());

-		Instruction* instr = make_instr(OpKind::Range_GetStep, false, this->currentBlock,
-			fir::Type::getNativeWord(), { range });
+		Instruction* instr = make_instr(OpKind::Range_GetStep, false, fir::Type::getNativeWord(), { range });

 		return this->addInstruction(instr, vname);
 	}
@@ -1956,8 +1933,7 @@ namespace fir
 		if(!val->getType()->isIntegerType())
 			error("irbuilder: val is not an integer type (got '%s')", val->getType());

-		Instruction* instr = make_instr(OpKind::Range_SetStep, true, this->currentBlock,
-			fir::Type::getRange(), { range, val });
+		Instruction* instr = make_instr(OpKind::Range_SetStep, true, fir::Type::getRange(), { range, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -1970,8 +1946,7 @@ namespace fir
 		if(!ecs->getType()->isEnumType())
 			error("irbuilder: enum is not an enum type (got '%s')", ecs->getType());

-		Instruction* instr = make_instr(OpKind::Enum_GetIndex, true, this->currentBlock,
-			fir::Type::getNativeWord(), { ecs });
+		Instruction* instr = make_instr(OpKind::Enum_GetIndex, true, fir::Type::getNativeWord(), { ecs });

 		return this->addInstruction(instr, vname);
 	}
@@ -1984,8 +1959,7 @@ namespace fir
 		if(!idx->getType()->isIntegerType())
 			error("irbuilder: index is not an integer type (got '%s')", idx->getType());

-		Instruction* instr = make_instr(OpKind::Enum_SetIndex, true, this->currentBlock,
-			ecs->getType(), { ecs, idx });
+		Instruction* instr = make_instr(OpKind::Enum_SetIndex, true, ecs->getType(), { ecs, idx });

 		return this->addInstruction(instr, vname);
 	}
@@ -1995,8 +1969,7 @@ namespace fir
 		if(!ecs->getType()->isEnumType())
 			error("irbuilder: enum is not an enum type (got '%s')", ecs->getType());

-		Instruction* instr = make_instr(OpKind::Enum_GetValue, true, this->currentBlock,
-			ecs->getType()->toEnumType()->getCaseType(), { ecs });
+		Instruction* instr = make_instr(OpKind::Enum_GetValue, true, ecs->getType()->toEnumType()->getCaseType(), { ecs });

 		return this->addInstruction(instr, vname);
 	}
@@ -2012,8 +1985,7 @@ namespace fir
 				ecs->getType()->toEnumType()->getCaseType(), val->getType());
 		}

-		Instruction* instr = make_instr(OpKind::Enum_SetValue, true, this->currentBlock,
-			ecs->getType(), { ecs, val });
+		Instruction* instr = make_instr(OpKind::Enum_SetValue, true, ecs->getType(), { ecs, val });

 		return this->addInstruction(instr, vname);
 	}
@@ -2029,7 +2001,7 @@ namespace fir
 		if(!ptr->getType()->isPointerType())
 			error("irbuilder: ptr is not pointer type (got '%s')", ptr->getType());

-		Instruction* instr = make_instr(OpKind::Value_ReadPtr, false, this->currentBlock, ptr->getType()->getPointerElementType(), { ptr });
+		Instruction* instr = make_instr(OpKind::Value_ReadPtr, false, ptr->getType()->getPointerElementType(), { ptr });
 		return this->addInstruction(instr, vname);
 	}

@@ -2056,22 +2028,20 @@ namespace fir
 		}


-		Instruction* instr = make_instr(OpKind::Value_WritePtr, true, this->currentBlock, Type::getVoid(), { v, ptr });
+		Instruction* instr = make_instr(OpKind::Value_WritePtr, true, Type::getVoid(), { v, ptr });
 		this->addInstruction(instr, "");
 	}


-	Value* IRBuilder::CreateLValue(Type* type, const std::string& vname)
+	static std::pair<Instruction*, IRBlock*> getInstrThatMakesLValue(IRBuilder* irb, Type* type, const std::string& vname)
 	{
-		// needs to be hoisted also
-		Instruction* instr = make_instr(OpKind::Value_CreateLVal, true, this->currentBlock, type, { ConstantValue::getZeroValue(type) },
-			Value::Kind::lvalue);
+		Instruction* instr = make_instr(OpKind::Value_CreateLVal, true, type, { ConstantValue::getZeroValue(type) }, Value::Kind::lvalue);

 		fir::Value* ret = instr->realOutput;
 		ret->setName(vname);

 		// get the parent function
-		auto parent = this->currentBlock->getParentFunction();
+		auto parent = irb->getCurrentBlock()->getParentFunction();
 		iceAssert(parent);

 		parent->addStackAllocation(type);
@@ -2080,42 +2050,23 @@ namespace fir
 		auto entry = parent->getBlockList().front();
 		iceAssert(entry);

-		// insert at the front (back = no guarantees)
-		entry->instructions.insert(entry->instructions.begin(), instr);
-
-		return ret;
+		return { instr, entry };
 	}

-	Value* IRBuilder::CreateConstLValue(Value* val, const std::string& vname)
-	{
-		// needs to be hoisted also
-		Instruction* instr = make_instr(OpKind::Value_CreateLVal, true, this->currentBlock, val->getType(),
-			{ ConstantValue::getZeroValue(val->getType()) }, Value::Kind::lvalue);
-
-		fir::Value* ret = instr->realOutput;
-		ret->setName(vname);
-
-		this->Store(val, ret);
-		ret->makeConst();
-
-		// get the parent function
-		auto parent = this->currentBlock->getParentFunction();
-		iceAssert(parent);
-
-		parent->addStackAllocation(val->getType());

-		// get the entry block
-		auto entry = parent->getBlockList().front();
-		iceAssert(entry);
+	Value* IRBuilder::CreateLValue(Type* type, const std::string& vname)
+	{
+		auto [ instr, entry ] = getInstrThatMakesLValue(this, type, vname);

-		// insert at the front (back = no guarantees)
+		// needs to be hoisted also
 		entry->instructions.insert(entry->instructions.begin(), instr);
-		return ret;
+
+		return instr->realOutput;
 	}

 	void IRBuilder::Store(Value* val, Value* lval)
 	{
-		if(lval->isclvalue())
+		if(lval->isConst())
 			error("irbuilder: cannot store to constant lvalue");

 		else if(!lval->islvalue())
@@ -2125,7 +2076,7 @@ namespace fir
 			error("irbuilder: cannot store value of type '%s' to lvalue of type '%s'", val->getType(), lval->getType());

 		// ok...
-		Instruction* instr = make_instr(OpKind::Value_Store, true, this->currentBlock, Type::getVoid(), { val, lval });
+		Instruction* instr = make_instr(OpKind::Value_Store, true, Type::getVoid(), { val, lval });
 		this->addInstruction(instr, "");
 	}

@@ -2134,19 +2085,22 @@ namespace fir
 		if(!val->getType()->isPointerType())
 			error("irbuilder: cannot dereference non-pointer type '%s'", val->getType());

-		Instruction* instr = make_instr(OpKind::Value_Dereference, true, this->currentBlock,
-			val->getType()->getPointerElementType(), { val }, val->getType()->isMutablePointer() ? Value::Kind::lvalue : Value::Kind::clvalue);
+		Instruction* instr = make_instr(OpKind::Value_Dereference, true, val->getType()->getPointerElementType(),
+			{ val }, Value::Kind::lvalue);
+
+		if(val->getType()->isImmutablePointer())
+			instr->realOutput->makeConst();

 		return this->addInstruction(instr, vname);
 	}

 	Value* IRBuilder::AddressOf(Value* lval, bool mut, const std::string& vname)
 	{
-		if(!lval->islorclvalue())
+		if(!lval->islvalue())
 			error("irbuilder: cannot take the address of a non-lvalue");

 		// ok...
-		Instruction* instr = make_instr(OpKind::Value_AddressOf, true, this->currentBlock,
+		Instruction* instr = make_instr(OpKind::Value_AddressOf, true,
 			mut ? lval->getType()->getMutablePointerTo() : lval->getType()->getPointerTo(), { lval });
 		return this->addInstruction(instr, vname);
 	}
@@ -2162,7 +2116,7 @@ namespace fir
 		if(data->getType() != ut->getVariant(id)->getInteriorType())
 			error("irbuilder: cannot store data '%s' into union variant '%s'", data->getType(), ut->getVariant(id)->getInteriorType());

-		Instruction* instr = make_instr(OpKind::Union_SetValue, true, this->currentBlock, unn->getType(),
+		Instruction* instr = make_instr(OpKind::Union_SetValue, true, unn->getType(),
 			{ unn, fir::ConstantInt::getNative(id), data });
 		return this->addInstruction(instr, vname);
 	}
@@ -2174,7 +2128,7 @@ namespace fir

 		auto ut = unn->getType()->toUnionType();

-		Instruction* instr = make_instr(OpKind::Union_GetValue, true, this->currentBlock, ut->getVariant(id)->getInteriorType(),
+		Instruction* instr = make_instr(OpKind::Union_GetValue, true, ut->getVariant(id)->getInteriorType(),
 			{ unn, fir::ConstantInt::getNative(id) });
 		return this->addInstruction(instr, vname);
 	}
@@ -2184,7 +2138,7 @@ namespace fir
 		if(!unn->getType()->isUnionType())
 			error("irbuilder: '%s' is not a union type", unn->getType());

-		Instruction* instr = make_instr(OpKind::Union_GetVariantID, true, this->currentBlock, fir::Type::getNativeWord(), { unn });
+		Instruction* instr = make_instr(OpKind::Union_GetVariantID, true, fir::Type::getNativeWord(), { unn });
 		return this->addInstruction(instr, vname);
 	}

@@ -2193,7 +2147,7 @@ namespace fir
 		if(!unn->getType()->isUnionType())
 			error("irbuilder: '%s' is not a union type", unn->getType());

-		Instruction* instr = make_instr(OpKind::Union_SetVariantID, true, this->currentBlock, unn->getType(),
+		Instruction* instr = make_instr(OpKind::Union_SetVariantID, true, unn->getType(),
 			{ unn, fir::ConstantInt::getNative(id) });

 		return this->addInstruction(instr, vname);
@@ -2229,7 +2183,7 @@ namespace fir

 	void IRBuilder::Unreachable()
 	{
-		this->addInstruction(make_instr(OpKind::Unreachable, true, this->currentBlock, fir::Type::getVoid(), { }), "");
+		this->addInstruction(make_instr(OpKind::Unreachable, true, fir::Type::getVoid(), { }), "");
 	}

 	IRBlock* IRBuilder::addNewBlockInFunction(std::string name, Function* func)
diff --git a/source/fir/Instruction.cpp b/source/fir/Instruction.cpp
index 465ac7e6a..1fc3401a8 100644
--- a/source/fir/Instruction.cpp
+++ b/source/fir/Instruction.cpp
@@ -14,15 +14,14 @@ namespace fir
 	static util::MemoryPool<Value> value_pool(65536);


-	Instruction::Instruction(OpKind kind, bool sideeff, IRBlock* parent, Type* out, const std::vector<Value*>& vals)
-		: Instruction(kind, sideeff, parent, out, vals, Value::Kind::rvalue) { }
+	Instruction::Instruction(OpKind kind, bool sideeff, Type* out, const std::vector<Value*>& vals)
+		: Instruction(kind, sideeff, out, vals, Value::Kind::prvalue) { }

-	Instruction::Instruction(OpKind kind, bool sideeff, IRBlock* parent, Type* out, const std::vector<Value*>& vals, Value::Kind k) : Value(out)
+	Instruction::Instruction(OpKind kind, bool sideeff, Type* out, const std::vector<Value*>& vals, Value::Kind k) : Value(out)
 	{
 		this->opKind = kind;
 		this->operands = vals;
 		this->sideEffects = sideeff;
-		this->parentBlock = parent;
 		this->realOutput = value_pool.construct(out, k);
 	}

@@ -238,7 +237,9 @@ namespace fir
 				else
 				{
 					auto name = op->getName().str();
-					ops += name + (name.empty() ? "" : " ") + "(%" + std::to_string(op->id) + ") :: " + op->getType()->str();
+					if(name.empty()) name += " ";
+
+					ops += strprintf("%s(%s%%%d) :: %s", name, op->islvalue() ? "*" : "", op->id, op->getType());
 				}

 				if(!didfn)
diff --git a/source/fir/Module.cpp b/source/fir/Module.cpp
index 319377513..99d765a20 100644
--- a/source/fir/Module.cpp
+++ b/source/fir/Module.cpp
@@ -288,7 +288,7 @@ namespace fir
 		GlobalVariable* gs = new GlobalVariable(Identifier("static_string" + std::to_string(stringId++), IdKind::Name), this,
 			Type::getInt8Ptr(), true, LinkageType::Internal, 0);

-		gs->setKind(Value::Kind::literal);
+		gs->setKind(Value::Kind::prvalue);
 		return (this->globalStrings[str] = gs);
 	}

diff --git a/source/fir/Types/ClassType.cpp b/source/fir/Types/ClassType.cpp
index 2e63e63fb..41de369be 100644
--- a/source/fir/Types/ClassType.cpp
+++ b/source/fir/Types/ClassType.cpp
@@ -172,7 +172,10 @@ namespace fir
 		return ret;
 	}

-
+	const util::hash_map<std::string, size_t>& ClassType::getElementNameMap()
+	{
+		return this->indexMap;
+	}



@@ -186,6 +189,40 @@ namespace fir
 		return this->initialiserList;
 	}

+	void ClassType::setDestructor(Function* f)
+	{
+		this->destructor = f;
+	}
+
+	void ClassType::setCopyConstructor(Function* f)
+	{
+		this->copyConstructor = f;
+	}
+
+	void ClassType::setMoveConstructor(Function* f)
+	{
+		this->moveConstructor = f;
+	}
+
+
+	Function* ClassType::getDestructor()
+	{
+		return this->destructor;
+	}
+
+	Function* ClassType::getCopyConstructor()
+	{
+		return this->copyConstructor;
+	}
+
+	Function* ClassType::getMoveConstructor()
+	{
+		return this->moveConstructor;
+	}
+
+
+
+
 	const std::vector<Function*>& ClassType::getMethods()
 	{
 		return this->methodList;
@@ -353,6 +390,18 @@ namespace fir
 		this->inlineInitialiser = fn;
 	}

+
+	Function* ClassType::getInlineDestructor()
+	{
+		return this->inlineDestructor;
+	}
+
+	void ClassType::setInlineDestructor(Function* fn)
+	{
+		this->inlineDestructor = fn;
+	}
+
+
 	fir::Type* ClassType::substitutePlaceholders(const util::hash_map<fir::Type*, fir::Type*>& subst)
 	{
 		if(this->containsPlaceholders())
diff --git a/source/fir/interp/interpreter.cpp b/source/fir/interp/interpreter.cpp
index f1961f669..0781c3492 100644
--- a/source/fir/interp/interpreter.cpp
+++ b/source/fir/interp/interpreter.cpp
@@ -1168,7 +1168,6 @@ namespace interp
 		}

 		error("interp: invaild state");
-		return interp::Value();
 	}


@@ -1229,7 +1228,6 @@ namespace interp

 	static interp::Value performGEP2(InterpState* is, fir::Type* resty, const interp::Value& ptr, const interp::Value& i1, const interp::Value& i2)
 	{
-
 		iceAssert(i1.type == i2.type);

 		// so, ptr should be a pointer to an array.
@@ -1239,7 +1237,7 @@ namespace interp
 		auto elmty = arrty->getArrayElementType();

 		auto ofs = twoArgumentOp(is, resty, i1, i2, [arrty, elmty](auto a, auto b) -> auto {
-			return (a * getSizeOfType(arrty)) + (b * getSizeOfType(elmty));
+			return (getSizeOfType(arrty) * a) + (getSizeOfType(elmty) * b);
 		});

 		auto realptr = getActualValue<uintptr_t>(ptr);
@@ -1280,7 +1278,7 @@ namespace interp

 	static interp::Value decay(const interp::Value& val)
 	{
-		if(val.val && val.val->islorclvalue())
+		if(val.val && val.val->islvalue())
 		{
 			auto ret = loadFromPtr(val, val.val->getType());
 			ret.val = val.val;
@@ -1981,7 +1979,7 @@ namespace interp
 				setRet(is, inst, oneArgumentOp(is, inst, b, [realptr, elmty](auto b) -> auto {
 					// this doesn't do pointer arithmetic!! if it's a pointer type, the value we get
 					// will be a uintptr_t.
-					return realptr + (b * getSizeOfType(elmty));
+					return realptr + (getSizeOfType(elmty) * b);
 				}));

 				break;
@@ -2070,8 +2068,6 @@ namespace interp
 				auto a = getArg(is, inst, 0);
 				auto b = getUndecayedArg(is, inst, 1);

-				iceAssert(inst.args[1]->islorclvalue());
-
 				auto ptr = (void*) getActualValue<uintptr_t>(b);
 				if(a.dataSize > LARGE_DATA_SIZE)    memmove(ptr, a.ptr, a.dataSize);
 				else                                memmove(ptr, &a.data[0], a.dataSize);
@@ -2470,8 +2466,6 @@ namespace interp
 				iceAssert(inst.args.size() == 2);
 				auto targtype = inst.args[1]->getType();

-				iceAssert(inst.args[0]->islorclvalue());
-
 				// again. just manipulate the memory.
 				auto unn = getUndecayedArg(is, inst, 0);
 				auto buffer = getActualValue<uintptr_t>(unn);
diff --git a/source/frontend/parser/expr.cpp b/source/frontend/parser/expr.cpp
index ae5d07cfe..fa399a482 100644
--- a/source/frontend/parser/expr.cpp
+++ b/source/frontend/parser/expr.cpp
@@ -31,17 +31,17 @@ namespace parser

 		st.pop();
 		auto stmt = parseStmt(st, /* allowExprs: */ false);
-		if(auto defn = dcast(FuncDefn, stmt))
-			defn->visibility = vis;
+		if(auto fd = dcast(FuncDefn, stmt))
+			fd->visibility = vis;

-		else if(auto defn = dcast(ForeignFuncDefn, stmt))
-			defn->visibility = vis;
+		else if(auto ffd = dcast(ForeignFuncDefn, stmt))
+			ffd->visibility = vis;

-		else if(auto defn = dcast(VarDefn, stmt))
-			defn->visibility = vis;
+		else if(auto vd = dcast(VarDefn, stmt))
+			vd->visibility = vis;

-		else if(auto defn = dcast(TypeDefn, stmt))
-			defn->visibility = vis;
+		else if(auto td = dcast(TypeDefn, stmt))
+			td->visibility = vis;

 		else
 			error(st, "access specifier cannot be applied to this statement");
@@ -444,7 +444,7 @@ namespace parser
 				if(auto it = st.binaryOps.find(st.front().str()); it != st.binaryOps.end())
 					return it->second.precedence;

-				else if(auto it = st.postfixOps.find(st.front().str()); it != st.postfixOps.end())
+				else if(it = st.postfixOps.find(st.front().str()); it != st.postfixOps.end())
 					return it->second.precedence;

 				return -1;
diff --git a/source/frontend/parser/toplevel.cpp b/source/frontend/parser/toplevel.cpp
index 335b34266..23f766cbb 100644
--- a/source/frontend/parser/toplevel.cpp
+++ b/source/frontend/parser/toplevel.cpp
@@ -160,7 +160,7 @@ namespace parser

 					auto ns = parseTopLevel(st, tok.str());
 					if(priv != VisibilityLevel::Invalid)
-						ns->visibility = priv, priv = VisibilityLevel::Invalid, tix = -1;
+						ns->visibility = priv, priv = VisibilityLevel::Invalid, tix = (size_t) -1;

 					root->statements.push_back(ns);

@@ -243,7 +243,7 @@ namespace parser
 					{
 						st.rewindTo(tix);

-						tix = -1;
+						tix = (size_t) -1;
 						priv = VisibilityLevel::Invalid;
 					}

diff --git a/source/frontend/parser/type.cpp b/source/frontend/parser/type.cpp
index c4629775d..8db180465 100644
--- a/source/frontend/parser/type.cpp
+++ b/source/frontend/parser/type.cpp
@@ -97,12 +97,12 @@ namespace parser
 			{
 				defn->nestedTypes.push_back(t);
 			}
-			else if(auto st = dcast(StaticDecl, s))
+			else if(auto sd = dcast(StaticDecl, s))
 			{
-				if(auto fn = dcast(FuncDefn, st->actual))
+				if(auto fn = dcast(FuncDefn, sd->actual))
 					defn->staticMethods.push_back(fn);

-				else if(auto vr = dcast(VarDefn, st->actual))
+				else if(auto vr = dcast(VarDefn, sd->actual))
 					defn->staticFields.push_back(vr);

 				else
@@ -113,19 +113,34 @@ namespace parser
 				addSelfToMethod(init, /* mutating: */ true);

 				if(init->name == "init")
+				{
 					defn->initialisers.push_back(init);
-
+				}
 				else if(init->name == "deinit")
-					defn->deinitialiser = init;
+				{
+					if(defn->deinitialiser)
+						error(init, "deinitialisers cannot be overloaded");

+					defn->deinitialiser = init;
+				}
 				else if(init->name == "copy")
-					defn->copyInitialiser = init;
+				{
+					if(defn->copyInitialiser)
+						error(init, "copy initialisers cannot be overloaded");

+					defn->copyInitialiser = init;
+				}
 				else if(init->name == "move")
-					defn->moveInitialiser = init;
+				{
+					if(defn->moveInitialiser)
+						error(init, "move initialisers cannot be overloaded");

+					defn->moveInitialiser = init;
+				}
 				else
+				{
 					error(s, "wtf? '%s'", init->name);
+				}
 			}
 			else
 			{
@@ -133,8 +148,8 @@ namespace parser
 			}
 		}

-		for(auto s : blk->deferredStatements)
-			error(s, "unsupported expression or statement in class body");
+		if(!blk->deferredStatements.empty())
+			error(blk->deferredStatements[0], "unsupported expression or statement in class body");

 		st.leaveStructBody();
 		return defn;
diff --git a/source/include/codegen.h b/source/include/codegen.h
index dc65c5962..d28dd6b65 100644
--- a/source/include/codegen.h
+++ b/source/include/codegen.h
@@ -56,7 +56,7 @@ namespace cgn
 		sst::Block* block = 0;

 		std::vector<fir::Value*> refCountedValues;
-		std::vector<fir::Value*> refCountedPointers;
+		std::vector<fir::Value*> raiiValues;
 	};

 	struct CodegenState
@@ -140,8 +140,7 @@ namespace cgn
 		fir::Value* getDefaultValue(fir::Type* type);

 		fir::Value* getConstructedStructValue(fir::StructType* str, const std::vector<FnCallArgument>& args);
-		void constructClassWithArguments(fir::ClassType* cls, sst::FunctionDefn* constr, fir::Value* selfptr, const std::vector<FnCallArgument>& args,
-			bool callInlineInitialiser);
+		fir::Value* constructClassWithArguments(fir::ClassType* cls, sst::FunctionDefn* constr, const std::vector<FnCallArgument>& args);

 		fir::Value* callVirtualMethod(sst::FunctionCall* call);

@@ -166,7 +165,7 @@ namespace cgn



-		void addVariableUsingStorage(sst::VarDefn* var, fir::Value* ptr, CGResult val);
+		void addVariableUsingStorage(sst::VarDefn* var, fir::Value* ptr);

 		void createWhileLoop(const std::function<void (fir::IRBlock*, fir::IRBlock*)>& check, const std::function<void ()>& body);

@@ -177,18 +176,22 @@ namespace cgn
 		void decrementRefCount(fir::Value* val);

 		void addRefCountedValue(fir::Value* val);
-		void removeRefCountedValue(fir::Value* val, bool ignoreMissing = false);
-
-		void addRefCountedPointer(fir::Value* ptr);
-		void removeRefCountedPointer(fir::Value* ptr, bool ignoreMissing = false);
+		void removeRefCountedValue(fir::Value* val);

 		std::vector<fir::Value*> getRefCountedValues();
-		std::vector<fir::Value*> getRefCountedPointers();

-		void performRefCountingAssignment(fir::Value* lhs, fir::Value* rhs, bool isInitial);
-		void moveRefCountedValue(fir::Value* lhs, fir::Value* rhs, bool isInitial);
+		void autoAssignRefCountedValue(fir::Value* lhs, fir::Value* rhs, bool isInitial);
+
+
+		void addRAIIValue(fir::Value* val);
+		void removeRAIIValue(fir::Value* val);
+		std::vector<fir::Value*> getRAIIValues();
+
+		void callDestructor(fir::Value* val);

-		void autoAssignRefCountedValue(fir::Value* lhs, fir::Value* rhs, bool isInitial, bool performStore);
+		fir::Value* copyRAIIValue(fir::Value* value);
+		void copyRAIIValue(fir::Value* from, fir::Value* target, bool enableMoving = true);
+		void moveRAIIValue(fir::Value* from, fir::Value* target);
 	};

 	fir::Module* codegen(sst::DefinitionTree* __std_exception_destroy);
diff --git a/source/include/defs.h b/source/include/defs.h
index d737cd1ea..9534155f7 100644
--- a/source/include/defs.h
+++ b/source/include/defs.h
@@ -10,8 +10,6 @@
 #include <string.h>

 #include "utils.h"
-#include "precompile.h"
-

 #ifndef __has_include
 #error "Please switch to a compiler that supports '__has_include'"
diff --git a/source/include/ir/function.h b/source/include/ir/function.h
index 3ad15d402..5278f6c92 100644
--- a/source/include/ir/function.h
+++ b/source/include/ir/function.h
@@ -53,7 +53,7 @@ namespace fir

 		Type* getReturnType();
 		size_t getArgumentCount();
-		std::vector<Argument*> getArguments();
+		const std::vector<Argument*>& getArguments();
 		Argument* getArgumentWithName(std::string name);

 		std::vector<IRBlock*>& getBlockList();
@@ -71,7 +71,7 @@ namespace fir
 		// this is used so the function knows how much space it needs to reserve for
 		// allocas.
 		void addStackAllocation(Type* ty);
-		std::vector<Type*> getStackAllocations();
+		const std::vector<Type*>& getStackAllocations();

 		void cullUnusedValues();

diff --git a/source/include/ir/instruction.h b/source/include/ir/instruction.h
index 60a6c54e5..56c0faa43 100644
--- a/source/include/ir/instruction.h
+++ b/source/include/ir/instruction.h
@@ -178,8 +178,8 @@ namespace fir
 		friend struct Module;
 		friend struct IRBuilder;

-		Instruction(OpKind kind, bool sideEffects, IRBlock* parent, Type* out, const std::vector<Value*>& vals);
-		Instruction(OpKind kind, bool sideEffects, IRBlock* parent, Type* out, const std::vector<Value*>& vals, Value::Kind k);
+		Instruction(OpKind kind, bool sideEffects, Type* out, const std::vector<Value*>& vals);
+		Instruction(OpKind kind, bool sideEffects, Type* out, const std::vector<Value*>& vals, Value::Kind k);
 		std::string str();

 		Value* getResult();
@@ -196,7 +196,6 @@ namespace fir

 		bool sideEffects;
 		Value* realOutput;
-		IRBlock* parentBlock;
 		std::vector<Value*> operands;
 	};
 }
diff --git a/source/include/ir/irbuilder.h b/source/include/ir/irbuilder.h
index 30fa833bb..cbb7694d3 100644
--- a/source/include/ir/irbuilder.h
+++ b/source/include/ir/irbuilder.h
@@ -204,7 +204,6 @@ namespace fir

 		void Store(Value* val, Value* lval);
 		Value* CreateLValue(Type* t, const std::string& vname = "");
-		Value* CreateConstLValue(Value* v, const std::string& vname = "");

 		Value* Dereference(Value* val, const std::string& vname = "");
 		Value* AddressOf(Value* lval, bool mut, const std::string& vname = "");
diff --git a/source/include/ir/type.h b/source/include/ir/type.h
index 662cfb6a6..5debb56e8 100644
--- a/source/include/ir/type.h
+++ b/source/include/ir/type.h
@@ -696,6 +696,8 @@ namespace fir
 		const std::vector<Type*>& getElements();
 		std::vector<Type*> getAllElementsIncludingBase();

+		const util::hash_map<std::string, size_t>& getElementNameMap();
+
 		const std::vector<Function*>& getMethods();
 		std::vector<Function*> getMethodsWithName(std::string id);
 		Function* getMethodWithType(FunctionType* ftype);
@@ -706,12 +708,23 @@ namespace fir
 		Function* getInlineInitialiser();
 		void setInlineInitialiser(Function* fn);

+		Function* getInlineDestructor();
+		void setInlineDestructor(Function* fn);
+
 		void setMembers(const std::vector<std::pair<std::string, Type*>>& members);
 		void setMethods(const std::vector<Function*>& methods);

 		ClassType* getBaseClass();
 		void setBaseClass(ClassType* ty);

+		void setDestructor(Function* f);
+		void setCopyConstructor(Function* f);
+		void setMoveConstructor(Function* f);
+
+		Function* getDestructor();
+		Function* getCopyConstructor();
+		Function* getMoveConstructor();
+
 		bool isInParentHierarchy(Type* base);

 		void addVirtualMethod(Function* method);
@@ -754,7 +767,13 @@ namespace fir
 		std::map<std::pair<std::string, std::vector<Type*>>, size_t> virtualMethodMap;

 		ClassType* baseClass = 0;
+
 		Function* inlineInitialiser = 0;
+		Function* inlineDestructor = 0;
+
+		Function* destructor = 0;
+		Function* copyConstructor = 0;
+		Function* moveConstructor = 0;

 		// static funcs
 		public:
diff --git a/source/include/ir/value.h b/source/include/ir/value.h
index 81e7faf2a..ba08770fb 100644
--- a/source/include/ir/value.h
+++ b/source/include/ir/value.h
@@ -44,13 +44,12 @@ namespace fir
 		friend struct util::MemoryPool<Value>;
 		friend struct util::FastInsertVector<Value>;

-		//? might be renamed when we need more value categories.
+		// congratulations, i fucking played myself.
 		enum class Kind
 		{
-			lvalue,     // lvalue. same as c
-			rvalue,     // same as c.
-			clvalue,    // const lvalue
-			literal     // literal value. mostly simplifies reference counting.
+			lvalue,     // has identity, cannot be moved from
+			xvalue,     // has identity, can be moved from
+			prvalue,    // no identity, can be moved from
 		};

 		// virtual funcs
@@ -59,12 +58,10 @@ namespace fir
 		void setKind(Kind k)    { this->kind = k; }

 		bool islvalue()     { return this->kind == Kind::lvalue; }
-		bool isrvalue()     { return this->kind == Kind::rvalue; }
-		bool isclvalue()    { return this->kind == Kind::clvalue; }
-		bool islorclvalue() { return this->islvalue() || this->isclvalue(); }
-		bool isLiteral()    { return this->kind == Kind::literal; }
+		bool canmove()      { return this->kind == Kind::xvalue || this->kind == Kind::prvalue; }

-		void makeConst()    { iceAssert(this->islvalue()); this->kind = Kind::clvalue; }
+		bool isConst()      { return this->isconst; }
+		void makeConst()    { this->isconst = true; }

 		// methods
 		void setName(const Identifier& idt);
@@ -77,13 +74,14 @@ namespace fir
 		// protected shit
 		size_t id;
 		protected:
-		Value(Type* type, Kind k = Kind::rvalue);
+		Value(Type* type, Kind k = Kind::prvalue);
 		virtual ~Value() { }

 		// fields
 		Identifier ident;
 		Type* valueType;
 		Kind kind;
+		bool isconst = false;
 	};

 	struct PHINode : Value
diff --git a/source/include/platform.h b/source/include/platform.h
index 18783c938..8cf93f2bf 100644
--- a/source/include/platform.h
+++ b/source/include/platform.h
@@ -30,6 +30,16 @@ namespace platform
 		#error "invalid host os!"
 	#endif

+	#if defined(__x86_64__) || defined(__aarch64__) || defined(_M_X64)
+		#define ARCH_64 1
+		#define ARCH_32 0
+	#else
+		#define ARCH_32 1
+		#define ARCH_64 0
+	#endif
+
+
+

 	#if OS_WINDOWS
 		using filehandle_t = void*;
diff --git a/source/include/precompile.cpp b/source/include/precompile.cpp
deleted file mode 100644
index be66d092d..000000000
--- a/source/include/precompile.cpp
+++ /dev/null
@@ -1,5 +0,0 @@
-#if !defined(_MSC_VER)
-
-#endif
-
-#include "precompile.h"
diff --git a/source/include/sst.h b/source/include/sst.h
index 5fe53491c..3cdda5c4c 100644
--- a/source/include/sst.h
+++ b/source/include/sst.h
@@ -7,8 +7,11 @@
 #include "sst_expr.h"
 #include "stcommon.h"

+
 #include "mpreal/mpreal.h"

+
+
 namespace fir
 {
 	struct Type;
@@ -743,8 +746,6 @@ namespace sst
 		std::vector<TypeDefn*> nestedTypes;
 		std::vector<VarDefn*> staticFields;
 		std::vector<FunctionDefn*> staticMethods;
-
-		fir::Function* inlineInitFunction = 0;
 		std::vector<FunctionDefn*> initialisers;

 		FunctionDefn* deinitialiser = 0;
diff --git a/source/misc/identifier.cpp b/source/misc/identifier.cpp
index b4c851fe6..3d1d5a1bc 100644
--- a/source/misc/identifier.cpp
+++ b/source/misc/identifier.cpp
@@ -53,7 +53,7 @@ void PolyArgMapping_t::add(const std::string& name, pts::Type* t)
 	SingleArg arg;
 	arg.name = name;
 	arg.type = t;
-	arg.index = -1;
+	arg.index = (size_t) -1;

 	this->maps.push_back(arg);
 }
diff --git a/source/platform/compiler.cpp b/source/platform/compiler.cpp
index 72c091b4f..234bba3e2 100644
--- a/source/platform/compiler.cpp
+++ b/source/platform/compiler.cpp
@@ -57,6 +57,7 @@ namespace compiler
 			{
 				// these dumb paths have spaces in them, so we need to quote it.
 				// link.exe handles its own de-quoting, not cmd.exe or whatever shell.
+
 				auto sdkRoot = strprintf("\"%s\"", getWindowsSDKLocation());
 				auto vsLibRoot = strprintf("\"%s\"", getVSToolchainLibLocation());

diff --git a/source/platform/msvcfinder.cpp b/source/platform/msvcfinder.cpp
index 295ff8ef6..b02e6be62 100644
--- a/source/platform/msvcfinder.cpp
+++ b/source/platform/msvcfinder.cpp
@@ -74,12 +74,10 @@ namespace compiler
 		std::string vsLibDirectory;
 	};

-	static bool checkDirectoryExists(const std::wstring& name)
+	static bool checkFileExists(const std::wstring& name)
 	{
 		auto attrib = GetFileAttributesW(name.c_str());
-		if(attrib == INVALID_FILE_ATTRIBUTES)   return false;
-
-		return (attrib & FILE_ATTRIBUTE_DIRECTORY);
+		return attrib != INVALID_FILE_ATTRIBUTES;
 	}

 	static bool visitFiles(const std::wstring& dir, VersionData* vd, std::function<void (const std::wstring& shortName,
@@ -170,31 +168,14 @@ namespace compiler
 		auto gots = swscanf_s(shortName.c_str(), L"%d.%d.%d.%d", &i0, &i1, &i2, &i3);
 		if(gots < 4) return;

-		if(i0 < vd->bestVersion[0])
-		{
+		auto b0 = vd->bestVersion[0];
+		auto b1 = vd->bestVersion[1];
+		auto b2 = vd->bestVersion[2];
+		auto b3 = vd->bestVersion[3];
+
+		// short-circuiting ftw.
+		if((b0 > i0) || (b1 > i1) || (b2 > i2) || (b3 > i3))
 			return;
-		}
-		else if(i0 == vd->bestVersion[0])
-		{
-			if(i1 < vd->bestVersion[1])
-			{
-				return;
-			}
-			else if(i1 == vd->bestVersion[1])
-			{
-				if(i2 < vd->bestVersion[2])
-				{
-					return;
-				}
-				else if(i2 == vd->bestVersion[2])
-				{
-					if(i3 < vd->bestVersion[3])
-					{
-						return;
-					}
-				}
-			}
-		}

 		vd->bestName = fullName;
 		vd->bestVersion[0] = i0;
@@ -213,17 +194,12 @@ namespace compiler
 		if(gots < 2)
 			return;

-		if(i0 < vd->bestVersion[0])
-		{
+		auto b0 = vd->bestVersion[0];
+		auto b1 = vd->bestVersion[1];
+
+		// short-circuiting ftw.
+		if((b0 > i0) || (b1 > i1))
 			return;
-		}
-		else if(i0 == vd->bestVersion[0])
-		{
-			if(i1 < vd->bestVersion[1])
-			{
-				return;
-			}
-		}

 		vd->bestName = fullName;
 		vd->bestVersion[0] = i0;
@@ -250,6 +226,8 @@ namespace compiler
 			auto win10lib = win10root + L"Lib";

 			VersionData vd;
+			memset(&vd, 0, sizeof(VersionData));
+
 			visitFiles(win10lib, &vd, &getBestWin10Version);

 			if(!vd.bestName.empty())
@@ -267,6 +245,8 @@ namespace compiler
 			auto win10lib = win10root + L"Lib";

 			VersionData vd;
+			memset(&vd, 0, sizeof(VersionData));
+
 			visitFiles(win10lib, &vd, &getBestWin8Version);

 			if(!vd.bestName.empty())
@@ -324,6 +304,7 @@ namespace compiler
 		ISetupInstance* inst = 0;
 		uint64_t newestVersionNum = 0;

+		// we look for the newest version that's installed, as opposed to the first.
 		while(true)
 		{
 			ISetupInstance* instance = NULL;
@@ -356,7 +337,6 @@ namespace compiler
 		if(!inst)
 			return false;

-
 		std::string vsRoot;
 		{
 			BSTR tmp;
@@ -365,6 +345,8 @@ namespace compiler

 			vsRoot = convertWCharToString(std::wstring(tmp));
 			SysFreeString(tmp);
+
+			inst->Release();
 		}

 		std::string toolchainVersion;
@@ -378,10 +360,10 @@ namespace compiler
 		}

 		std::string toolchainPath = strprintf("%s\\Tools\\MSVC\\%s", vsRoot, toolchainVersion);
-		if(checkDirectoryExists(convertStringToWChar(toolchainPath)))
+		if(checkFileExists(convertStringToWChar(toolchainPath)))
 		{
-			// TODO: check the target arch!!!
-			result->vsBinDirectory = strprintf("%s\\bin\\Hostx64", toolchainPath);
+			//* this is *HOST* architecture, so we can just use our defines.
+			result->vsBinDirectory = strprintf("%s\\bin\\Host%s", toolchainPath, ARCH_64 ? "x64" : "x86");
 			result->vsLibDirectory = strprintf("%s\\lib", toolchainPath);

 			return true;
@@ -400,6 +382,8 @@ namespace compiler

 		if(!cached)
 		{
+			memset(&cachedResult, 0, sizeof(FindResult));
+
 			findWindowsKitRoot(&cachedResult);
 			auto found = findVSToolchain(&cachedResult);
 			if(!found) error("backend: failed to find installed Visual Studio location!");
diff --git a/source/platform/platform.cpp b/source/platform/platform.cpp
index 7ff654041..2208a2dca 100644
--- a/source/platform/platform.cpp
+++ b/source/platform/platform.cpp
@@ -3,6 +3,7 @@
 // Licensed under the Apache License Version 2.0.

 #include <fcntl.h>
+#include <stdlib.h>

 #include "errors.h"
 #include "frontend.h"
@@ -50,9 +51,21 @@ namespace platform

 	std::string getEnvironmentVar(const std::string& name)
 	{
-		auto ret = std::getenv(name.c_str());
-		if(ret) return std::string(ret);
-		else    return "";
+		char buffer[256] = { 0 };
+		size_t len = 0;
+
+	#if OS_WINDOWS
+		if(getenv_s(&len, buffer, name.c_str()) != 0)
+	#else
+		if(getenv(name.c_str()) == 0)
+	#endif
+		{
+			return "";
+		}
+		else
+		{
+			return std::string(buffer, len);
+		}
 	}

 	void pushEnvironmentVar(const std::string& name, const std::string& value)
@@ -220,7 +233,6 @@ namespace platform
 			{
 				perror("there was an error reading the file");
 				error("expected %d bytes, but read only %d", fileLength, didRead);
-				exit(-1);
 			}
 		}

diff --git a/source/typecheck/controlflow.cpp b/source/typecheck/controlflow.cpp
index 2e46077e5..1a91e276c 100644
--- a/source/typecheck/controlflow.cpp
+++ b/source/typecheck/controlflow.cpp
@@ -124,8 +124,6 @@ static bool checkBlockPathsReturn(sst::TypecheckState* fs, sst::Block* block, fi
 				SimpleError::make(block->statements[i + 1]->loc, "unreachable code after return statement")
 					->append(SimpleError::make(MsgType::Note, retstmt->loc, "return statement was here:"))
 					->postAndQuit();;
-
-				doTheExit();
 			}
 		}
 		else /* if(i == block->statements.size() - 1) */
diff --git a/source/typecheck/dotop.cpp b/source/typecheck/dotop.cpp
index e24ce9496..0d3e0f398 100644
--- a/source/typecheck/dotop.cpp
+++ b/source/typecheck/dotop.cpp
@@ -911,7 +911,6 @@ static sst::Expr* doStaticDotOp(sst::TypecheckState* fs, ast::DotOperator* dot,
 	}

 	error("????!!!!");
-	return 0;
 }


diff --git a/source/typecheck/polymorph/solver.cpp b/source/typecheck/polymorph/solver.cpp
index 39c650e08..f7c9149da 100644
--- a/source/typecheck/polymorph/solver.cpp
+++ b/source/typecheck/polymorph/solver.cpp
@@ -42,7 +42,7 @@ namespace sst
 			else
 			{
 				// limit decomposition of the given types by the number of transforms on the target type.
-				auto [ tt, ttrfs ] = internal::decomposeIntoTransforms(tgt, -1);
+				auto [ tt, ttrfs ] = internal::decomposeIntoTransforms(tgt, (size_t) -1);
 				auto [ gt, gtrfs ] = internal::decomposeIntoTransforms(gvn, ttrfs.size());

 				// if(ttrfs != gtrfs)
diff --git a/source/typecheck/type.cpp b/source/typecheck/type.cpp
index d005f49b0..401b49dad 100644
--- a/source/typecheck/type.cpp
+++ b/source/typecheck/type.cpp
@@ -186,60 +186,55 @@ namespace sst
 					}


-					{
-						auto d = defs[0];
+					auto d = defs[0];

-						auto tyd = dcast(TypeDefn, d);
-						if(!tyd)
+					auto tyd = dcast(TypeDefn, d);
+					if(!tyd)
+					{
+						// helpful error message: see if there's a actually a type further up!
+						ErrorMsg* extraHelp = 0;
 						{
-							// helpful error message: see if there's a actually a type further up!
-							ErrorMsg* extraHelp = 0;
+							auto t = tree->parent;
+							while(!extraHelp && t)
 							{
-								auto t = tree->parent;
-								while(!extraHelp && t)
+								if(auto ds = t->getDefinitionsWithName(name); ds.size() > 0)
 								{
-									if(auto ds = t->getDefinitionsWithName(name); ds.size() > 0)
+									for(const auto& d : ds)
 									{
-										for(const auto& d : ds)
+										if(dcast(sst::TypeDefn, d))
 										{
-											if(dcast(sst::TypeDefn, d))
+											std::vector<std::string> ss;
+											auto t1 = tree;
+											while(t1 != t)
 											{
-												std::vector<std::string> ss;
-												auto t1 = tree;
-												while(t1 != t)
-												{
-													t1 = t1->parent;
-													if(!t1->isAnonymous)
-														ss.push_back("^");
-												}
-
-												ss.push_back(name);
-
-												extraHelp = SimpleError::make(MsgType::Note, d->loc,
-													"'%s' was defined as a type in the parent scope, here:", name)
-													->append(BareError::make(MsgType::Note, "to refer to it, use '%s'", util::serialiseScope(ss)));
+												t1 = t1->parent;
+												if(!t1->isAnonymous)
+													ss.push_back("^");
 											}
+
+											ss.push_back(name);
+
+											extraHelp = SimpleError::make(MsgType::Note, d->loc,
+												"'%s' was defined as a type in the parent scope, here:", name)
+												->append(BareError::make(MsgType::Note, "to refer to it, use '%s'", util::serialiseScope(ss)));
 										}
 									}
-
-									t = t->parent;
 								}
-							}

-							//* example of something 'wrong'
-							auto err = SimpleError::make(this->loc(), "definition of '%s' cannot be used as a type", d->id.name)
-								->append(SimpleError::make(MsgType::Note, d->loc, "'%s' was defined here:", d->id.name));
+								t = t->parent;
+							}
+						}

-							if(extraHelp) err->append(extraHelp);
+						//* example of something 'wrong'
+						auto err = SimpleError::make(this->loc(), "definition of '%s' cannot be used as a type", d->id.name)
+							->append(SimpleError::make(MsgType::Note, d->loc, "'%s' was defined here:", d->id.name));

-							err->postAndQuit();
-						}
+						if(extraHelp) err->append(extraHelp);

-						return tyd->type;
+						err->postAndQuit();
 					}

-					iceAssert(0);
-					return 0;
+					return tyd->type;
 				};


